<?xml version="1.0"?>
<process-model model-name="cmac_process" code-language="C" tv-in-db="yes" tv-in-tb="yes">
	<OPNET-info OPNET-release="12.0.A" OPNET-patchlevel="5" OPNET-model-data-version="10.7.A"/>
	<model-attributes>
		<attribute name="Wireless LAN Parameters" type="compound">
			<properties type="compound" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="Default"/>
				<symbol-map>
					<symbol name="Default">
						<sub-object>
							<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
							<attribute creation-mechanics="Model" name="list" type="object list">
								<object-list>
									<sub-object>
										<attribute creation-mechanics="Model" name="Channel Settings" type="compound">
											<sub-object>
												<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
												<attribute creation-mechanics="Model" name="list" type="object list">
													<object-list>
														<sub-object/>
													</object-list>
												</attribute>
											</sub-object>
										</attribute>
									</sub-object>
								</object-list>
							</attribute>
						</sub-object>
					</symbol>
				</symbol-map>
				<comments>
<![CDATA[
Specifies parameters used by 
the Wireless LAN Protocol 
(WLAN). WLAN is used as the 
MAC layer protocol in the 
surrounding node. 







]]>
				</comments>
				<count-properties name="count" type="integer">
					<properties type="integer" auto-assign="yes" symbolic-only="no">
						<default-value value="1"/>
						<lower-limit value="1" exclusive="no"/>
						<upper-limit value="1" exclusive="no"/>
						<comments>
<![CDATA[


]]>
						</comments>
					</properties>
				</count-properties>
				<list-properties name="list" type="object list">
					<properties type="object list" auto-assign="yes" symbolic-only="no">
						<object-list>
							<sub-object name="Data Rate" type="double">
								<properties type="double" units="bps" auto-assign="yes" symbolic-only="yes">
									<default-value value-symbol="11 Mbps"/>
									<symbol-map>
										<symbol name="1 Mbps" value="1,000,000"/>
										<symbol name="2 Mbps" value="2,000,000"/>
										<symbol name="5.5 Mbps" value="5,500,000"/>
										<symbol name="11 Mbps" value="11,000,000"/>
									</symbol-map>
									<comments>
<![CDATA[
1 Mbps, 2 Mbps, 5.5 Mbps and 
11 Mbps  data rates 
supported by the wlan model. 
   
]]>
									</comments>
								</properties>
							</sub-object>
							<sub-object name="Packet Reception-Power Threshold" type="double">
								<properties type="double" units="W" auto-assign="yes" symbolic-only="no">
									<default-value value="7.33E-14"/>
									<lower-limit value="0.0" exclusive="yes"/>
									<symbol-map>
										<symbol name="7.33E-14" value="7.33E-14"/>
									</symbol-map>
									<comments>
<![CDATA[
Defines the received power 
threshold value in Watts at the 
radio receiver for arriving WLAN 
packets. Packets with a power 
less than threshold considered as 
noise packets and they don't 
change the status of the receiver 
to "busy" from MAC's point of 
view, and don't turn on the 
signal lock at the receiver. 
These packets serve as 
interference source against the 
valid packets.

The packets with a power higher
than threshold are considered as 
valid packets. Unless the default 
transmission power is changed, 
all the WLAN packets should reach 
at their destinations with 
sufficient power to be a valid 
packet if the propagation 
distance between the source and 
destination is less than 300 
meters as required by IEEE 802.11 
WLAN standard.

The value of the "high threshold 
trigger" of the statwires between 
the radio receiver and the MAC 
module in the surrounding node 
model will be overwritten by the 
value of this attribute.

]]>
									</comments>
								</properties>
							</sub-object>
							<sub-object name="Channel Settings" type="compound">
								<properties type="compound" auto-assign="yes" symbolic-only="no">
									<default-value>
										<sub-object>
											<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
											<attribute creation-mechanics="Model" name="list" type="object list">
												<object-list>
													<sub-object/>
												</object-list>
											</attribute>
										</sub-object>
									</default-value>
									<comments>
<![CDATA[
In the wlan model there are 
4 transmitting and receiving 
channels. Each channel is 
associated with a data rate 
of (1, 2, 5,5, and 11 Mbps). 
The user can set the minimum 
frequency and the bandwidth 
of these channels. Note that 
these settings will be for 
all four channels because 
they belong to same station. 
   



]]>
									</comments>
									<count-properties name="count" type="integer">
										<properties type="integer" auto-assign="yes" symbolic-only="no">
											<default-value value="1"/>
											<lower-limit value="1" exclusive="no"/>
											<upper-limit value="1" exclusive="no"/>
											<comments>
<![CDATA[


]]>
											</comments>
										</properties>
									</count-properties>
									<list-properties name="list" type="object list">
										<properties type="object list" auto-assign="yes" symbolic-only="no">
											<object-list>
												<sub-object name="Bandwidth" type="double">
													<properties type="double" units="Khz" auto-assign="yes" symbolic-only="no">
														<default-value value="1,000"/>
														<lower-limit value="0.0" exclusive="no"/>
														<symbol-map>
															<symbol name="10" value="10"/>
														</symbol-map>
														<comments>
<![CDATA[
This attribute specifies the 
bandwidth of the channel. 







]]>
														</comments>
													</properties>
												</sub-object>
												<sub-object name="Min frequency" type="double">
													<properties type="double" units="MHz" auto-assign="yes" symbolic-only="no">
														<default-value value="2,405"/>
													</properties>
												</sub-object>
											</object-list>
										</properties>
									</list-properties>
								</properties>
							</sub-object>
							<sub-object name="Max Receive Lifetime" type="double">
								<properties type="double" units="secs" auto-assign="yes" symbolic-only="no">
									<default-value value-symbol="0.5"/>
									<lower-limit value="0.0" exclusive="yes"/>
									<symbol-map>
										<symbol name="0.5" value="0.5"/>
										<symbol name="1.0" value="1.0"/>
										<symbol name="1.5" value="1.5"/>
										<symbol name="2.0" value="2.0"/>
									</symbol-map>
									<comments>
<![CDATA[
Maximum time after the 
initial reception of the 
fragmented MSDU	after which 
further attempts to  
reassemble the MSDU will be 
terminated.	 
]]>
									</comments>
								</properties>
							</sub-object>
						</object-list>
					</properties>
				</list-properties>
			</properties>
		</attribute>
		<attribute name="Address" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="From MAC Intf"/>
				<lower-limit value="0" exclusive="no"/>
				<symbol-map>
					<symbol name="From MAC Intf" value="-2"/>
				</symbol-map>
				<comments>
<![CDATA[
MAC layer address of the 
surrounding node.  This 
address should be unique 
across all stations in the 
network. 

]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="Transmission Power" type="double">
			<properties type="double" auto-assign="no" symbolic-only="no">
				<default-value value="0.001"/>
			</properties>
		</attribute>
	</model-attributes>
	<simulation-attributes>
		<attribute name="debug_level" group="debug" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="yes">
				<default-value value-symbol="NO"/>
				<symbol-map>
					<symbol name="NO" value="0"/>
					<symbol name="LOW" value="1"/>
					<symbol name="MEDIUM" value="2"/>
					<symbol name="MAX" value="3"/>
				</symbol-map>
				<comments>
<![CDATA[

]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="RTS" group="cmac" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="NO"/>
				<symbol-map>
					<symbol name="NO" value="-1"/>
				</symbol-map>
			</properties>
		</attribute>
		<attribute name="mac_layer" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="CMAC"/>
				<symbol-map>
					<symbol name="CMAC" value="1"/>
					<symbol name="IEEE80211" value="2"/>
				</symbol-map>
				<comments>
<![CDATA[
The CTR are activated (optimization 
in order to improve the capacity of 
convergecast networks) 
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="max_priv_duration" group="cmac" type="double">
			<properties type="double" auto-assign="no" symbolic-only="no">
				<default-value value="0.01"/>
				<comments>
<![CDATA[
The maximum time during which a node keeps to be privileged (after that, it forward the privilege to its child in the ktree)
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="CTR_hop_spacing" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="no">
				<default-value value="4"/>
				<comments>
<![CDATA[
The number of hops that separate two consecutive CTR sent by the sinks
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="nb_channels" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="no">
				<default-value value="1"/>
				<comments>
<![CDATA[
number of channels
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="ktree_algo" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="SYNC"/>
				<symbol-map>
					<symbol name="SYNC" value="1"/>
					<symbol name="MTree" value="2"/>
					<symbol name="Static" value="3"/>
				</symbol-map>
				<comments>
<![CDATA[
The algorithm used to select the k-tree nodes:

SYNC: a SYNC packets is sent by the sink, with a maximum power. Any node receives this packet and records the reception power. The children will be chosen among the nodes with the minimum rx=power

MTree: firstly, a tree which maximizes the leaves is constructed. Then, we construct a node-disjoint k-tree core (i.e. selection of the k different branches which maximizes the number of descendants)
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="nb_branches" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="no">
				<default-value value="4"/>
				<comments>
<![CDATA[
The number of leaves for the k-tree core (in our case, the number of branches starting from the sink) 
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="sink_address" group="traffic" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value="0"/>
			</properties>
		</attribute>
		<attribute name="exponential_backoff" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="FALSE"/>
				<symbol-map>
					<symbol name="FALSE" value="0"/>
					<symbol name="TRUE" value="1"/>
				</symbol-map>
			</properties>
		</attribute>
	</simulation-attributes>
	<attribute-assignments>
		<assignment attribute-name="Address" type="integer" status="promoted"/>
		<assignment attribute-name="Transmission Power" type="double" status="promoted"/>
		<assignment attribute-name="Wireless LAN Parameters" type="compound" status="promoted"/>
		<assignment attribute-name="begsim intrpt" type="toggle" status="hidden" value="1"/>
		<assignment attribute-name="doc file" type="string" status="hidden"/>
		<assignment attribute-name="endsim intrpt" type="toggle" status="hidden" value="1"/>
		<assignment attribute-name="failure intrpts" type="enumerated" status="hidden"/>
		<assignment attribute-name="intrpt interval" type="toggle double" status="hidden"/>
		<assignment attribute-name="priority" type="integer" status="hidden"/>
		<assignment attribute-name="recovery intrpts" type="enumerated" status="hidden"/>
		<assignment attribute-name="subqueue" type="compound" status="hidden">
			<sub-object>
				<attribute creation-mechanics="EMA" name="count" type="integer" value="4"/>
				<attribute creation-mechanics="EMA" name="list" type="object list">
					<object-list>
						<sub-object/>
						<sub-object/>
						<sub-object/>
						<sub-object/>
					</object-list>
				</attribute>
			</sub-object>
		</assignment>
		<assignment attribute-name="super priority" type="toggle" status="hidden"/>
	</attribute-assignments>
	<interfaces>
		<interface promoted-name="subqueue" type="compound" inherit-limits="yes" inherit-symbol-only="yes" inherit-comments="yes" inherit-units="yes" inherit-default-value="yes">
			<attribute-names>
<![CDATA[
subqueue
]]>
			</attribute-names>
			<properties type="compound" auto-assign="no" symbolic-only="no">
				<count-properties name="count" type="integer">
					<properties type="integer" auto-assign="no" symbolic-only="no">
						<default-value value="1"/>
					</properties>
				</count-properties>
				<list-properties name="list" type="object list">
					<properties type="object list" auto-assign="no" symbolic-only="no"/>
				</list-properties>
			</properties>
		</interface>
	</interfaces>
	<state-variables>
<![CDATA[
/* Station's own address */
int	\my_address;

/* The node must wait for a reply to its frame (CTS, ACK...) */
Boolean	\is_reply_to_receive;

/* Does a reply must be transmitted ?                           */
/* (after we received one particular frame, e.g. RTS, CTS, etc) */
Boolean	\is_reply_to_send;

/* The reply to a frame is not what we expected */
/* -> consider that the frame has timeouted     */
Boolean	\is_reply_bad;

/* We sent a packet, and we had a valid reply */
/* (RTS -> CTS, or DATA->ACK...)              */
Boolean	\is_reply_received;

/* The next frame to send */
/*                        */
frame_struct	\next_frame_to_send;

/* The last frame that was transmitted */
frame_struct	\last_frame_sent;

/* The buffer containing all the unicast data frames we must send */
List*	\unicast_frame_buffer;

/* The buffer containing all the multicast data frames we must send */
List*	\multicast_frame_buffer;

/* Used in storing data rate attribute. This is the rate at which	 */
/* data frame is transmitted.										                            */
double	\operational_speed;

/* Has this node the priority to send all its data packets */
/* (it received a CTR from its parent)                     */
Boolean	\is_node_privileged;

/* Is the node a sink ? */
Boolean	\is_sink;

/* The neighborhood table */
List*	\my_neighborhood_table;

/* The transmitter is busy, i.e. a frame is transmitted */
Boolean	\is_tx_busy;

/* current power transmission for my main radio */
double	\my_current_tx_power;

/* the receive is busy, i.e. a frame has been transmitted by a neighbor */
Boolean	\is_rx_busy;

/* The power above we consider the channel is busy */
double	\rx_power_threshold;

/* The power of the last received SYNC frame */
/* in 1E-14 W                                */
double	\my_sync_rx_power;

/* The list of the nodes which reserved the medium             */
/* We can have several reservations in a multi-channel network */
List*	\my_nav_list;

/* my max backoff */
int	\cw;

/* My current backoff value */
int	\my_backoff;

/* The interruption for the backoff (can be stopped by a medium activity) */
Evhandle	\backoff_intrpt;

/* Is the CW static or exponential? */
int	\EXPONENTIAL_BACKOFF;

/* When did I become privileged ? */
double	\time_start_privileged;

/* The timeout interruption */
Evhandle	\frame_timeout_intrpt;

/* The interruption which triggers a timeout if the frame was not received */
Evhandle	\timeout_intrpt;

/* The interruption which triggers a return to the main channel */
Evhandle	\main_channel_return_intrpt;

/* The channel I am currently using (used by the monitor process) */
short	\my_current_channel_for_monitor;

/* The object id of the monitor process */
Objid	\monitor_objid;

/* Has the next channel status change to be notified (multichannel case) */
Boolean	\my_channel_status_notif;

/* the debug level for the simulations */
int	\DEBUG;

/* The interruption for stop defering */
Evhandle	\defer_intrpt;

/* The next branch which will be polled by the sink */
/* (with a CTR)                                     */
int	\ctr_last_branch;

/* The rx_power of the last received transmission    */
/* (just before the rx_module leaves its busy state) */
double	\last_rx_power;

/* the channel I am currently using for my rx/tx */
short	\my_current_channel;

/* The debug file (perso) */
FILE*	\my_debug_file;

/* local identification of the node                    */
/* (id which has no signification outside the process) */
int	\my_stat_id;

/* Must an hello to be transmitted ? */
Boolean	\is_hello_to_send;

/* The list of frame_id already received */
List*	\my_frame_id_seen;

/* My mac layer protocol */
int	\MAC_LAYER;

/* ktree nodes are allowed to send packets only when they are privileged */
Boolean	\strict_privileged_mode;

/* IS the directional antenna activated for the SYNC ? */
int	\is_sync_direct_antenna;

/* The branch pointed by the last SYNC frame */
int	\sync_last_branch;

/* My branch number (if I identified it) */
int	\my_branch;

/* The channel used for my current transmissions */
int	\my_privileged_channel;

/* The time during which a node remains privileged */
double	\slot_privileged_duration;

/* Offset time before I received the CTR from my parent */
double	\slot_privileged_offset;

/* The number of hops that must separate two consecutive CTR */
int	\CTR_HOP_SPACING;

/* A RTS/CTS is required gor longer packets (OPC_INT_INFINITY -> never required) */
int	\RTS_PK_SIZE;

/* transmission power */
double	\POWER_TX;

/* the algo I am executing to form the ktree-core */
int	\KTREE_ALGO;

/* the number of branches for the tree of cMAC */
int	\NB_BRANCHES;

/* Information about the tree rooted at the sink: */
/* -parent                                        */
/* -distance to the sink                          */
/* -size of my subtree (descendant + myself)      */
sink_tree_struct	\my_sink_tree;

/* the address of the sink */
int	\sink_address;

/* The information I am sharing with other processes */
mac_info*	\my_mac_info;

]]>
	</state-variables>
	<header-block>
<![CDATA[
/*
 *  cmac_process.c
 *  
 *  Created by Fabrice Theoleyre on 29/09/09.
 *  Copyright 2009 CNRS / LIG. All rights reserved.
 *
 */


#include	"cmac_process.h"
#include	"cmac_tools.h"
#include	"cmac_interface.h"
#include	"cmac_monitor.h"



/*-------------------------------------------------------

NOTES:

* cmac_tree and ktree are identical (the ktree is the structure used by 
cmac to define the branches that 'collect' the traffic to the sink)

* 



-------------------------------------------------------*/


//-----------------------------------------------
//				SPECIAL DEBUG
//-----------------------------------------------

#define		DEBUG_STATE_MACHINE				0
//(my_address == 403)



//-----------------------------------------------
//				STREAM & STAT
//-----------------------------------------------

//PHY
#define		STREAM_TO_RADIO					0
#define		STREAM_FROM_RADIO				0

//APP layer
#define		STREAM_TO_UP					1
#define		STREAM_FROM_UP					1

//For the monitor process connection
#define		MONITOR_OUTPUT_STREAM			2
#define		MONITOR_INPUT_STREAM			2

//SYNC case
#define		STREAM_TO_DIRECT_SYNC			3

//Statistics wires
#define		STAT_FROM_RX					0
#define		STAT_FROM_TX					1

#define		STAT_FROM_TX_DIREC_SYNC			2








//-----------------------------------------------
//		   	WLAN_SUPPORT.h
//-----------------------------------------------

// Define the WLAN global variables, which are declared in wlan_support.h.

// Global linked list of AP position info
WlanT_AP_Position_Info* 			global_ap_pos_info_head = OPC_NIL;

// Global variable to keep note of the nature of the subnet
// This variable is initialized to not set
WlanT_Bss_Identification_Approach	bss_id_type = WlanC_Not_Set;

// Read-only array of the minimum frequencies of the 12 operational 802.11a
// WLAN channels.
double	WLANC_11a_CHNL_MIN_FREQ_ARRAY [WLANC_11a_OPER_CHNL_COUNT] = 
			{5170.0, 5190.0, 5210.0, 5230.0, 5250.0, 5270.0, 5290.0, 5310.0, 5735.0, 5755.0, 5775.0, 5795.0};

// Read-only arrays for mandatory 802.11a and 802.11g data rates.
double	WLANC_11a_MANDATORY_DRATE_ARRAY [3] = {24000000.0, 12000000.0, 6000000.0};
double	WLANC_11g_MANDATORY_DRATE_ARRAY [7] = {24000000.0, 12000000.0, 11000000.0, 6000000.0, 5500000.0, 2000000.0, 1000000.0};

// Reset one of the packet field index global variables so its value can be
// checked to determine whether all of those variables are initialized or not
int		WLANC_DATA_TYPE_FD = OPC_FIELD_INDEX_INVALID;
int		WLANC_DATA_HEADER_FD, WLANC_DATA_QOS_FD, WLANC_DATA_BODY_FD, WLANC_DATA_ACCEPT_FD, WLANC_DATA_PKID_FD;
int		WLANC_CNTL_TYPE_FD, WLANC_CNTL_HEADER_FD, WLANC_CNTL_BA_FD, WLANC_CNTL_ACCEPT_FD;
int		WLANC_BEACON_BODY_FD;
int 	WLANC_ACT_MGMT_CAT_ACT_FD, WLANC_ACT_MGMT_TID_FD, WLANC_ACT_MGMT_PARAMS_FD;






//-----------------------------------------------
//		   	INTERRUPTIONS
//-----------------------------------------------

#define		PK_FROM_UPPER					((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() == STREAM_FROM_UP))
#define		PK_FROM_LOWER					((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() != STREAM_FROM_UP))



//We received a frame
#define		IS_FRAME_RECEIVED				((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() == STREAM_FROM_RADIO))


//Frame to received (acak, cts...) -> timeout	
#define		IS_FRAME_TIMEOUT				((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == FRAME_TIMEOUT_CODE))


//Is the medium busy ? (transmission / reception / reservation)
#define		IS_MEDIUM_BUSY					((is_rx_busy) || (is_tx_busy) || (get_nav_main_channel() >= op_sim_time()))


//We must defer in any of these conditions: 
//- a CTR msut be transmitted 
//- a packet was received and we must reply (ACK, CTS, CTR...) 
//- the medium is busy (We must get another backoff) 
#define		IS_BACK_TO_DEFER				((next_frame_to_send.type == CTR_PK_TYPE) || (IS_FRAME_RECEIVED && is_reply_to_send))
//#define		IS_BACK_TO_DEFER				((next_frame_to_send.type == CTR_PK_TYPE) || (IS_FRAME_RECEIVED && IS_REPLY_TO_SEND))


//We must transmit one packet: our data buffer is not empty OR we have already prepared a frame to send
#define		IS_DATA_OK						((!strict_privileged_mode) || (is_hello_to_send && !IS_BROADCAST_FORBIDDEN) || !my_sink_tree.is_in_ktree || is_node_privileged || is_sink)
#define		IS_PK_TO_SEND					((IS_DATA_OK && !is_frame_buffer_empty()) || (next_frame_to_send.type != NO_PK_TYPE))




//The mode privileged is finished !
// -> The node must become unprivileged
// -> Or we have no more data frames to send, and we remained privileged for a sufficiently long time
//
//	NB: if we receive PRIVILEGED_MAX_CODE after becoming a unpriviledge mode, nothing happens
//		and two privileged modes are sufficiently inter spaced so that no problem occurs 
//		the sink sends CTR with a period largely superior to PRIVILEGED_MAX_TIME (PRIVILEGED_MAX_TIME * NB_BRANCH * BETA)
//		Moreover, we have a second verification after having received a PRIVILEGED_MAX_CODE
//
#define		PRIVILEGED_END					(PRIVILEGED_MEDIUM_LIMIT || PRIVILEGED_HIGH_LIMIT)

#define		END_PRIV_SLOT					(time_start_privileged + slot_privileged_duration - slot_privileged_offset <= op_sim_time())
#define		END_PRIV_INTRPT					((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == PRIVILEGED_MAX_CODE))

#define		PRIVILEGED_MEDIUM_LIMIT			((is_node_privileged) && (is_frame_buffer_empty()) && (time_start_privileged + slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO <= op_sim_time()))
#define		PRIVILEGED_HIGH_LIMIT			((is_node_privileged) && (END_PRIV_SLOT || END_PRIV_INTRPT))


#define		MAIN_CHANNEL_RETURN				((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == MAIN_CHANNEL_RETURN_CODE))


//No frame to send
#define		NO_FRAME						(next_frame_to_send.type == NO_PK_TYPE)


//this node has the priority to sends its packets
#define		IS_NODE_PRIO					((next_frame_to_send.type == CTS_PK_TYPE) || (next_frame_to_send.type == ACK_PK_TYPE) || (next_frame_to_send.type == DATA_UNICAST_PK_TYPE && next_frame_to_send.pk_size  >= RTS_PK_SIZE))


//Collision: we have the priority to send a reply, but the medium is busy (another node is not aware of the current communication)
#define		PRIORITY_AND_MEDIUM_BUSY		((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE) && (IS_MEDIUM_BUSY) && (IS_NODE_PRIO))


//transmission canceled from the DEFER state (no frame to send, or a collision occured
#define		TRANSMISSION_CANCELED			(NO_FRAME || PRIORITY_AND_MEDIUM_BUSY)


//I will backoff
#define		GO_TO_BACKOFF					((!TRANSMISSION_CANCELED) && (!IS_MEDIUM_BUSY) && (my_backoff > 0))


//I will directly send one packet
#define		GO_TO_SEND						((!TRANSMISSION_CANCELED) && (!IS_MEDIUM_BUSY) && (my_backoff == 0))


//I can send one BROADCAST frame -> other nodes will receive it
//Special case: the source is the sink (I can send a packet even if I am not privileged (I am never))
#define		IS_BROADCAST_FORBIDDEN			0
//((!is_node_privileged && my_sink_tree.is_in_ktree && !is_sink && (nb_channels == 1)) || (is_nav_for_other_channel()) || (!is_main_channel_active(STREAM_TO_RADIO)))
//TAG







//-----------------------------------------------
//		   	INTERRUPTION CODES
//-----------------------------------------------

//Nothing happened, this is just an interruption to bypass unforced states
#define		NOTHING_CODE					0

//A frame has timeouted -> no ACK/CTS received
#define		FRAME_TIMEOUT_CODE				1


//The sink must generate a CTR
#define		SINK_CTR_CODE					2


//The node must wait the interframe time berfore the transmission
#define		DEFER_CODE						3


//A CTR packet has to be sent
#define		CTR_PK_CODE						4


//A Hello packet has to be sent
#define		HELLO_PK_CODE					5


//The backoff interruption
#define		BACKOFF_CODE					6


//Verification of timeouts in the neighborhood_table
#define		NEIGHBOR_TIMEOUT_CODE			7


//A nav is expired -> unblock potential transmissions
#define		NAV_END_CODE					8


//The node must become unprivileged
#define		PRIVILEGED_MIN_CODE				9
//The node should become unprivileged if its data buffer is empty
#define		PRIVILEGED_MAX_CODE				10


//The code to generate a sync frame
#define		SINK_SYNC_CODE					11


//The periodical deletion of frame_ids
#define		FRAME_ID_TIMEOUT_CODE			12


//I must return to my main frequency
#define		MAIN_CHANNEL_RETURN_CODE		13





//-----------------------------------------------
//		   DEBUG FILES
//-----------------------------------------------

//Common -> but no pb since no concurrent execution (discrete event simulator)
FILE	*debug_files[20];
int		cmac_timestamp = 0;

//Number of nodes
int		nb_mac_nodes = 0;




//-----------------------------------------------
//					SHARED VARIABLES
//-----------------------------------------------

int		global_frame_id 	= 0;
double 	TIME_MAX_PRIVILEGED;
int		*nodeid_to_addr_var = NULL;
Boolean	connectivity_verification = OPC_FALSE;

//the position of the sink in the grid
int		y_sink_int = 0, x_sink_int = 0;
//directions (deduce the nb of branches)
Boolean	is_node_present_for_direction[4] = {0,0,0,0};	
short	direction_to_branch_id[4] = {-1,-1,-1,-1};	
Boolean	*ktree_static_ok;



//-----------------------------------------------
//				PARAMETERS
//-----------------------------------------------


// Number of channels to use
int		nb_channels = 0;

]]>
	</header-block>
	<function-block>
<![CDATA[

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
//---------------------------								  ---------------------------
//---------------------------			COMMON			      ---------------------------
//---------------------------								  ---------------------------
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------






//-----------------------------------------------------------
//
//					PARAMETERS
//
//-----------------------------------------------------------

//returns the nb of nodes in the network
int get_nb_nodes(){
	FIN(get_nb_nodes());
	
	FRET(nb_mac_nodes);
}



//nodeid to mac address
int nodeid_to_addr(int nodeid){
	FIN(nodeid_to_addr(int nodeid));
	
	if ((nodeid < 0) || (nodeid > get_nb_nodes())){
		printf("this node id does not exist (%d). Probably a bug\n", nodeid);
		FRET(ADDR_INVALID);
	}
	
	FRET(nodeid_to_addr_var[nodeid]);
}


//mac address to node id
int addr_to_nodeid(int addr){
	FIN(addr_to_nodeid(int addr));
	int		nb_nodes = get_nb_nodes();
	int		i;
	
	for(i=0; i<nb_nodes; i++)
		if (nodeid_to_addr_var[i] == addr)
			FRET(i);
	
	FRET(ADDR_INVALID);
}


//-----------------------------------------------------------
//
//					FRAME TIMEOUTS
//
//-----------------------------------------------------------

//Adds a timeout interruption
//NB : i have a blocking state -> I do not send any other packet until either I received the reply or the frame timeouts
void add_frame_timeout(double time){
	FIN(add_frame_timeout(double time));

	//error, the timeout interruption was not canceled !
	op_ev_cancel_if_pending(timeout_intrpt);
	if (op_ev_valid(timeout_intrpt))
		op_sim_end("A timeout interruption must be canceled when the reply is received" , "Please correct this bug", "" , "");

	//adds a timeout interruption
	timeout_intrpt = op_intrpt_schedule_self(op_sim_time() + time, FRAME_TIMEOUT_CODE);
	
	//debug
	debug_print(MAX , DEBUG_TIMEOUT , "adds a timeout for %f us (at %f)\n", time * 1000000, op_sim_time() + time);

	FOUT;
}









//-----------------------------------------------------------
//
//					ANTENNAS & RADIO
//
//-----------------------------------------------------------


//Changes the radio power for tranmissions
void change_tx_power(double power , int stream){
	FIN(change_tx_power(double power , int stream));
	
	//id
	int			tx_id , chan_id , sub_chan_id;
	int			num_chan;
	int			i;
	
	//gets the id of the tansmitter + channel attributes
	tx_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	op_ima_obj_attr_get (tx_id, "channel", &chan_id);

	//Sets the channel attributes
	//NB: I have normally one single channel, but .....
	num_chan = op_topo_child_count(chan_id, OPC_OBJTYPE_RATXCH);		
	for(i=0 ; i<num_chan ; i++){
		sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
		op_ima_obj_attr_set (sub_chan_id, "power", power);
	}

	debug_print(LOW , DEBUG_RADIO , "New power transmission %f\n", power);
	
	FOUT;
}

//returns true if we are focused on the main channel
Boolean is_main_channel_active(){
	FIN(is_main_channel_active());

	int			radio_id , chan_id , sub_chan_id;
	double		frequency;	

	//Gets only transmitter value (the receiver value is identical, or there is a big trouble !)
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , STREAM_TO_RADIO);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_get (sub_chan_id, "min frequency", 	&frequency);
	
	FRET(CHANNEL_MAIN_ID == freq_to_channel(frequency));
}

//Changes the radio power for tranmissions
void change_tx_rx_phy(short channel){
	FIN(change_tx_rx_phy(short channel));

	int		radio_id , chan_id , sub_chan_id;
	double	old_freq;
	double	frequency;
	//to update the status of my channel (bug in OPNET)
	int		*channel_state_table;
	char	msg[500], temp[500];
	int		i;
	
	//nothing todo!
	if (channel == my_current_channel)
		FOUT;

	my_current_channel 	= channel;
	frequency			= channel_to_freq(channel);	
	
	//------------ TRANSMISSION -----------
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , STREAM_TO_RADIO);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_get (sub_chan_id, "min frequency", 	&old_freq);
	op_ima_obj_attr_set (sub_chan_id, "min frequency", 	frequency);
	

	//------------ RECEPTION -----------
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_IN , OPC_OBJTYPE_RARX , STREAM_TO_RADIO);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RARXCH, 0);
	op_ima_obj_attr_set (sub_chan_id, "min frequency", 	frequency);

	if (frequency != old_freq)
		debug_print(LOW , DEBUG_RADIO , "channel changed %d (%f Hz) -> %d (%f Hz)\n", freq_to_channel(old_freq), old_freq , channel, frequency);
					
	//the parent is no more frozen on the privileged channel
	if ((old_freq!= CHANNEL_MAIN_ID) && (frequency == CHANNEL_MAIN_ID))
		flush_nav_time(old_freq);
	
	
	//--------- Updates the channel status --------- 
	if (monitor_objid != OPC_OBJID_INVALID){
		channel_state_table = op_ima_obj_state_get(monitor_objid);
	
		if (is_rx_busy != channel_state_table[channel]){
			my_current_channel_for_monitor = channel;
			debug_print(LOW , DEBUG_RADIO , "BUG avoided: channel status before (%d) and after (%d) channel change are different !\n", is_rx_busy , channel_state_table[channel]);
			my_channel_status_notif = OPC_TRUE;
		}
		else
			my_current_channel_for_monitor = -1;	
	
		//status of all channels: for debug purpose
		strcpy(msg, "");
		for(i=0 ; i<nb_channels ; i++){
			snprintf(temp , 500 , "%d(%d)", i , channel_state_table[i]);
			strncat(msg , temp , 500);
		}
		strncat(msg , "\n", 500);
		debug_print(LOW , DEBUG_RADIO, msg);
	}
	FOUT;
}

//Changes the radio power for tranmissions
void change_antenna_direction(int stream , int branch){
	FIN(change_antenna_direction(int stream , int branch));
	
	int			antenna_id;
	int			tx_id;
	double		theta;
	double		x , y;
	
	//Transmitter id (I am connected via a stream to it)
	tx_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	
	//One single antenna per transmitter
	antenna_id	= op_topo_assoc(tx_id , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_ANT , 0);
	
	
	//Direction
	theta = 2 * PI * branch / NB_BRANCHES;
	x = cos(theta);
	y = sin(theta);

	//and point it
	op_ima_obj_attr_set (antenna_id, "target latitude", 	x);
	op_ima_obj_attr_set (antenna_id, "target longitude", 	y);

	debug_print(LOW , DEBUG_RADIO , "New direction for the antenna: %f\n", theta);
	
	FOUT;
}






//-----------------------------------------------------------
//
//			 NAV (Network Allocation Vector)
//
//-----------------------------------------------------------


//Prints the list of current NAV
void print_nav_list(int debug_type){
	FIN(print_nav_list(int debug_type));
	
	int			i;
	nav_struct	*ptr;

	
	debug_print(LOW , debug_type , "-----------------------------------------\n");
	debug_print(LOW , debug_type , "		NAV LIST (%f)\n", op_sim_time());
	debug_print(LOW , debug_type , "-----------------------------------------\n");
	debug_print(LOW , debug_type , "\n");
	
	debug_print(LOW , debug_type , "  ADDR   | CHANNEL |  TIMEOUT\n");
	
	for (i=0 ; i< op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		debug_print(LOW , debug_type , "%8d	|   %3d   |  %f\n", ptr->address , ptr->channel , ptr->timeout);
	}
	FOUT;
}

//Deletes obsolete nav
void delete_timeouted_nav(void * arg, int code){
	FIN(delete_timeouted_nav(void * arg, int code));
	
	int				i;
	nav_struct		*ptr;
	double			older_entry = 0;
	
	//Walks in the list
	for(i= op_prg_list_size(my_nav_list)-1 ; i>= 0 ; i--){
		ptr = op_prg_list_access(my_nav_list , i);
		
		//Timeouted entry !
		if (ptr->timeout <= op_sim_time()){
			debug_print(LOW , DEBUG_BACKOFF , "NAV from %d deleted\n", ptr->address);
			
			ptr = op_prg_list_remove(my_nav_list , i);
			op_prg_mem_free(ptr);
		}
		
		//updates the time for the older entry
		else if ((older_entry > ptr->timeout) || (older_entry == 0))
			older_entry = ptr->timeout;
	}
	
	
	//Next verification
	if (older_entry != 0)
		op_intrpt_schedule_call(older_entry , 0 , delete_timeouted_nav , NULL);
	FOUT;
}


//adds a medium reservation
void add_nav(int source, double nav_duration , short channel){
	FIN(add_nav(int source, double nav_duration , short channel));
	
	nav_struct	*ptr;
	int			i;
	
	//Deletes timeouts
	if (op_prg_list_size(my_nav_list) == 0)
		op_intrpt_schedule_call(op_sim_time() + nav_duration , 0 , delete_timeouted_nav , NULL);
	
	//Updates the entry if one already exists
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if (ptr->address == source){
			ptr->timeout = op_sim_time() + nav_duration;
			ptr->channel = channel;
	
			//debug_print(LOW , DEBUG_BACKOFF , "NAV updated, src %d, duration %fus, channel %d\n", source , nav_duration * 1E6, channel);			
			FOUT;
		}
	}
	
	//Adds one new element
	ptr = op_prg_mem_alloc(sizeof(nav_struct));
	ptr->address 	= source;
	ptr->channel	= channel;
	ptr->timeout 	= op_sim_time() + nav_duration;
	op_prg_list_insert(my_nav_list, ptr , OPC_LISTPOS_TAIL);
	
	//debug_print(LOW , DEBUG_BACKOFF , "NAV added, src %d, duration %fus, channel %d\n", source , nav_duration * 1E6, channel);
	FOUT;
}


//removes all the NAVs for this channel (we are no more privileged, and we should remove them)
void flush_nav_time(short channel){
	FIN(flush_nav_time(short channel));
	
	int				i;
	nav_struct		*ptr;
	
	//Walks in the list
	for(i= op_prg_list_size(my_nav_list)-1 ; i>= 0 ; i--){
		ptr = op_prg_list_access(my_nav_list , i);
		
		//Timeouted entry !
		if (ptr->channel == channel){
			debug_print(LOW , DEBUG_BACKOFF , "NAV from %d deleted (priv channel)\n", ptr->address);
			
			ptr = op_prg_list_remove(my_nav_list , i);
			op_prg_mem_free(ptr);
		}
	}
	
	
	FOUT;
}

//updates the nav
void update_nav_time(int source, double nav_duration, short channel){
	FIN(update_nav_time(int source, double nav_duration, short channel));
		
	//No real reservation
	if (nav_duration <= 0){
		//debug_print(LOW , DEBUG_BACKOFF , "NAV ! UPDATED -> src %d, duration %fus, pk_size %d, channel %d\n", source , transmission_time * 1E6 , pk_size, channel);
		FOUT;
	}

	//Stores the NAV duration
	add_nav(source, nav_duration, channel);
					
	//Schedules the end of the NAV	
	op_intrpt_schedule_self(op_sim_time() + nav_duration , NAV_END_CODE);
	
	//debug_print(LOW , DEBUG_BACKOFF , "NAV -> src %d, nav_duration %fus, channel %d\n", source , nav_duration * 1E6, channel);
	FOUT;
}


//Returns the longest NAV for the main channel
double get_nav_main_channel(){
	FIN(get_nav_main_channel());
	
	int			i;
	nav_struct	*ptr;
	double		timeout = 0;
	
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > timeout) && (ptr->channel == CHANNEL_MAIN_ID))
			timeout = ptr->timeout;
	}
	
	FRET(timeout);
}


//Is the medium free to reply to addr ? (i.e. no other node has already reserved this channel ?
Boolean is_reply_possible(int addr , short channel){
	FIN(is_reply_possible(int addr , short channel));
	
	int			i;
	nav_struct	*ptr;
	
	//a privileged nodes has all the rights!
	if (!is_main_channel_active())
		FRET(OPC_TRUE);	
	
	//others must look at their NAV
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > op_sim_time()) && (ptr->channel == channel) && (ptr->address != addr))
			FRET(OPC_FALSE);
	}
	
	FRET(OPC_TRUE);
}


//The destination is available for reception (no NAV for any channel)
Boolean is_destination_available(int destination){
	FIN(is_destination_available(int destination));

	int			i;
	nav_struct	*ptr;
	
	//a privileged nodes has all the rights!
	if (is_node_privileged)
		FRET(OPC_TRUE);	
	
	//Else, I must verify that the destination is not busy
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > op_sim_time()) && (ptr->address == destination))
			FRET(OPC_FALSE);
	}
	FRET(OPC_TRUE);
}





//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												QUEUE MANAGEMENT										  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------








//-----------------------------------------------------------
//
//					DUPLICATA DETECTION
//
//-----------------------------------------------------------


//Deletes the frame_id which became obsolete
void del_timeouted_frame_id(void* tot , int code){
	FIN(del_timeouted_frame_id(void* tot , int code));
	
	int						i;
	id_timeout_struct		*ptr;
		
	//Walks in the list
	for(i= op_prg_list_size(my_frame_id_seen)-1 ; i>= 0 ; i--){
		ptr = op_prg_list_access(my_frame_id_seen , i);
		
		//Timeouted entry !
		if (ptr->timeout <= op_sim_time()){		
			ptr = op_prg_list_remove(my_frame_id_seen , i);
			debug_print(MAX, DEBUG_DATA, "Frame (id %d, src %d) is removed from the cache (timeouted at %f)\n", ptr->id, ptr->source, ptr->timeout);
			op_prg_mem_free(ptr);
		}
	}	
	
	//Next verification
	if (op_prg_list_size(my_frame_id_seen) != 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_FRAME_ID , FRAME_ID_TIMEOUT_CODE , del_timeouted_frame_id , NULL);

	FOUT;
}


//Is thie frame_id already in the list ?
Boolean is_frame_id_seen(int source, int frame_id){
	FIN(is_frame_id_seen(int source, int frame_id));
	
	id_timeout_struct		*ptr;
	int						i;
	
	for(i=0 ; i < op_prg_list_size(my_frame_id_seen) ; i++){
		ptr = op_prg_list_access(my_frame_id_seen , i);
		
		if ((ptr->id == frame_id) && (ptr->source == source))
			FRET(OPC_TRUE);
	}
	
	FRET(OPC_FALSE);
}



//adds the frame_id as already seen
void add_frame_id_seen(int source, int frame_id){
	FIN(add_frame_id_seen(int source, int frame_id));
	
	id_timeout_struct		*ptr;
	
	//the frame id is already in the list
	if (is_frame_id_seen(source, frame_id))
		FOUT;
	
	//Empty list -> timeouted verificaiton
	if (op_prg_list_size(my_frame_id_seen) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_FRAME_ID , FRAME_ID_TIMEOUT_CODE , del_timeouted_frame_id , NULL);
	
	//New entry
	ptr = op_prg_mem_alloc(sizeof(id_timeout_struct));
	ptr->source		= source;
	ptr->id			= frame_id;
	ptr->timeout	= op_sim_time() + TIMEOUT_FRAME_ID;
	op_prg_list_insert(my_frame_id_seen , ptr , OPC_LISTPOS_TAIL);
	
	FOUT;
}


//Prints the content of the frame_id cache
void print_frame_id_seen(int debug_type){
	FIN(print_frame_id_seen(int debug_type));
	
	//Frame buffer
	id_timeout_struct	*ptr;
	//info
	int					i;

	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "		Frame Id Seen Buffer (size %d)\n" , op_prg_list_size(unicast_frame_buffer));
	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "SRC    |  ID   |	TIMEOUT	\n");

	
	for(i=op_prg_list_size(my_frame_id_seen)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(my_frame_id_seen , i);

		debug_print(LOW , debug_type , "%5d  |  %5d	|	%f\n", ptr->source, ptr->id , ptr->timeout);
	}
	FOUT;
}


//-----------------------------------------------------------
//
//					UNICAST FRAME BUFFER
//
//-----------------------------------------------------------


//Prints the content of the data frame buffer
void print_unicast_frame_buffer(int debug_type){
	FIN(print_unicast_frame_buffer(int debug_type));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;
	int				data_id;

	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "			Unicast Frame Buffer of %d (size %d)\n" , my_address , op_prg_list_size(unicast_frame_buffer));
	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "DEST	|	TYPE		|     ID    | NB_RETRY | MIN_TRANSMISSION\n");


	
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		op_pk_fd_get(ptr->payload, FIELD_PAYLOAD_ID, &data_id);
		debug_print(LOW , debug_type , "%5d	|	%s	| %5d/%5d | %8d | %f\n", ptr->destination ,  pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id , data_id, ptr->nb_retry , ptr->time_transmission_min);
	}
	FOUT;
}


//increments the number of retransmissions for the corresponding frame_id
void increment_nb_retry_unicast_frame_buffer(int id){
	FIN(increment_nb_retry_unicast_frame_buffer(int id));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;
	
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == id){
		
			ptr->nb_retry++;
			
			//exponential backoff only for non-privileged nodes!
			if ((EXPONENTIAL_BACKOFF) && (cw < MAX_EXPO_BACKOFF) && (!my_sink_tree.is_in_ktree))
				cw = cw * 2;
			
			//will try to retransmit this frame later (the destination is perhaps currently privileged)
			if ((ptr->nb_retry > MEDIUM_NB_RETRY) && (!my_sink_tree.is_in_ktree) && (MAC_LAYER != IEEE80211)){
				ptr->time_transmission_min = op_sim_time() + TIME_MAX_PRIVILEGED;
			}
			
			//Verify that we dont have too many retransmissions
			if (ptr->nb_retry >= MAX_NB_RETRY){
				debug_print(LOW, DEBUG_DATA , "the unicast frame to %d was not acknowledged and we have too many retransmissions -> DELETED (type %s, id %d)\n",  ptr->destination , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
								
				ptr = op_prg_list_remove(unicast_frame_buffer , i);
				if (ptr->payload != NULL)
					op_pk_destroy(ptr->payload);
				op_prg_mem_free(ptr);
				
				cw = MAX_BACKOFF;
			}
			else
				debug_print(LOW, DEBUG_DATA , "the unicast frame to %d was not acknowledged -> RETRANSMISSION (nb retry %d type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		}
	}	
	print_unicast_frame_buffer(DEBUG_DATA);	
	
	FOUT;
}


//Deletes the data which were timeouted
void del_timeouted_unicast(void *arg, int code){
	FIN(del_timeouted_unicast(void *arg, int code));
	
	frame_struct	*ptr;
	int				i;
	char			msg[100];
	double			older_entry = -1;
	
	for(i=op_prg_list_size(unicast_frame_buffer) - 1 ; i >=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);
		
		//timeouted entry
		if (ptr->time_added <= op_sim_time() - TIMEOUT_DATA_FRAME){
			
			debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(unicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
		
		//next verification
		else if ((older_entry > ptr->time_added + TIMEOUT_DATA_FRAME) || (older_entry == -1))
			older_entry = ptr->time_added + TIMEOUT_DATA_FRAME;
	}

	if (older_entry != -1)
		op_intrpt_schedule_call(op_sim_time() + older_entry , 0 , del_timeouted_unicast , NULL);
	FOUT;
}


//adds a (data) frame to send
void add_in_unicast_frame_buffer(frame_struct frame_tmp , int position){
	FIN(add_in_unicast_frame_buffer(frame_struct frame_tmp , int position));
	
	//Frame buffer
	frame_struct	*ptr;
		
	//Error
	if ((frame_tmp.type != DATA_UNICAST_PK_TYPE) && (frame_tmp.type != DATA_MULTICAST_PK_TYPE) && (frame_tmp.type != HELLO_PK_TYPE))
		op_sim_end("It is not possible to add a control frame" , "in the buffer of data unicast frame to send", "" , "");
	
	//buffer size
	if (op_prg_list_size(unicast_frame_buffer) > DATA_BUFFER_SIZE_MAX){
		debug_print(LOW, DEBUG_DATA, "Overflow: the unicast frame to %d (id %d) was destroyed directly before its insertion in the data buffer\n", frame_tmp.destination , frame_tmp.frame_id);
		op_pk_destroy(frame_tmp.payload);
		FOUT;
	}
	
	//Timeouts
	if (op_prg_list_size(unicast_frame_buffer) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_DATA_FRAME , 0 , del_timeouted_unicast , NULL);

	
	//Memory allocation + insertion in the buffer
	ptr = op_prg_mem_alloc(sizeof(frame_struct));
	*ptr  = frame_tmp;	
	op_prg_list_insert(unicast_frame_buffer , ptr , position);
	
	debug_print(MEDIUM , DEBUG_DATA , "a unicast frame to %d (id %d) was added in the buffer\n", frame_tmp.destination , frame_tmp.frame_id);
	
	FOUT;
}


//returns the nb of data frames to send
int get_unicast_frame_buffer_size(){
	FIN(get_unicast_frame_buffer_size());
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time())
			nb++;
	}
	
	FRET(nb);
}


//Must data frame be transmitted ?
Boolean is_unicast_frame_buffer_empty(){
	FIN(is_unicast_frame_buffer_empty());
	FRET(get_unicast_frame_buffer_size() == 0);
}


//returns the first data frame to send
frame_struct *get_unicast_frame_buffer(int pos){
	FIN(get_unicast_frame_buffer(int pos));
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time()){
			if (pos == nb)
				FRET(ptr);
			nb++;
		}
	}
	
	FRET(NULL);
}






//-----------------------------------------------------------
//
//					MULTICAST FRAME BUFFER
//
//-----------------------------------------------------------


//Deletes the multicast frames which were timeouted
void del_timeouted_multicast(void *arg, int code){
	FIN(del_timeouted_multicast(void *arg, int code));
	
	frame_struct	*ptr;
	int				i;
	char			msg[100];
	double			older_entry = -1;
	
	for(i=op_prg_list_size(multicast_frame_buffer) - 1 ; i >=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);
		
		//timeouted entry
		if (ptr->time_added <= op_sim_time() - TIMEOUT_DATA_FRAME){
			
			debug_print(LOW, DEBUG_TIMEOUT , "the multicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
			debug_print(LOW, DEBUG_NODE , "the multicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(multicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
		
		//next verification
		else if ((older_entry > ptr->time_added + TIMEOUT_DATA_FRAME) || (older_entry == -1))
			older_entry = ptr->time_added + TIMEOUT_DATA_FRAME;
	}

	if (older_entry != -1)
		op_intrpt_schedule_call(op_sim_time() + older_entry , 0 , del_timeouted_multicast , NULL);
	FOUT;
}


//adds a (data) frame to send
void add_in_multicast_frame_buffer(frame_struct frame_tmp , int position){
	FIN(add_in_multicast_frame_buffer(frame_struct frame_tmp , int position));
	
	//Frame buffer
	frame_struct	*ptr;
		
	//Error
	if ((frame_tmp.type != DATA_MULTICAST_PK_TYPE) && (frame_tmp.type != HELLO_PK_TYPE))
		op_sim_end("It is not possible to add a control frame" , "in the buffer of data frame to send", "" , "");
	
	
	//Timeouts
	if (op_prg_list_size(multicast_frame_buffer) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_DATA_FRAME , 0 , del_timeouted_multicast , NULL);

	
	//Memory allocation + insertion in the buffer
	ptr = op_prg_mem_alloc(sizeof(frame_struct));
	*ptr  = frame_tmp;	
	op_prg_list_insert(multicast_frame_buffer , ptr , position);
	
	debug_print(MEDIUM , DEBUG_DATA , "a multicast frame to %d (id %d) was added in the buffer\n", frame_tmp.destination , frame_tmp.frame_id);

	FOUT;
}


//returns the nb of data frames to send
int get_multicast_frame_buffer_size(){
	FIN(get_multicast_frame_buffer_size());
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time())
			nb++;
	}
	
	FRET(nb);
}


//Must data frame be transmitted ?
Boolean is_multicast_frame_buffer_empty(){
	FIN(is_multicast_frame_buffer_empty());
	FRET(get_multicast_frame_buffer_size() == 0);
}


//returns the first data frame to send
frame_struct *get_multicast_frame_buffer(int pos){
	FIN(get_multicast_frame_buffer(int pos));
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time()){
			if (pos == nb)
				FRET(ptr);
			nb++;
		}
	}
	
	FRET(NULL);
}



//Prints the content of the data frame buffer
void print_multicast_frame_buffer(int debug_type){
	FIN(print_multicast_frame_buffer(int debug_type));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;

	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "			Multicast Frame Buffer of %d (size %d)\n" , my_address , op_prg_list_size(multicast_frame_buffer));
	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "	DEST	|	TYPE	| 	ID		|	NB_RETRY	|	MIN_TRANSMISSION\n");


	
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		debug_print(LOW , debug_type , "%5d	|	%s	|	%d		|	%d		|	%f\n", ptr->destination ,  pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id , ptr->nb_retry , ptr->time_transmission_min);
	}
	FOUT;
}



//-----------------------------------------------------------
//
//					MULTICAST & UNICAST FRAME BUFFER
//
//-----------------------------------------------------------


//Rteurns the nb of possible frames
int get_frame_buffer_size(){
	FIN(get_frame_buffer_size());
	
	frame_struct	*ptr;
	frame_struct	*ptr_uni;
	frame_struct	*ptr_multi;
	int				i , j;
	int				nb = 0;
	
	//initialization
	i = 0;
	//Multicast -> only when all my neighbors can receive it
	if (IS_BROADCAST_FORBIDDEN)
		j = op_prg_list_size(multicast_frame_buffer);
	else
		j = 0;

	while((i < op_prg_list_size(unicast_frame_buffer)) || (j < op_prg_list_size(multicast_frame_buffer))){
	
		//no more unicast frame
		if (i == op_prg_list_size(unicast_frame_buffer)){
			ptr = op_prg_list_access(multicast_frame_buffer , j);
			j++;
		}
	
	
		//no more multicast frame
		else if (j == op_prg_list_size(multicast_frame_buffer)){
			ptr = op_prg_list_access(unicast_frame_buffer , i);
			i++;
		}
	
	
		else{
			ptr_uni 	= op_prg_list_access(unicast_frame_buffer , i);
			ptr_multi	= op_prg_list_access(multicast_frame_buffer , j);
			
			//next element for the next time
			if (ptr_uni->time_added < ptr_multi->time_added){
				ptr = ptr_uni;
				i++;
			}
			else{
				ptr = ptr_multi;
				j++;
			}
		}
		
		//result
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)))
			nb++;
	}
	FRET(nb);
}

//Must any multicast / anycast data farme be sent ?
Boolean is_frame_buffer_empty(){
	FIN(is_frame_buffer_empty());
	FRET((get_frame_buffer_size() == 0));
}


//returns the first data frame to send
frame_struct *get_frame_buffer(int pos){
	FIN(get_frame_buffer(int pos));

	frame_struct	*ptr;
	frame_struct	*ptr_uni;
	frame_struct	*ptr_multi;
	int				i , j;
	int				nb = 0;
	
	//initialization
	i = 0;
	//Multicast -> only when all my neighbors can receive it
	if (IS_BROADCAST_FORBIDDEN)
		j = op_prg_list_size(multicast_frame_buffer);
	else
		j = 0;

	while((i < op_prg_list_size(unicast_frame_buffer)) || (j < op_prg_list_size(multicast_frame_buffer))){
	
		//no more unicast frame
		if (i == op_prg_list_size(unicast_frame_buffer)){
			ptr = op_prg_list_access(multicast_frame_buffer , j);
			j++;
		}
	
	
		//no more multicast frame
		else if (j == op_prg_list_size(multicast_frame_buffer)){
			ptr = op_prg_list_access(unicast_frame_buffer , i);
			i++;
		}
	
	
		else{
			ptr_uni 	= op_prg_list_access(unicast_frame_buffer , i);
			ptr_multi	= op_prg_list_access(multicast_frame_buffer , j);
			
			//next element for the next time
			if (ptr_uni->time_added < ptr_multi->time_added){
				ptr = ptr_uni;
				i++;
			}
			else{
				ptr = ptr_multi;
				j++;
			}
		}
		
		//result
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)) && (pos == nb))
			FRET(ptr);
		
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)))
			nb++;
	}
	FRET(NULL);
}



//deletes the multicast or unicast frames with the frame_id 'id'
void del_frame_buffer_with_id(int id , Boolean acknowledged){
	FIN(del_frame_buffer_with_id(int id , Boolean acknowledged));
	
	frame_struct	*ptr;
	char			msg[100];
	int				i;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == id){
			debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d is removed from the data buffer (ack required %d, nb_retry %d, type %s, id %d)\n",  ptr->destination , acknowledged , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(unicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
	}
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->frame_id == id){
			debug_print(LOW, DEBUG_TIMEOUT , "the multicast frame to %d is removed from the data buffer (ack required %d, nb_retry %d, type %s, id %d)\n",  ptr->destination , acknowledged , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(multicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
	}
	FOUT;
}



//returns TRUE if the frame_id is present in the buffer
Boolean is_in_frame_buffer(int frame_id){
	FIN(is_in_frame_buffer(int frame_id));
	
	frame_struct	*ptr;
	int				i;
	
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->frame_id == frame_id)
			FRET(OPC_TRUE);
	}
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == frame_id)
			FRET(OPC_TRUE);
	}
	
	FRET(OPC_FALSE);
}


//Debug
void print_frame_buffer(int debug_type){
	FIN(print_frame_buffer(int debug_type));
	
	print_multicast_frame_buffer(debug_type);
	print_unicast_frame_buffer(debug_type);

	FOUT;
}






//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												ROUTING													  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------




//-----------------------------------------------------------
//
//						NEXT HOP
//
//-----------------------------------------------------------


//returns the next_hop to the sink
int get_next_hop(){
	FIN(get_next_hop());
	
	compar_struct 	next;
	
	debug_print(LOW , DEBUG_DATA , "Route computation toward the sink. Candidates are:\n");
	
	//Next hop
	next.addr		= my_sink_tree.parent;
	next.ktree_dist	= my_sink_tree.ktree_dist;
	next.sink_dist	= my_sink_tree.sink_dist - 1;
			
	debug_print(MAX , DEBUG_DATA , "Next hop (and parent node) to the sink is %d\n", next.addr);

	FRET(next.addr);

}




//-----------------------------------------------------------
//
//					GRID POSITION
//
//-----------------------------------------------------------



//returns the y-coordinate in the grid
int get_y_coord_in_grid(int addr){
	FIN(get_y_coord_in_grid(int addr));
	FRET(addr /  100);
}
//returns the x-coordinate in the grid
int get_x_coord_in_grid(int addr){
	FIN(get_x_coord_in_grid(int addr));
	FRET(addr - ((int) (addr /  100)) * 100);
}



//-----------------------------------------------------------
//
//					IS KTREE_NODE status
//
//-----------------------------------------------------------



//Am I one child of this node?
Boolean is_cmac_child_of(neigh_struct *neigh_ptr, int my_address_tmp){
	FIN(is_cmac_child_of(neigh_struct *neigh_ptr, int my_address_tmp));
	int				i;
	child_struct	*child_ptr;
	
	//Walks in the list
	for(i=0 ; i < op_prg_list_size(neigh_ptr->cmac_children) ; i++){
		child_ptr = op_prg_list_access(neigh_ptr->cmac_children , i);
			
		//It is one parent -> save its stability
		if (child_ptr->address == my_address_tmp)
			FRET(OPC_TRUE);
	}	

	FRET(OPC_FALSE);
}


//empty a list (memory release of all elements)
void empty_list(List **ll_ptr){
	FIN(empty_list(List **ll_ptr));	
	void	*ptr;
	List	*ll = *ll_ptr;
	
	while(op_prg_list_size(ll) != 0){
		ptr = op_prg_list_remove(ll ,0);
		op_prg_mem_free(ptr);
	}
	FOUT;
}


//Is this node a ktree node ?
Boolean	compute_is_in_ktree(){
	FIN(compute_is_in_ktree());
	
	int				i , j;
	neigh_struct	*neigh_ptr;
	child_struct	*child_ptr;
	
	//The sink is always a cmac selected node !
	if (is_sink)
		FRET(OPC_TRUE);	
		
	//Walks in the list
	for(i=op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//Tis is a parent and I am in the list of its ktree children
		if (neigh_ptr->address == my_sink_tree.parent)
			for(j=0 ; j < op_prg_list_size(neigh_ptr->cmac_children) ; j++){
				child_ptr = op_prg_list_access(neigh_ptr->cmac_children , j);
			
				//It is one parent -> save its stability
				if (child_ptr->address == my_address)
					FRET(OPC_TRUE);
			}
	}
	FRET(OPC_FALSE);
}



//Changes the status of this node
Boolean update_is_in_ktree_and_dist(){
	FIN(update_is_in_ktree_and_dist());
	
	int		old_value;

	old_value = my_sink_tree.is_in_ktree;
	my_sink_tree.is_in_ktree = compute_is_in_ktree();
	
	//the value changed !
	if (my_sink_tree.is_in_ktree != old_value){
		
		//updates the ktree distance
		if (my_sink_tree.is_in_ktree)
			my_sink_tree.ktree_dist = 0;
	
		//debug
		print_neighborhood_table(DEBUG_KTREE);
		printf("%f: %d ktree_node status: %d -> %d\n", op_sim_time(), my_address , old_value , my_sink_tree.is_in_ktree);
		debug_print(LOW , DEBUG_KTREE , "changed the ktree_node status: %d -> %d\n", old_value , my_sink_tree.is_in_ktree);
	}
	
	
	//The value changed (a gratuitous hello is surely required)
	FRET(old_value != my_sink_tree.is_in_ktree);
}


//-----------------------------------------------------------
//
//				DISTANCES KTREE / SINK
//
//-----------------------------------------------------------


//update the nb of descendants in the subtree
void update_sink_subtree_size(){
	FIN(update_sink_subtree_size());
	
	neigh_struct	*neigh_ptr;
	int				i;

	//re-intialization (at least myself)
	my_sink_tree.subtree_size = 1;
	
	//adds the subtree size of all my children
	for(i=0; i<op_prg_list_size(my_neighborhood_table); i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table, i);
		
		if (neigh_ptr->parent == my_address){
			my_sink_tree.subtree_size += neigh_ptr->subtree_size;
		}
	}	
	
	FOUT;
}

//for all dynamic algos, create dynamically the tree
void update_sink_tree_infos_dynamic(){
	FIN(update_sink_tree_infos_dynamic());

	int				i;
	neigh_struct	*neigh_ptr;
	short			best_ktree_dist , best_sink_dist;
	int				best_parent;
	
	//initial best values
	best_ktree_dist	= DIST_SINK_MAX;
	best_sink_dist	= DIST_SINK_MAX;
	best_parent		= ADDR_INVALID;
	for(i=0 ; i<op_prg_list_size(my_neighborhood_table); i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table, i);
		
		if 	((stability_get(neigh_ptr) > STAB_MIN) && (neigh_ptr->bidirect)){// && (neigh_ptr->address == my_sink_tree.parent)){
			best_sink_dist	= neigh_ptr->sink_dist + 1;
			best_parent		= neigh_ptr->address;
		}
	}
			
	//Update the distance to the sink and to the ktree
	for(i=0 ; i < op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
				
		if ((stability_get(neigh_ptr) > STAB_MIN) && (neigh_ptr->bidirect) && (neigh_ptr->sink_dist < DIST_SINK_MAX)){
			
			//Distance to the ktree
			if (best_ktree_dist > neigh_ptr->ktree_dist + 1){
				best_ktree_dist = neigh_ptr->ktree_dist + 1;
			}
			
			//Distance to the sink (the parent is the next hop toward the sink)
			//NB: tree of shortest paths toward the sink (and I try to maintain the same parent)
			//NB2: if our parent is among the best parents, let keep it!
			if ((best_sink_dist > neigh_ptr->sink_dist + 1) || ((neigh_ptr->address == my_sink_tree.parent) && (best_sink_dist == neigh_ptr->sink_dist) && (best_sink_dist == neigh_ptr->sink_dist + 1))){
				best_sink_dist = neigh_ptr->sink_dist + 1;
				best_parent		= neigh_ptr->address;
			}
		}		
	}
	
	//no parent -> exit
	if (best_parent == ADDR_INVALID)
		FOUT;
	
	//particular case
	if (my_sink_tree.is_in_ktree)
		best_ktree_dist = 0;
	
	//debug
	if ((my_sink_tree.sink_dist != best_sink_dist) || (my_sink_tree.ktree_dist != best_ktree_dist))
		debug_print(MEDIUM , DEBUG_HELLO , "Updates the distance to the sink %d (old %d) and to the k=tree %d (old %d)\n", neigh_ptr->address, best_ktree_dist, my_sink_tree.sink_dist, best_sink_dist, my_sink_tree.ktree_dist);
	
	if (my_sink_tree.parent	!= best_parent)
		debug_print(MAX, DEBUG_CONTROL, "parent changed %d -> %d \n", my_sink_tree.parent, best_parent);
	
	//final assignment
	my_sink_tree.sink_dist 	= best_sink_dist;
	my_sink_tree.ktree_dist	= best_ktree_dist;
	my_sink_tree.parent		= best_parent;
	
	//update the size of the subtree
	update_sink_subtree_size(best_parent);
	
	if (DEBUG >= MEDIUM)
		print_neighborhood_table(DEBUG_HELLO);
	
	FOUT;
}



//static case -> tree along the grid
void update_sink_tree_infos_static(){
	FIN(update_sink_tree_infos_static());
	short	direction;
	
	//position in the grid (x,y)
	int	x_int = get_x_coord_in_grid(my_address);
	int	y_int = get_y_coord_in_grid(my_address);	

	if ((x_int == x_sink_int) && (y_int == y_sink_int))
		op_sim_end("ERROR: the sink has no parent", "", "","");

	//x axis is closer	
	if (((pow(x_int - x_sink_int, 2) < pow(y_int - y_sink_int, 2)) && (x_int != x_sink_int)) || (y_int == y_sink_int)){
		if (x_int < x_sink_int)
			direction = 1;
		else
			direction = -1;	
		my_sink_tree.parent 	= y_int * 100 + x_int + direction;
		my_sink_tree.ktree_dist = fabs(x_sink_int - x_int);
	}
	else{
		if (y_int < y_sink_int)
			direction = 1;
		else
			direction = -1;	
		my_sink_tree.parent 	= y_int * 100 + x_int + 100 * direction;
		my_sink_tree.ktree_dist = fabs(y_sink_int - y_int);
	}		
	
	//distances to the sink and the ktree
	my_sink_tree.sink_dist 	= fabs(x_sink_int - x_int) + fabs(y_sink_int - y_int);
	if ((x_int == x_sink_int) || (y_int == y_sink_int))
		my_sink_tree.ktree_dist = 0;
	
	debug_print(MAX, DEBUG_CONTROL, "parent %d, sink dist %d, ktree dist %d\n", my_sink_tree.parent, my_sink_tree.sink_dist, my_sink_tree.ktree_dist);
	
	FOUT;
}


//Updates information about the tree toward the sink
//NB: I try to maintain the same parent as previously if it is still valid
void update_sink_tree_infos(){
	FIN(update_sink_tree_infos());
		
	//particular case for the sink
	if (is_sink){
		my_sink_tree.sink_dist 	= 0;
		my_sink_tree.ktree_dist	= 0;
		FOUT;
	}
	
	//data already started
	if ((BLOCK_KTREE_AFTER_START_DATA) && (op_sim_time() > TIME_START_DATA))
		FOUT;	
	
	//dynamic algo
	if (KTREE_ALGO != KTREE_ALGO_STATIC)
		update_sink_tree_infos_dynamic();

	//constructs the tree following the grid
	else
		update_sink_tree_infos_static();

	FOUT;
}




//-----------------------------------------------------------
//
//				KTREE INFO MANAGEMENT
//
//-----------------------------------------------------------



//Returns the CMAC child
child_struct *get_cmac_child(short branch_id){
	FIN(get_cmac_child(short branch_id));	
	child_struct	*child_ptr;
	int				i;
	double			last_polled;
	
	//the usual behavior
	for(i=0; i<op_prg_list_size(my_sink_tree.cmac_children); i++){
		child_ptr = op_prg_list_access(my_sink_tree.cmac_children , i);
		
		if (child_ptr->branch_id == branch_id){
			debug_print(MAX, DEBUG_CONTROL, "child -> %d for branch %d\n", child_ptr->address, branch_id);
			print_neighborhood_table(DEBUG_CONTROL);
			FRET(child_ptr);		
		}
	}
	
	//if the branch_id does not correspond, I search the oldest polled child
	last_polled = -1;
	for(i=0; i<op_prg_list_size(my_sink_tree.cmac_children); i++){
		child_ptr = op_prg_list_access(my_sink_tree.cmac_children , i);
		if ((last_polled == -1) || (last_polled > child_ptr->last_polled))
			last_polled 	= child_ptr->last_polled;
	}
	
	//and I return it! 
	for(i=0; (last_polled != -1) && (i<op_prg_list_size(my_sink_tree.cmac_children)); i++){
		child_ptr = op_prg_list_access(my_sink_tree.cmac_children , i);
		
		if (last_polled == child_ptr->last_polled){
			debug_print(MAX, DEBUG_CONTROL, "child -> %d for branch %d (recovery mode for branch_id %d)\n", child_ptr->address, child_ptr->branch_id, branch_id);
			print_neighborhood_table(DEBUG_CONTROL);
			FRET(child_ptr);		
		}
	}
	
	//default case -> no child at all!
	debug_print(MAX, DEBUG_CONTROL, "child -> none for branch %d\n", branch_id);
	print_neighborhood_table(DEBUG_CONTROL);
	FRET(NULL);
}


//returns the nb of current branches (number of ktree children)
int get_nb_branches(){
	FIN(get_nb_branches());
	FRET(op_prg_list_size(my_sink_tree.cmac_children));
}


//Compares to couples addr/power 
int compare_election_struct(const void *value_a, const void * value_b){
	FIN(compare_election_struct(void *value_a, void * value_b));

	election_struct	a , b;
	
	a = *(election_struct*)value_a;
	b = *(election_struct*)value_b;
	
	
	//null power -> bad
	if (b.pow == 0)
		FRET(1);
	if (a.pow == 0)
		FRET(-1);
	
	//First criterium: branch nb (for the sink, else no particular interest)
	if ((is_sink) && (is_sync_direct_antenna)){
		if (a.branch < b.branch)
			FRET(1);
		if (a.branch > b.branch)
			FRET(-1);
	}
	
	//Second criterium: power
	if (a.pow < b.pow)
		FRET(1);
	if (a.pow > b.pow)
		FRET(-1);
	
	//3rd criterium: id
	if (a.addr > b.addr)
		FRET(1);
	FRET(-1);
}



//-----------------------------------------------------------
//
//				KTREE-CORE ELECTION
//
//-----------------------------------------------------------


//-----------------------------------------------------------
//					SYNC ALGO
//-----------------------------------------------------------

//compare two savings
int saving_value_compare(const void *a_tmp, const void *b_tmp){
	FIN(saving_value_compare(const void *a_tmp, const void *b_tmp));
	saving_comp_struct	*a;
	saving_comp_struct	*b;
	
	a = (saving_comp_struct*)a_tmp;
	b = (saving_comp_struct*)b_tmp;
	
	if (a->saving > b->saving)
		FRET(1);
	if (a->saving < b->saving)
		FRET(-1);
	if (a->address > b->address)
		FRET(1);
	if (a->address < b->address)
		FRET(-1);

	//if savings are identical => we can use any order
	//Indeed, the same node anounces the same saving => it will discriminate its own branch by itself!
	FRET(1);
	op_sim_end("Error, the saving values must be stricly different", "", "", "");
	FRET(0);
}

//searches the node in my chdilren which has the nb^th largest saving
List *neigh_construct_max_saving_child(){
	FIN(neigh_construct_max_saving_child());
	int					i, j;
	neigh_struct		*neigh_ptr;
	saving_comp_struct	*saving_record;
	
	//initialization
	List *ll = op_prg_list_create();
	
	
	//for each neighbor, verify that it is a child & adds its savings in the global list
	for(i=0; i<op_prg_list_size(my_neighborhood_table); i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table, i);
		
		//a node must be a bidirect neighbor with a minimal stability
		if ((neigh_ptr->parent == my_address) && (neigh_ptr->bidirect) && (stability_get(neigh_ptr) >= STAB_MIN))
			for(j=0; j<NB_BRANCHES; j++)
				
				//only strictly positive savings are valid
				if (neigh_ptr->savings[j] > 0){
					saving_record = op_prg_mem_alloc(sizeof(saving_comp_struct));
					saving_record->address 	= neigh_ptr->address;
					saving_record->saving	= neigh_ptr->savings[j];		
					//debug_print(MAX, DEBUG_KTREE, "saving %d %d to insert\n", saving_record->address, saving_record->saving);
					op_prg_list_insert_sorted(ll, saving_record, saving_value_compare); 
				}	
	}	

	FRET(ll);
}


//returns the list of current ktree children
//Remark: when I have only x candidates for y branches (x < y), I re=elect the same node several times to be a child
void update_current_cmac_children_maxtree(){
	FIN(update_current_cmac_children_maxtree());
	//Control
	neigh_struct		*neigh_ptr;
	int					i , j;
	//children
	child_struct		*child_ptr;
	short				nb_branch = 0;
	child_struct		*child_new;
	saving_comp_struct	*child_saving;
	List				*children_sorted_by_savings;

	//special case: the sink MUST elect its children and chooses the branch id by itself
	if (is_sink){
		
		//creates the list of max savigs children
		children_sorted_by_savings = neigh_construct_max_saving_child();
			
		//elects one node per branch (the same node can be chosen several times)
		for(i=0; (i<NB_BRANCHES) && (op_prg_list_size(children_sorted_by_savings) > 0); i++){
					
			//we get the nb_children^th best child
			child_saving = op_prg_list_access(children_sorted_by_savings, i % op_prg_list_size(children_sorted_by_savings));
			
			//and we insert it in the list
			child_new = op_prg_mem_alloc(sizeof(child_struct));
			child_new->address 		= child_saving->address;
			child_new->branch_id	= i;
			child_new->last_polled	= op_sim_time();
			op_prg_list_insert(my_sink_tree.cmac_children, child_new, OPC_LISTPOS_TAIL);
			
			debug_print(MAX, DEBUG_KTREE, "The sink is choosing %d for the branch %d\n", child_new->address, child_new->branch_id);
		}
	}
	
	
	//searches if I am the children of anyone
	//Be careful, I can be several times children 
	for(i=0; (!is_sink) && (i<op_prg_list_size(my_neighborhood_table)); i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table, i);
		
		if (neigh_ptr->address == my_sink_tree.parent){		
			for(j=0; j<op_prg_list_size(neigh_ptr->cmac_children); j++){
				child_ptr = op_prg_list_access(neigh_ptr->cmac_children, j);
			
				//I have to choose the nb^th max savings value as my child (with the corresponding branch_id) 
				if (child_ptr->address == my_address){
					//debug_print(MAX, DEBUG_KTREE, "I am a child for %d (branch id %d)\n", neigh_ptr->address, child_ptr->branch_id);
					
					//for the first child, we compute the sorted set of candidates
					if (nb_branch == 0)
						children_sorted_by_savings = neigh_construct_max_saving_child();
					
					//We must have at least one candidate before electing it
					if (op_prg_list_size(children_sorted_by_savings) > 0){
					
						//we get the nb_children^th best child
						child_saving = op_prg_list_access(children_sorted_by_savings, nb_branch++ % op_prg_list_size(children_sorted_by_savings));
					
						//and we insert it in the list
						child_new = op_prg_mem_alloc(sizeof(child_struct));
						child_new->address 		= child_saving->address;
						child_new->branch_id	= child_ptr->branch_id;
						child_new->last_polled	= op_sim_time();
						op_prg_list_insert(my_sink_tree.cmac_children, child_new, OPC_LISTPOS_TAIL);
					
						debug_print(MAX, DEBUG_KTREE, "node %d was elected child (branch %d, saving %d)\n", child_new->address, child_new->branch_id, child_saving->saving);
					}
				}
			}		
		}
	}
	
	//memory release
	//the list of children sorted by saving values (only if we are the child of at least one node)
	if (nb_branch > 0){
		for(i=op_prg_list_size(children_sorted_by_savings) - 1; i>=0; i--){
			child_saving = op_prg_list_remove(children_sorted_by_savings, i);
			op_prg_mem_free(child_saving);
		}
		op_prg_mem_free(children_sorted_by_savings);
	}
	
	char msg[100], str[100];
	snprintf(msg, 100, "FINAL_CHILDREN_LIST: <");
	for(i=0 ; i < op_prg_list_size(my_sink_tree.cmac_children) ; i++){
		child_ptr = op_prg_list_access(my_sink_tree.cmac_children , i);
		snprintf(str, 100, "%s %d (branch %d) ", msg, child_ptr->address, child_ptr->branch_id);
		strncpy(msg, str, 100);
	}
	debug_print(MAX, DEBUG_KTREE, "%s>\n", msg);
	
	
	print_neighborhood_table(DEBUG_KTREE);
	
	FOUT;
}


//returns the list of current ktree chdilren
void update_current_cmac_children_sync(){
	FIN(update_current_cmac_children_sync());
	
	int				i;
	neigh_struct	*neigh_ptr;
	//To store all the power, sorted, in a list
	List			*max_sync_rx_power;
	election_struct	*election_ptr;
	//Control
	child_struct	*child_ptr;
	short			branch_tmp = -1;
	//conditions
	Boolean			direct_and_new;
	Boolean			no_direct_and_new;

	
	//empty the old list
	while(op_prg_list_size(my_sink_tree.cmac_children) > 0){
		child_ptr = op_prg_list_remove(my_sink_tree.cmac_children , 0);
		op_prg_mem_free(child_ptr);
	}

	//--------------------------------------------------
	//				NO KTREE NODE
	//--------------------------------------------------
	if ((!is_sink) && ((my_sync_rx_power == 0) || (!my_sink_tree.is_in_ktree))){// || (my_sink_tree.sink_dist > MAX_BRANCH_LENGTH))){
		//debug_print(MAX , DEBUG_KTREE , "No ktree node: %d %d %d\n", my_sync_rx_power == 0 , !my_sink_tree.is_in_ktree , my_sink_dist > MAX_BRANCH_LENGTH);
		FOUT;
	}
	else{
		//initialization
		max_sync_rx_power = op_prg_list_create();	
		
		
		//--------------------------------------------------
		//	Stores all the power of my neighbors (sorted)
		//  They must have a sufficient stability metric
		//--------------------------------------------------
		for(i= op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
			
			neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
			//Adds the power if the node is farther from the sink
			if ((neigh_ptr->sink_dist > my_sink_tree.sink_dist) && (stability_get(neigh_ptr) > STAB_MIN) && (neigh_ptr->bidirect)){
				election_ptr = op_prg_mem_alloc(sizeof(election_struct));
				election_ptr->addr 	= neigh_ptr->address;
				election_ptr->pow 	= neigh_ptr->sync_rx_power;
				op_prg_list_insert_sorted(max_sync_rx_power , election_ptr , compare_election_struct);
			}
		}
	
		//--------------------------------------------------
		//			No node in the list
		//--------------------------------------------------
		if (op_prg_list_size(max_sync_rx_power) == 0){
		}
	
		//--------------------------------------------------
		//		For the sink -> places the N min power
		//--------------------------------------------------
		else if (is_sink){
			debug_print(LOW , DEBUG_KTREE , "cmac children: \n");

			//Firt branch to deal with
			branch_tmp = -1;
			
			//Walks in the sorted list of my neighbors
			for(i=0 ; i < op_prg_list_size(max_sync_rx_power) ; i++){
				election_ptr = op_prg_list_access(max_sync_rx_power , i);
				
				debug_print(MAX , DEBUG_KTREE , "	ptr (%d : %d %f) current (%d)\n", election_ptr->addr , election_ptr->branch , election_ptr->pow , branch_tmp);
				
				//Eliminates nodes nearer from the sink than I am
				direct_and_new		= (is_sync_direct_antenna) && (election_ptr->branch > branch_tmp);
				no_direct_and_new	= (!is_sync_direct_antenna) && (i < NB_BRANCHES);
				
				if ((election_ptr->pow != 0) && (direct_and_new || no_direct_and_new)){
					branch_tmp = election_ptr->branch;
				
					//creates a list of current ktree children
					child_ptr = op_prg_mem_alloc(sizeof(child_struct));
					child_ptr->address 		= election_ptr->addr;
					child_ptr->branch_id 	= election_ptr->branch;
					op_prg_list_insert(my_sink_tree.cmac_children , child_ptr , OPC_LISTPOS_TAIL);
					
					//debug_print(MAX , DEBUG_KTREE , "	->%d\n", child_ptr->address);					
				}
			}
		}	
		//------------------------------------------------------
		//	For a normal ktree node, chooses only the lowest
		//------------------------------------------------------
		else{

			election_ptr = op_prg_list_access(max_sync_rx_power , 0);
			
			if ((election_ptr->pow < my_sync_rx_power) && (election_ptr->pow != 0)){
				debug_print(MAX , DEBUG_KTREE , "node %d chosen as cmac child\n", election_ptr->addr);
					
				//creates a list of current ktree nodes
				child_ptr = op_prg_mem_alloc(sizeof(child_struct));
				child_ptr->address 		= election_ptr->addr;
				child_ptr->branch_id 	= election_ptr->branch;
				op_prg_list_insert(my_sink_tree.cmac_children , child_ptr , OPC_LISTPOS_TAIL);
			}
			else
				debug_print(MAX , DEBUG_KTREE , "no cmac-child node : %d\n", election_ptr->pow < my_sync_rx_power , election_ptr->pow != 0);
			
		
		}
			

		//--------------------------------------------------
		//			release memory
		//--------------------------------------------------
		while(op_prg_list_size(max_sync_rx_power) > 0){
			election_ptr = op_prg_list_remove(max_sync_rx_power , 0);
			op_prg_mem_free(election_ptr);
		}
		op_prg_mem_free(max_sync_rx_power);
	}
	
	debug_print(LOW , DEBUG_KTREE , "FINAL_LIST\n");
	for(i=0 ; i < op_prg_list_size(my_sink_tree.cmac_children) ; i++){
		child_ptr = op_prg_list_access(my_sink_tree.cmac_children , i);
		debug_print(LOW , DEBUG_KTREE , "  : %d\n", child_ptr->address);
	}
	
	FOUT;
}

//direction number (normalized)
short addr_to_direction_in_grid(int addr){
	FIN(addr_to_direction_in_grid(int addr));
	
	int	x_int = get_x_coord_in_grid(addr);
	int	y_int = get_y_coord_in_grid(addr);	
	
	if (x_int < x_sink_int)
		FRET(0);
	if (x_int > x_sink_int)
		FRET(1);
	if (y_int < y_sink_int)
		FRET(2);
	if (y_int > y_sink_int)
		FRET(3);

	op_sim_end("Error: unknown direction for this address","", "", "");
	FRET(0);
}



//the increment for the normalized direction (to the sink)
short direction_to_addr_incr_in_grid(int direction){
	FIN(direction_to_addr_incr_in_grid(int direction));
	
	switch(direction){	
		case 0:
			FRET(-1);
		case 1:
			FRET(1);
		case 2:
			FRET(-100);
		case 3:
			FRET(100);	
	}
	
	op_sim_end("Error: unknown direction","", "", "");
	FRET(0);
}

//was this address attributed to at least one node?
Boolean does_node_address_exists(int addr){
	FIN(does_node_address_exists(int addr));
	
	int		i;
	
	//a simple walk in the list of attributed addresses!
	for(i=0; i<get_nb_nodes(); i++)
		if (nodeid_to_addr_var[i] == addr)
			FRET(OPC_TRUE);
	
	FRET(OPC_FALSE);
}

//returns the list of current ktree chdilren (children are chosen along the grid in a static manner)
void update_current_cmac_children_static(List * old_cmac_children){
	FIN(update_current_cmac_children_static(List * old_cmac_children));
	child_struct	*child_ptr;
	int				i;

	//not a ktree-node -> no child
	if ((!my_sink_tree.is_in_ktree) || (ktree_static_ok[my_stat_id])){
		op_prg_list_free(my_sink_tree.cmac_children);
		op_prg_list_elems_copy(old_cmac_children, my_sink_tree.cmac_children);
		debug_print(LOW, DEBUG_CONTROL, "static -> %d %d\n", my_sink_tree.is_in_ktree, ktree_static_ok[my_stat_id]);
		FOUT;
	}
	
	//empty the old list
	op_prg_list_free(my_sink_tree.cmac_children);

	//how many branches have we got?
	if (is_sink){
		for(i=0; i<4; i++)
			if ((direction_to_branch_id[i] > -1) && (does_node_address_exists(my_address + direction_to_addr_incr_in_grid(i)))){
				child_ptr = op_prg_mem_alloc(sizeof(child_struct));
				child_ptr->address 		= my_address + direction_to_addr_incr_in_grid(i);
				child_ptr->branch_id 	= direction_to_branch_id[i];
				op_prg_list_insert(my_sink_tree.cmac_children , child_ptr , OPC_LISTPOS_TAIL);
			}
	
	}
	//other nodes choose to forward along their axis
	else if (my_sink_tree.is_in_ktree) {
		short direction = addr_to_direction_in_grid(my_address);
	 
		if (does_node_address_exists(my_address + direction_to_addr_incr_in_grid(direction))){
			child_ptr = op_prg_mem_alloc(sizeof(child_struct));
			child_ptr->address 		= my_address + direction_to_addr_incr_in_grid(direction);
			child_ptr->branch_id 	= direction_to_branch_id[direction];
			op_prg_list_insert(my_sink_tree.cmac_children , child_ptr , OPC_LISTPOS_TAIL);
		}
		else
			debug_print(LOW, DEBUG_CONTROL, "%d does not exist\n", my_address + direction_to_addr_incr_in_grid(direction) );
	}
	
	ktree_static_ok[my_stat_id] = OPC_TRUE;
	
	FOUT;
}

//print a list of children
void print_cmac_children(List *ll, short debug_type){
	FIN(print_cmac_children(List *ll, short debug_type));
	int				i;
	char			msg[200], str[200];
	child_struct	*child_ptr;
	
	strcpy(msg, "");
	for(i=0; i<op_prg_list_size(ll); i++){
		child_ptr = op_prg_list_access(ll, i);
		
		snprintf(str, 200, "%s | %d (%d) ", msg, child_ptr->address, child_ptr->branch_id);
		strncpy(msg, str, 200);
	}
	debug_print(MEDIUM, debug_type, "%s\n", msg);
	
	FOUT;
}

//-----------------------------------------------------------
//					COMMON
//-----------------------------------------------------------

	
//updates my cmac children and return if it actually changes
Boolean update_current_cmac_children(){
	FIN(update_current_cmac_children());
	
	child_struct	*child_ptr, *child_ptr2;
	int				i , j, k;
	Boolean			list_changed;
	Boolean			found;
	List			*old_cmac_children, *l1, *l2;
	
	//only for cmac!
	if ((MAC_LAYER != CMAC) || (FREEZE_HELLO_DISCOVERY_AFTER_CONVERGENCE && op_sim_time() > TIME_BEFORE_HELLO_CONVERGENCE))
		FRET(OPC_FALSE);
	
	//saves the old list
	old_cmac_children = my_sink_tree.cmac_children;
	my_sink_tree.cmac_children = op_prg_list_create();	
	
	//elects the children, depdends on the ktree creation algo
	switch(KTREE_ALGO){
	
		case KTREE_ALGO_SYNC :
			update_current_cmac_children_sync();
		break;
		
		case KTREE_ALGO_MAXTREE :
			update_current_cmac_children_maxtree();
		break;
		
		case KTREE_ALGO_STATIC :
			update_current_cmac_children_static(old_cmac_children);
		break;
		
		default:
			op_sim_end("You have to specify a ktree-algo to construct the structure", "", "", "");
		break;
	}
	
	//does at least one child was added / removed
	list_changed = OPC_FALSE;
	for(k=0; k<2; k++){
		//elements of k1 that are not in k2
		if (k == 0){
			debug_print(LOW, DEBUG_CONTROL, "New list\n");
			l1 = my_sink_tree.cmac_children;
			l2 = old_cmac_children;
		}
		//inverse
		else{
			debug_print(LOW, DEBUG_CONTROL, "Old list\n");
			l1 = old_cmac_children;
			l2 = my_sink_tree.cmac_children;		
		}
	
		//differents
		for(i=0; i<op_prg_list_size(l1); i++){
			child_ptr = op_prg_list_access(l1 , i);
			found = OPC_FALSE;
			
			for(j=0; !found && j<op_prg_list_size(l2); j++){
				child_ptr2 = op_prg_list_access(l2 , j);
				if ((child_ptr2->address == child_ptr->address) && (child_ptr2->branch_id == child_ptr->branch_id)){
					debug_print(LOW, DEBUG_CONTROL, "Child found %d, branch_id %d\n", child_ptr->address, child_ptr->branch_id);
					found = OPC_TRUE;
				}
			}
			
			if (!found){
				debug_print(LOW, DEBUG_CONTROL, "Child changed %d, branch_id %d\n", child_ptr->address, child_ptr->branch_id);
				list_changed = OPC_TRUE;
			}
		}
	}
	if (list_changed){
		debug_print(LOW, DEBUG_CONTROL, "New list of children:\n");
		print_cmac_children(my_sink_tree.cmac_children, DEBUG_CONTROL);
		debug_print(LOW, DEBUG_CONTROL, "Old list of children:\n");
		print_cmac_children(old_cmac_children, DEBUG_CONTROL);
	}	
	
	//empty the old list
	op_prg_list_free(old_cmac_children);
	op_prg_mem_free(old_cmac_children);

	
	FRET(list_changed);
}






//-----------------------------------------------------------
//
//				KTREE FIELDS in HELLOS
//
//-----------------------------------------------------------

//returns an array with zero values to 'simulate an array of savings 
//=> no need to change other functions if we do not include it in the packets
short *create_null_savings(){
	FIN(create_null_savings());
	int		i;
	short	*savings_field = op_prg_mem_alloc(sizeof(short) * NB_BRANCHES);
	
	for(i=0; i<NB_BRANCHES; i++)
		savings_field[i] = 0;
	
	FRET(savings_field);
}

//Creates a list of ktree nodes
short *create_savings_from_packet(Packet *pk){
	FIN(create_savings_from_packet(Packet *pk));
	
	//Control
	int		i;
	//list of savings
	short	*savings_ptr;
			
	//nb ktree nodes
	int source;
	op_pk_nfd_get_int32(pk, FIELD_PK_SOURCE,		&source);
	op_pk_nfd_get_ptr(pk, 	FIELD_PK_HELLO_SAVINGS,	(void**)&savings_ptr);

	
	//DEBUG
	char	msg[100], str[100];
	snprintf(msg, 100, "Savings in the transmitted hello: "); 
	for(i=0 ; i<NB_BRANCHES; i++){
		snprintf(str, 100, "%s %d ", msg, savings_ptr[i]);
		strncpy(msg, str, 100);
	}
	debug_print(MEDIUM, DEBUG_KTREE, "%s\n", msg); 
	
	FRET(savings_ptr);
}


//fills the packet with the list of my savings
void fill_savings_fields(Packet *pk){
	FIN(fill_savings_fields(Packet *pk));
	
	//to manage the savnigs value in the neighborhood
	List				*sav_list;
	saving_comp_struct	*sav_ptr;
	short				*saving_field = op_prg_mem_alloc(sizeof(short) * NB_BRANCHES);
	//control
	int		i;
	
	//extract the best children
	sav_list = neigh_construct_max_saving_child();
	
	//and adds them in the packet
	for(i=0; i<NB_BRANCHES; i++){		
		
		//no child case: the single saving is myself
		if ((i == 0) && (op_prg_list_size(sav_list) == 0)){
			saving_field[i] = 1;		
		}
		//first child: the subtree size
		else if (i == 0){
			sav_ptr = op_prg_list_access(sav_list, i);
			saving_field[i] = my_sink_tree.subtree_size + sav_ptr->saving;		
		}
		//for other children, I just forward their savings without any modification
		else if (op_prg_list_size(sav_list) > i){
			sav_ptr = op_prg_list_access(sav_list, i);
			saving_field[i] = sav_ptr->saving;		
		}
		//no candidate
		else{
			saving_field[i] = 0;		
		}
	}
	op_pk_nfd_set_ptr(pk, FIELD_PK_HELLO_SAVINGS, saving_field, op_prg_mem_copy_create, op_prg_mem_free, sizeof(short) * NB_BRANCHES);
	
	//memory release
	for(i=op_prg_list_size(sav_list)-1; i>=0; i--){
		sav_ptr = op_prg_list_remove(sav_list, i);
		op_prg_mem_free(sav_ptr);
	}
	op_prg_mem_free(sav_list);
	
	//debug purpose
	//print_neighborhood_table(DEBUG_HELLO);
	
	FOUT;
}


//Creates a list of sinktree nodes
List *create_my_cmac_children_from_packet(Packet *pk){
	FIN(create_my_cmac_children_from_packet(Packet *pk));
	
	//result
	List			*ll;
	//List size and elements
	int				nb_cmac_children;
	child_struct	*child_ptr;
	//Control
	int				i;
	//info
	int				source;
	//list of children
	child_struct	*list_children_ptr;
	
	//init
	ll = op_prg_list_create();
		
	//nb ktree nodes
	op_pk_nfd_get(pk,		FIELD_PK_HELLO_NB_CMAC_CHILDREN, 	&nb_cmac_children);
	op_pk_nfd_get_int32(pk, FIELD_PK_SOURCE, 					&source);
	op_pk_nfd_get_ptr(pk, 	FIELD_PK_HELLO_CMAC_CHILDREN,		(void**)&list_children_ptr);

	//insert each ktree children in the list
	//debug_print(MAX, DEBUG_HELLO, "Hello extraction - cmac children:\n");
	for(i=0 ; i<nb_cmac_children; i++){
		child_ptr 	= op_prg_mem_alloc(sizeof(child_struct));
		child_ptr->address 		= list_children_ptr[i].address;
		child_ptr->branch_id 	= list_children_ptr[i].branch_id;
		op_prg_list_insert(ll , child_ptr , OPC_LISTPOS_HEAD);
		debug_print(MAX, DEBUG_HELLO, "\t%d (branch %d)\n", child_ptr->address, child_ptr->branch_id);
		
		if ((child_ptr->address == my_address) && (my_sink_tree.parent != source))
			debug_print(LOW, DEBUG_HELLO, "Inconsistent decision: %d chosed me as child although it is not my parent!\n", source);
	}
	
	//memory release for the packet field itself
	if (nb_cmac_children != 0)
		op_prg_mem_free(list_children_ptr);
	
	FRET(ll);
}


//fills the packet with the list of my cmac-tree children
void fill_cmac_children_fields(Packet *pk){
	FIN(fill_cmac_children_fields(Packet *pk));
	
	child_struct	*child_ptr;
	//Control
	int				i;
	//list of children
	child_struct	*list_children_ptr;
	int				nb_cmac_children;
	
	//updates my list of cmac chdilren (just before transmitting the hello)
	update_current_cmac_children();
	nb_cmac_children = op_prg_list_size(my_sink_tree.cmac_children);
	debug_print(MAX, DEBUG_HELLO, "%d children to announce in my hellos\n", nb_cmac_children);
	
	//nb of children
	op_pk_nfd_set(pk, FIELD_PK_HELLO_NB_CMAC_CHILDREN, nb_cmac_children);

	//Fills ktree children fields
	if (nb_cmac_children != 0){
		list_children_ptr = op_prg_mem_alloc(sizeof(child_struct) * nb_cmac_children);
	
		for(i=0; i<nb_cmac_children; i++){
			child_ptr = op_prg_list_access(my_sink_tree.cmac_children, i);
			list_children_ptr[i].address 	= child_ptr->address;			
			list_children_ptr[i].branch_id 	= child_ptr->branch_id;			
			debug_print(MAX, DEBUG_HELLO, "\t%d (branch %d)\n", child_ptr->address, child_ptr->branch_id);			
		}		
		op_pk_nfd_set_ptr(pk, FIELD_PK_HELLO_CMAC_CHILDREN, list_children_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof(child_struct) * nb_cmac_children);
	}
	
	//print_neighborhood_table(DEBUG_HELLO);
	FOUT;
}






//-----------------------------------------------------------
//
//						STABILITY
//
//-----------------------------------------------------------


//updates the stability metric
void stability_update(neigh_struct *neigh_ptr, Boolean received){
	FIN(stability_update(neigh_struct *neigh_ptr, Boolean received));
	
	(neigh_ptr->stability)[neigh_ptr->stability_ptr] = received;
	neigh_ptr->stability_ptr	= (neigh_ptr->stability_ptr + 1) % STAB_NB;
	
	FOUT;
}

//intializes the stability metric
void stability_init(neigh_struct *neigh_ptr){
	FIN(stability_init(neigh_struct *neigh_ptr));
	
	
	neigh_ptr->stability = op_prg_mem_alloc(sizeof(Boolean) * STAB_NB);
	neigh_ptr->stability_ptr = 0;	
	
	FOUT;
}

//computes the stability associated to this array of booleans
double stability_get(neigh_struct *neigh_ptr){
	FIN(stability_get(neigh_struct *neigh_ptr));
	short	res = 0;
	int		i;
	
	for(i=0; i<STAB_NB; i++)
		res += neigh_ptr->stability[i];
		
	FRET((double)res / STAB_NB);
}


//-----------------------------------------------------------
//
//					HELLOS
//
//-----------------------------------------------------------

//Does the source receive correctly my own hello packets 
Boolean is_bidirect_from_packet(Packet *pk){
	FIN(is_bidirect_from_packet(Packet *pk));
	int		*list_neighs_ptr;
	int		nb_neighs;
	int		i;
	
	//the fields in the packet
	op_pk_nfd_get(pk, FIELD_PK_HELLO_NEIGH_TABLE_SIZE, &nb_neighs);	
	if (nb_neighs == 0)
		FRET(OPC_FALSE);
	op_pk_nfd_get_ptr(pk, FIELD_PK_HELLO_NEIGH_TABLE, (void**)&list_neighs_ptr);

	//am in the list of its neighbors?
	for(i=0; i<nb_neighs; i++)
		if (list_neighs_ptr[i] == my_address)
			FRET(OPC_TRUE);
	op_prg_mem_free(list_neighs_ptr);
	
	FRET(OPC_FALSE);
}


//fills the packet with the list of my cmac-tree children
void fill_neigh_table_fields(Packet *pk){
	FIN(fill_neigh_table_fields(Packet *pk));
	
	int				*list_neighs_ptr;
	int				i, ptr;
	neigh_struct	*neigh_ptr;
	
	//the number of neighbors to include
	int	nb_neighs = 0;
	for(i=0; i<op_prg_list_size(my_neighborhood_table); i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
	
		if (stability_get(neigh_ptr) > STAB_MIN)
			nb_neighs++;		
	}
	op_pk_nfd_set(pk, FIELD_PK_HELLO_NEIGH_TABLE_SIZE, nb_neighs);	
	
	//Fills the list of children children fields
	if (nb_neighs != 0){
	
		//memory allocation
		list_neighs_ptr = op_prg_mem_alloc(sizeof(int) * nb_neighs);
		ptr = 0;
	
		//fill it
		for(i=0; i<op_prg_list_size(my_neighborhood_table); i++){
			neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
	
			if (ptr > nb_neighs)
				op_sim_end("Memory error", "Your array is not sufficiently large to store all your neighbors", "Bug in the implementation", "");
				
			if (stability_get(neigh_ptr) > STAB_MIN)
				list_neighs_ptr[ptr++] = neigh_ptr->address;		
		}		
		
		//and finally assign this value to the packet
		op_pk_nfd_set_ptr(pk, FIELD_PK_HELLO_NEIGH_TABLE, (void*)list_neighs_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof(int) * nb_neighs);
	}	
	
	FOUT;
}




//Generates an hello (next frame to send !)
void generate_hello(double next_hello){ 
	FIN(generate_hello(double next_hello));
	
	//Packet to send
	frame_struct	frame;
	//info
	int				frame_id;
	
	//frame id
	frame_id = get_new_frame_id();
	
	frame.source				= my_address;
	frame.destination			= ADDR_BROADCAST;
	frame.type					= HELLO_PK_TYPE;
	frame.frame_id				= frame_id;
	frame.nb_retry				= 0;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	frame.nav_duration			= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE + SINK_DIST_SIZE + KTREE_DIST_SIZE;
	frame.next_hello			= next_hello;
	
	//Adds the hello in head of the data packet buffer
	add_in_multicast_frame_buffer(frame , OPC_LISTPOS_HEAD);
	is_hello_to_send 			= OPC_TRUE;
	
	debug_print(LOW , DEBUG_HELLO , "HELLO generated toward %d\n", frame.destination);
	
	FOUT;
}


//Deletes the neighbors which did not send an HELLO for a long time (timeout)
void delete_timeouted_neighbors(void *ptr , int code){
	FIN(delete_timeouted_neighbors(void *ptr , int code));
		
	double			older_entry = 0;
	int				i;
	neigh_struct	*neigh_ptr;
	Boolean			is_modif_required = OPC_FALSE;
		
	//Walks in the list
	for(i= op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//The entry is timeouted -> stability --
		if (neigh_ptr->timeout <= op_sim_time()){
			if ((op_sim_time() < TIME_BEFORE_HELLO_CONVERGENCE) || (!FREEZE_HELLO_DISCOVERY_AFTER_CONVERGENCE))
				stability_update(neigh_ptr, OPC_FALSE);		
			//debug_print(MEDIUM, DEBUG_HELLO, "Stability for node %d decreases to %f\n", neigh_ptr->address, stability_get(neigh_ptr));
			
			//next timeout 
			if (op_sim_time() < TIME_BEFORE_HELLO_CONVERGENCE)
				neigh_ptr->timeout 	+= HELLO_PK_PERIOD_BEFORE_CONVERGENCE + HELLO_PK_PERIOD_BEFORE_CONVERGENCE / 10;
			else
				neigh_ptr->timeout 	+= HELLO_PK_PERIOD + HELLO_PK_PERIOD / 10;			
			
			//the PDR is 0 -> we just remove this neighbor
			if (stability_get(neigh_ptr) == 0){
				neigh_ptr = op_prg_list_remove(my_neighborhood_table , i);
			
				debug_print(LOW , DEBUG_HELLO , "neighbor %d timeouted after a null stability\n", neigh_ptr->address);

				empty_list(&(neigh_ptr->cmac_children));
				op_prg_mem_free(neigh_ptr->cmac_children);
				op_prg_mem_free(neigh_ptr->stability);
				op_prg_mem_free(neigh_ptr);
				neigh_ptr = NULL;

				is_modif_required = OPC_TRUE;
			}
			else if (stability_get(neigh_ptr) < STAB_MIN)
				is_modif_required = OPC_TRUE;
		}
		
		//when must be done the next verification ?
		if ((neigh_ptr != NULL) && ((older_entry > neigh_ptr->timeout) || (older_entry == 0)))
			older_entry = neigh_ptr->timeout;
	}
	
	
	//Modification in the neighborhood table !
	if (is_modif_required){
		//ktree node
		if (update_is_in_ktree_and_dist())
			generate_hello(0);

		//Distances
		update_sink_tree_infos();		
		print_neighborhood_table(DEBUG_HELLO);
	}
	
	//Next verification
	if (op_prg_list_size(my_neighborhood_table) != 0)
		op_intrpt_schedule_call(older_entry , NEIGHBOR_TIMEOUT_CODE , delete_timeouted_neighbors , NULL);
	
	FOUT;	
}


//replaces the corresponding child for the source
Boolean neighborhood_table_cmac_children_replace_for_node(int source, short branch_id, int child){
	FIN(neighborhood_table_cmac_children_replace_for_node(int source, short branch_id, int child));
	int				i, j;
	neigh_struct	*neigh_ptr;
	child_struct	*child_ptr;
	
	for(i=0; i<op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
	
		if (neigh_ptr->address == source){
		
			//replaces an existing child for this branch_id
			for(j=0; j<op_prg_list_size(neigh_ptr->cmac_children); j++){
				child_ptr = op_prg_list_access(neigh_ptr->cmac_children, j);
				if (child_ptr->branch_id == branch_id){
				debug_print(LOW, DEBUG_CONTROL, "I modified the child %d -> %d (branch_id %d) for node %d\n", child, child_ptr->address, branch_id, source);
					child_ptr->address = child;
					FRET(OPC_TRUE);
				}
			}
			
			//adds a child for this node (none exists for this branch_id)
			child_ptr = op_prg_mem_alloc(sizeof(child_struct));
			child_ptr->branch_id 	= branch_id;
			child_ptr->address		= child;
			op_prg_list_insert(neigh_ptr->cmac_children, child_ptr, OPC_LISTPOS_HEAD);
			debug_print(LOW, DEBUG_CONTROL, "I added the child %d (branch_id %d) for node %d\n", child, branch_id, source);
			FRET(OPC_TRUE);
		}
	}
	
	debug_print(LOW, DEBUG_CONTROL, "I cannot modify the children list for node %d since it is not present in the neighborhood table\n", source);
	
	FRET(OPC_FALSE);
}


//updates the neighborhood table with one new entry !
void update_neighborhood_table(int source , Boolean bidirect, int sink_dist , int ktree_dist, double sync_rx_power, int parent, short subtree_size, short *savings, int branch , List *cmac_children_tmp , double next_hello){
	FIN(update_neighborhood_table(int source , Boolean bidirect, int sink_dist , int ktree_dist, double sync_rx_power, int parent, short_subtree_size, short *savings, int branch , List *cmac_children_tmp , double next_hello));
	
	int				i;
	neigh_struct	*neigh_ptr;
	Boolean	neighbor_updated 				= OPC_FALSE;
	Boolean	hello_required 					= OPC_FALSE;
	Boolean	update_cmac_children_required 	= OPC_FALSE;
		
	//---------------------------
	//		LIST UPDATE
	//---------------------------
	for(i=0; i<op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
	
		if (neigh_ptr->address == source){
			//flush the list
			empty_list(&(neigh_ptr->cmac_children));
			op_prg_mem_free(neigh_ptr->cmac_children);
			op_prg_mem_free(neigh_ptr->savings);
			
			//an urgent verification is required
			if ((neigh_ptr->parent == my_address) && (parent != my_address))
				update_cmac_children_required = OPC_TRUE;
			
			//update
			neigh_ptr->bidirect			= bidirect;
			neigh_ptr->sink_dist		= sink_dist;
			neigh_ptr->ktree_dist		= ktree_dist;
			neigh_ptr->sync_rx_power	= sync_rx_power;
			neigh_ptr->parent			= parent;
			neigh_ptr->cmac_children	= cmac_children_tmp;
			neigh_ptr->subtree_size		= subtree_size;
			neigh_ptr->savings			= savings;
			neighbor_updated 			= OPC_TRUE;
			
			//is that a gratuitous hello or not?
			if (next_hello != 0){
				neigh_ptr->timeout		= op_sim_time() + next_hello + next_hello / 10;			
				stability_update(neigh_ptr, OPC_TRUE);
			}	
			debug_print(MEDIUM , DEBUG_HELLO, "neighbor %d updated (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);

		}	
	}
	

	//---------------------------
	//		LIST ADD
	//---------------------------
	if (!neighbor_updated){
		//We add one entry -> we must schedule the timeout verification
		if (op_prg_list_size(my_neighborhood_table) == 0)			
			op_intrpt_schedule_call(op_sim_time() + next_hello + next_hello / 10 , NEIGHBOR_TIMEOUT_CODE , delete_timeouted_neighbors , NULL);

		neigh_ptr = op_prg_mem_alloc(sizeof(neigh_struct));
		stability_init(neigh_ptr);
		neigh_ptr->address			= source;
		neigh_ptr->bidirect			= bidirect;
		neigh_ptr->sink_dist		= sink_dist;
		neigh_ptr->ktree_dist		= ktree_dist;
		neigh_ptr->sync_rx_power	= sync_rx_power;
		neigh_ptr->parent			= parent;
		neigh_ptr->subtree_size		= subtree_size;
		neigh_ptr->savings			= savings;
		neigh_ptr->cmac_children	= cmac_children_tmp;
		neigh_ptr->timeout			= op_sim_time() + next_hello + next_hello / 10;			
		stability_update(neigh_ptr, OPC_TRUE);
		op_prg_list_insert(my_neighborhood_table , neigh_ptr , OPC_LISTPOS_TAIL);	  
		
	
		debug_print(MEDIUM , DEBUG_HELLO, "neighbor %d added (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);
	}
	
	//-------------------------------------------------
	//		INFOS ABOUT THE TREE ROOTED AT THE SINK
	//-------------------------------------------------
	update_sink_tree_infos();
	
	//---------------------------
	//		IS KTREE NODE ?
	//---------------------------
	//NB: I must verify for each reception 
	//the source may have change the list of its ktree children	
	if (update_is_in_ktree_and_dist())
		hello_required = OPC_TRUE;
	
	if (update_cmac_children_required){
		if (update_current_cmac_children())
			hello_required = OPC_TRUE;
	}		
	
	//I changed by ktree node status or my distance to sink / ktree
	if (hello_required){
		print_neighborhood_table(DEBUG_HELLO);
		generate_hello(0);
	}
	
	FOUT;
}

//converts a list of int* in a string
char *array_of_short_to_str(short* tab, short nb_elem, char *msg, int length, Boolean padding){

	FIN(array_of_short_to_str(short* tab, short nb_elem, char *msg, int length, Boolean padding));
	
	int		i;
	char	str[100];

	strncpy(msg, "", length);
	for(i=0; i < nb_elem ; i++){
		snprintf(str , 100, "%s %d", msg , tab[i]);
		strncpy(msg, str, length);
	}
	if(padding)
		for(i=strlen(msg); i<length; i++)
			strncat(msg, " ", length);
	
	FRET(msg);
}


//converts a list of int* in a string
char *list_of_int_ptr_to_str(List* ll, char *msg, int length, Boolean padding){

	FIN(list_of_int_ptr_to_str(List* ll, char *msg, int length, Boolean padding));
	
	int		i;
	int		*int_ptr;
	char	str[100];

	strncpy(msg, "", length);
	for(i=0; i < op_prg_list_size(ll) ; i++){
		int_ptr = op_prg_list_access(ll , i);
		snprintf(str , 100, "%s %d", msg , *int_ptr);
		strncpy(msg, str, length);
	}		
	if(padding)
		for(i=strlen(msg); i<length; i++)
			strncat(msg, " ", length);
	
	FRET(msg);
}


//converts a list of int* in a string
char *list_of_children_to_str(List* ll, char *msg, int length, Boolean padding){
	FIN(list_of_chiildren_to_str(List* ll, char *msg, int length, Boolean padding));
	
	int				i;
	child_struct	*child_ptr;
	char			str[100];

	
	strncpy(msg, "", length);
	for(i=0 ; i < op_prg_list_size(ll) ; i++){
		child_ptr = op_prg_list_access(ll , i);
		snprintf(str, 100, "%s %d (%d) ", msg, child_ptr->address, child_ptr->branch_id);
		strncpy(msg, str, length);
	}
	
	//adds "space" chars
	if(padding)
		for(i=strlen(msg); i<length; i++)
			strncat(msg, " ", length);

	FRET(msg);
}


//Prints in my debug_file the neighborhood table
void print_neighborhood_table(int debug_type){
	FIN(print_neighborhood_table(int debug_type));
	
	int				i;
	neigh_struct	*neigh_ptr;
	char			savings_str[13];
	char			cmac_children_str[50];

	
	if (debug_type >= DEBUG_PRINTF){
		printf("---------------------------------------\n");
		printf("	NEIGHBORHOOD TABLE (%d-%f)\n", my_address, op_sim_time());
		printf("---------------------------------------\n");
		printf("\n");
		printf("%d> addr(bidir)|sinkDist|ktDist| Timeout |Parent|Stab|STreeSize|  Savings  |Cmac Children\n", my_address);
	}
	else{
		debug_print(LOW , debug_type , "---------------------------------------\n");
		debug_print(LOW , debug_type , "	NEIGHBORHOOD TABLE (%f)\n", op_sim_time());
		debug_print(LOW , debug_type , "---------------------------------------\n");
		debug_print(LOW , debug_type , "\n");
		debug_print(LOW , debug_type , "addr(bidir)|sinkDist|ktDist| Timeout |Parent|Stab|STreeSize|  Savings  |Cmac Children\n");
	}
	
	for (i=0 ; i< op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//the whole info
		if (debug_type >= DEBUG_PRINTF)
			printf("%d> %5d (%1d)  |%8d|%6d|%7f|%6d|%4.2f|%7d  |%s|%s\n", my_address, neigh_ptr->address , neigh_ptr->bidirect, convert_int(neigh_ptr->sink_dist) , convert_int(neigh_ptr->ktree_dist) , neigh_ptr->timeout , neigh_ptr->parent, stability_get(neigh_ptr), neigh_ptr->subtree_size, array_of_short_to_str(neigh_ptr->savings, NB_BRANCHES, savings_str, 11, OPC_TRUE), list_of_children_to_str(neigh_ptr->cmac_children, cmac_children_str, 50, OPC_FALSE));
		else
			debug_print(LOW , debug_type , "%5d (%1d)  |%8d|%6d|%7f|%6d|%4.2f|%7d  |%s|%s\n", neigh_ptr->address , neigh_ptr->bidirect, convert_int(neigh_ptr->sink_dist) , convert_int(neigh_ptr->ktree_dist) , neigh_ptr->timeout , neigh_ptr->parent, stability_get(neigh_ptr), neigh_ptr->subtree_size, array_of_short_to_str(neigh_ptr->savings, NB_BRANCHES, savings_str, 11, OPC_TRUE), list_of_children_to_str(neigh_ptr->cmac_children, cmac_children_str, 50, OPC_FALSE));
	}
	if (debug_type >= DEBUG_PRINTF)
		printf("%d> sinkDist=%d, ktDist=%d, parent=%d, STreeSize=%d, isBN=%d, syncPw=%f, cmacChildren=%s\n", my_address, my_sink_tree.sink_dist , my_sink_tree.ktree_dist, my_sink_tree.parent, my_sink_tree.subtree_size, my_sink_tree.is_in_ktree, convert_double(my_sync_rx_power), list_of_children_to_str(my_sink_tree.cmac_children, cmac_children_str, 50, OPC_FALSE));
	else
		debug_print(LOW , debug_type , "sinkDist=%d, ktDist=%d, parent=%d, STreeSize=%d, isBN=%d, syncPw=%f, cmacChildren=%s\n", my_sink_tree.sink_dist , my_sink_tree.ktree_dist, my_sink_tree.parent, my_sink_tree.subtree_size, my_sink_tree.is_in_ktree, convert_double(my_sync_rx_power), list_of_children_to_str(my_sink_tree.cmac_children, cmac_children_str, 50, OPC_FALSE));

	
	FOUT;
}

























//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												CONTROL FRAME											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------



//-----------------------------------------------------------
//
//			  	NEXT_FRAME to Send
//
//-----------------------------------------------------------

//from info about the frame, generate the corresponding packet (juste before transmission)
Packet* create_packet(frame_struct frame){
	FIN(create_packet(frame_struct frame));
	
	char	msg[100];
	Packet	*pk;
	Boolean	cancel_transmission = OPC_FALSE;

	switch(frame.type){
		case DATA_MULTICAST_PK_TYPE:
		case DATA_UNICAST_PK_TYPE:
			pk = op_pk_create_fmt("cmac_frame");
			op_pk_nfd_set(pk , FIELD_PK_DATA_PAYLOAD , 	op_pk_copy(frame.payload));
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO , 	frame.power_ratio);
		
			print_unicast_frame_buffer(DEBUG_CONTROL);
		break;
		case HELLO_PK_TYPE:
			pk = op_pk_create_fmt("cmac_hello");
			op_pk_nfd_set(pk , FIELD_PK_HELLO_SINK_DIST , 	my_sink_tree.sink_dist);
			op_pk_nfd_set(pk , FIELD_PK_HELLO_KTREE_DIST,	my_sink_tree.ktree_dist);
			op_pk_nfd_set(pk , FIELD_PK_HELLO_NEXT,			frame.next_hello);
			op_pk_nfd_set(pk , FIELD_PK_HELLO_PARENT,		my_sink_tree.parent);

			//ktree algo info
			if (op_pk_nfd_is_set(pk , 	FIELD_PK_HELLO_SYNC_POWER))
				op_pk_nfd_strip(pk , 	FIELD_PK_HELLO_SYNC_POWER);
			if (op_pk_nfd_is_set(pk , 	FIELD_PK_HELLO_SUBTREE_SIZE))
				op_pk_nfd_strip(pk , 	FIELD_PK_HELLO_SUBTREE_SIZE);
			
			switch (KTREE_ALGO){
				
				case KTREE_ALGO_SYNC:
					op_pk_nfd_set(pk, FIELD_PK_HELLO_SYNC_POWER, my_sync_rx_power);			
				break;
		
				case KTREE_ALGO_MAXTREE:
					op_pk_nfd_set(pk, FIELD_PK_HELLO_SUBTREE_SIZE, my_sink_tree.subtree_size);
					fill_savings_fields(pk);
				break;
				
				case KTREE_ALGO_STATIC:
				break;
				
				default:
					op_sim_end("Unknown ktree algo", "", "", "");
			}	
			fill_cmac_children_fields(pk);
			
			//include my neighborhood table to detect unidirectional links
			fill_neigh_table_fields(pk);
			
		break;
		case RTS_PK_TYPE:
			pk = op_pk_create_fmt("cmac_rts");
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO , 	frame.power_ratio);
		break;
		case CTS_PK_TYPE:
			pk = op_pk_create_fmt("cmac_cts");
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO, 	frame.power_ratio);
		break;
		case CTR_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr");
			op_pk_nfd_set(pk , FIELD_PK_CTR_CHANNEL, 	my_privileged_channel);
			op_pk_nfd_set(pk , FIELD_PK_CTR_TSLOT , 	slot_privileged_duration);
			op_pk_nfd_set(pk , FIELD_PK_CTR_BRANCHID,	ctr_last_branch);
			debug_print(LOW, DEBUG_NODE , "offset sent %f\n", op_sim_time() - frame.time_added);
			op_pk_nfd_set(pk , FIELD_PK_CTR_OFFSET , 	op_sim_time() - frame.time_added);
		
			//the offset is too large, discard this CTR!
			if (op_sim_time() - frame.time_added > slot_privileged_duration){
				debug_print(MEDIUM, DEBUG_CONTROL, "CTR to cancel (too late) - TODO? - nb retries %d\n",frame.nb_retry);
			//	cancel_transmission = OPC_TRUE;
			}
		break;
		case CTR_ACK_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr_ack");
			op_pk_nfd_set(pk , FIELD_PK_CTR_CHANNEL , 	my_privileged_channel);
			op_pk_nfd_set(pk , FIELD_PK_CTR_TSLOT , 	slot_privileged_duration);
		break;
		case CTR_END_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr_end");
		break;
		case ACK_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ack");
		break;
		case SYNC_PK_TYPE:
			pk = op_pk_create_fmt("cmac_sync");
			op_pk_nfd_set(pk , FIELD_PK_SYNC_BRANCH, 	sync_last_branch);
		break;
		default:
			strncpy(msg, "Packet type %d unknown", 100);
			op_sim_end(msg , "Consequently, I cannot generate the corresponding packet" , "" , "");
		break;
	}
	
	
	//Common fields
	op_pk_nfd_set(pk , FIELD_PK_SOURCE, 		frame.source);
	op_pk_nfd_set(pk , FIELD_PK_DESTINATION,	frame.destination);
	op_pk_nfd_set(pk , FIELD_PK_TYPE,			frame.type);
	op_pk_nfd_set(pk , FIELD_PK_ID,				frame.frame_id);
	op_pk_nfd_set(pk , FIELD_PK_ACCEPT,			OPC_TRUE);
	op_pk_nfd_set(pk , FIELD_PK_NAV_DURATION, 	frame.nav_duration);
		
	//the transmission is not anymore valid
	if (cancel_transmission){
		op_pk_destroy(pk);
		pk = OPC_NIL;
	}
	
	//returns the frame !
	FRET(pk);
}


//Deletes the next scheduled frame
void set_next_frame_null(){
	FIN(set_next_frame_null());
	
//	char	msg[100];

	//debug_print(MEDIUM , DEBUG_DATA , "old frame scheduled (destination %d, type %s) canceled / deleted / in_progress\n", next_frame_to_send.destination, pk_type_to_str(next_frame_to_send.type , msg, 100));
	
	next_frame_to_send.type = NO_PK_TYPE;
	
	FOUT;
}


//Replaces the next_frame_to_send
void change_next_frame(frame_struct new_frame){
	FIN(change_next_frame(frame_struct new_frame));
	
//	char	msg1[100];
//	char	msg2[100];

	//debug_print(MEDIUM , DEBUG_DATA , "old frame scheduled (destination %d, type %s) replaced by a new frame (destination %d, type %s)\n", next_frame_to_send.destination, pk_type_to_str(next_frame_to_send.type , msg1, 100) , new_frame.destination , pk_type_to_str(new_frame.type , msg2, 100));
	
	next_frame_to_send = new_frame;
	
	FOUT;
}




//-----------------------------------------------------------
//
//				 FRAME ID MANAGEMENT
//
//-----------------------------------------------------------

//Returns a new unique frame id
int get_new_frame_id(){
	FIN(get_new_frame_id());
	
	global_frame_id = (global_frame_id + 1) % ((int)(pow(2, sizeof(int) * 8) / 2) - 1);
	FRET(global_frame_id);
}






//-----------------------------------------------------------
//
//					REQUEST TO SEND
//
//-----------------------------------------------------------

//Generates a RTS
void generate_rts(int destination , int nav_duration , int data_frame_id , double power_ratio){
	FIN(generate_rts(int destination , int nav_duration , int data_frame_id , double power_ratio));
	
	//Packet to send
	frame_struct		frame;

	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= RTS_PK_TYPE;
	frame.frame_id 				= data_frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration			= nav_duration;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + DURATION_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	
	debug_print(MEDIUM , DEBUG_CONTROL , "RTS for %d (frame_id %d)\n", destination , data_frame_id);
	
	FOUT;
}




//-----------------------------------------------------------
//
//					CLEAR TO SEND
//
//-----------------------------------------------------------

//Generates a CTS
void generate_cts(int destination , int nav_duration, int frame_id , double power_ratio){
	FIN(generate_cts(int destination , int nav_duration, int frame_id , double power_ratio));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= CTS_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration			= nav_duration;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + DURATION_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);

	debug_print(MEDIUM , DEBUG_CONTROL , "CTS for %d, frame id\n",  destination ,  frame_id);
	
	FOUT;
}




//-----------------------------------------------------------
//
//					ACKNOWLEDGEMENT
//
//-----------------------------------------------------------

//Generates an ACK
void generate_ack(int destination, int nav_duration , int frame_id , double power_ratio){
	FIN(generate_ack(int destination, int nav_duration , int frame_id , double power_ratio));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= ACK_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration 			= nav_duration;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	
	//prepares transmission
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "ACK generated by %d at %f\n", my_address , op_sim_time());
	
	FOUT;
}



//-----------------------------------------------------------
//
//					SYNCHRONIZATION
//
//-----------------------------------------------------------


//Generates a SYNC and schedules its transmission (next_frame_to_send)
void generate_sync(){
	FIN(generate_sync());
	
	//Packet to send
	frame_struct		frame;
	//info
	int					frame_id;
	
	//frame id
	frame_id = get_new_frame_id();
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= ADDR_BROADCAST;
	frame.type 					= SYNC_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration			= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE + NB_TIER_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "SYNC generated\n");
	
	FOUT;
}



//-----------------------------------------------------------
//
//					CLEAR TO RECEIVE
//
//-----------------------------------------------------------


//Generates a CTR-END and schedules its transmission (next_frame_to_send)
void generate_ctr_end(){
	FIN(generate_ctr_end());
	
	//Packet to send
	frame_struct		frame;
	//info
	int				frame_id;
	
	//frame id
	frame_id = get_new_frame_id();
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= ADDR_BROADCAST;
	frame.type 					= CTR_END_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration			= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "CTR-END generated\n");
	
	FOUT;
}



//Generates a CTR and schedules its transmission (next_frame_to_send)
void generate_ctr(){
	FIN(generate_ctr());
	
	//Packet to send
	frame_struct	frame;
	//info
	child_struct	*dest_child;
	int				frame_id;
	
	//Main channel
	debug_print(LOW, DEBUG_CONTROL,"The main channel is used for all CTR\n");
	change_tx_rx_phy(CHANNEL_MAIN_ID);
		
	//Destination
	if (is_sink){
		if (++ctr_last_branch >= get_nb_branches())
			ctr_last_branch = 0;
		
		//If several available channels, get one for this branch (round robin when the branch changes)
		if (nb_channels > 1){
			my_privileged_channel = 1 + (ctr_last_branch % (nb_channels - 1));
			debug_print(LOW, DEBUG_CONTROL,"SINK-CTR: branch %d -> channel %d (nb channels %d)\n", ctr_last_branch, my_privileged_channel, nb_channels);
		}
		else
			my_privileged_channel = 0;
		
		
		dest_child = get_cmac_child(ctr_last_branch);	
	}
	else
		dest_child = get_cmac_child(ctr_last_branch);
	
	//No more ktree children
	if (dest_child == NULL){
		debug_print(LOW, DEBUG_CONTROL,"CTR useless: no child\n");
		is_node_privileged = OPC_FALSE;
		FOUT;
	}
	
	//Generates the CTR
	else {
		//Unavailability of the next hop
		//update_nav_time(destination, 2 * (slot_privileged_duration + MAX_CTR_DELAY_FROM_SINK) , CHANNEL_MAIN_ID , 0);
	
		//frame id
		frame_id = get_new_frame_id();
		dest_child->last_polled		= op_sim_time();

		//multichannel -> the destination will have to send a CTR_ACK
		if (nb_channels > 1)
			frame.nav_duration	= compute_ctr_ack_time();
		//single channel -> the CTR is acknowledged pasively by a data packet
		else
			frame.nav_duration	= compute_data_time(MTU_MAX);
	
		//offset -> the time at which the new slot begins (some time can have been saved and can be used by the next hop)
	//	if (is_sink)
			frame.time_added = op_sim_time();
	//	else
	//		frame.time_added = time_start_privileged + slot_privileged_duration - slot_privileged_offset;
		
		//Next frame to send
		frame.source 				= my_address;
		frame.destination 			= dest_child->address;
		frame.type 					= CTR_PK_TYPE;
		frame.frame_id 				= frame_id;
		frame.nb_retry				= 0;
		frame.power_ratio			= 1;
		frame.pk_size				= HEADERS_PK_SIZE;
		frame.time_sent				= 0;
		frame.time_transmission_min	= 0;
		frame.released				= OPC_FALSE;
		frame.payload				= NULL;
		change_next_frame(frame);

		debug_print(LOW , DEBUG_CONTROL , "CTR generated for the child %d (branch %d)\n", dest_child->address, ctr_last_branch);
	}
	FOUT;
}


//Generates a CTR-ACK
void generate_ctr_ack(int destination, int frame_id){
	FIN(generate_ctr_ack(int destination, int frame_id));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= CTR_ACK_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.nav_duration 			= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	
	//prepares transmission
	change_next_frame(frame);
	
	
	debug_print(MEDIUM , DEBUG_CONTROL , "CTR-ACK generated by %d at %f\n", my_address , op_sim_time());
	
	FOUT;
}




//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												RECEPTION												  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------












//-----------------------------------------------------------
//
//				 RECEIVE FROM UPPER
//
//-----------------------------------------------------------

//Prepares a data frame (headers, queue...)
void prepare_data_frame(Packet	*payload , int frame_id , int next_hop , double power_ratio){
	FIN(prepare_data_frame(Packet	*payload , int frame_id , int next_hop , double power_ratio));
	
	//Packet to send
	frame_struct	frame;
	
	if (DEBUG >= MAX)
		print_neighborhood_table(DEBUG_NODE);
	debug_print(MAX , DEBUG_NODE , "DATA frame generated, next hop to the sink is %d\n", next_hop); 
	
	//Fields
	frame.source				= my_address;
	frame.destination			= next_hop;
	frame.frame_id				= frame_id;
	frame.nb_retry				= 0;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= payload;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + op_pk_total_size_get(payload);
	frame.nav_duration			= compute_data_time(frame.pk_size) + compute_ack_time();	
	//NB: this nav duration will be if we need a RTS/CTS or if this is a special case...
	
	
	if (next_hop == ADDR_BROADCAST){
		frame.type	= DATA_MULTICAST_PK_TYPE;
		add_in_multicast_frame_buffer(frame , OPC_LISTPOS_TAIL);
	}
	else{
		frame.type	= DATA_UNICAST_PK_TYPE;
		add_in_unicast_frame_buffer(frame , OPC_LISTPOS_TAIL);
	}
	FOUT;	
}



//receives a packet from the upper layer
void receive_packet_from_up(){
	FIN(receive_packet_from_up());
	
	Packet	*payload;
	int		frame_id;
	int		data_id;
	//Info from the upper layer
	int		next_hop;
	double	power_ratio;
	
	//frame id
	frame_id = get_new_frame_id();
	
	//Packet from upper
	payload = op_pk_get(op_intrpt_strm());
	op_pk_fd_get(payload, FIELD_PAYLOAD_ID, &data_id);
	
	//routing
	next_hop	= get_next_hop();		
	power_ratio	= 1;

	//ready to send !
	if (next_hop != -1)
		prepare_data_frame(payload , frame_id , next_hop , power_ratio);

	debug_print(LOW , DEBUG_DATA , "DATA to send to %d (frameid %d, dataid %d)\n", next_hop , frame_id, data_id);
	
	FOUT;
}





//-----------------------------------------------------------
//
//					TRANSMISSION TIMES
//
//-----------------------------------------------------------




//returns the time for the RTS
double compute_rts_time(){
	FIN(compute_rts_cts_data_ack_time());
	
	//Packet size
	Packet			*pkptr;
	int				pk_size;	
	
	pkptr = op_pk_create_fmt("cmac_rts");
	pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	FRET(PROPAGATION_DELAY + SIFS + PROPAGATION_DELAY + ((double)pk_size) / operational_speed);
}

//returns the time for the CTS
double compute_cts_time(){
	FIN(compute_cts_cts_data_ack_time());
	
	//Packet size
	Packet			*pkptr;
	int				pk_size;	
	
	pkptr = op_pk_create_fmt("cmac_cts");
	pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	FRET(PROPAGATION_DELAY + SIFS + PROPAGATION_DELAY + ((double)pk_size) / operational_speed);
}

//returns the time required for a DATA transmission
double compute_data_time(int data_pk_size){
	FIN(compute_data_time(int data_pk_size));
	
	//Exchange: SIFS / DATA / SIFS / ACK	
	FRET(PROPAGATION_DELAY + SIFS + PROPAGATION_DELAY + ((double)data_pk_size) / operational_speed);
}

//returns the time for an ack
double compute_ack_time(){
	FIN(compute_ack_time());
	
	//Packet size
	Packet			*pkptr;
	int				ack_pk_size;

	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange:  SIFS / ACK	
	FRET(PROPAGATION_DELAY + SIFS + PROPAGATION_DELAY + ((double)ack_pk_size) / operational_speed);
}

//returns the time for an ack
double compute_ctr_ack_time(){
	FIN(compute_ctr_ack_time());
	
	//Packet size
	Packet			*pkptr;
	int				pk_size;

	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ctr_ack");
	pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange:  SIFS / ACK	
	FRET(PROPAGATION_DELAY + SIFS + PROPAGATION_DELAY + (double)(pk_size ) / operational_speed);
}






//-----------------------------------------------------------
//
//			 RECEIVE FROM RADIO
//
//-----------------------------------------------------------




//Receives a frame after an interruption
void receive_packet_from_radio(){
	FIN(receive_packet_from_radio());
	
	//Pk to receive
	Packet			*payload;
	Packet			*frame;
	//is the frame valid
	int				accepted;
	//Pk fields
	int				source, destination;
	int				frame_type;
	int				frame_id;
	int				next_hop;
	double			power_ratio;
	Boolean			bidirect;
	//CTR
	int				channel;
	double			t_slot;
	double			offset;	
	int				branch_id;
	//data frame
	frame_struct	*frame_ptr;
	//hellos
	int				sink_dist , ktree_dist , branch;
	List			*cmac_children_tmp;
	double			sync_power;
	int				parent;
	int				subtree_size;
	short			*savings_tmp;
	//RTS / CTS / DATA / ACK for nav
	int				nav_duration = 0;
	//to detect changes
	Boolean 		prev_is_ktree_node;
	int				prev_nb_children;
	//next hello
	double			next_hello;
	//Control
	char			msg[100];
	

	//Gets the packet
	frame  = op_pk_get(op_intrpt_strm());

	int toto;
	//Some pk fields
	op_pk_nfd_get(frame, FIELD_PK_ACCEPT,		&accepted);
	op_pk_nfd_get(frame, FIELD_PK_SOURCE, 		&source);
	op_pk_nfd_get(frame, FIELD_PK_DESTINATION,	&destination);
	op_pk_nfd_get(frame, FIELD_PK_DESTINATION,	&toto);
	op_pk_nfd_get(frame, FIELD_PK_TYPE, 		&frame_type);
	op_pk_nfd_get(frame, FIELD_PK_ID,			&frame_id);
	op_pk_nfd_get(frame , FIELD_PK_NAV_DURATION,&nav_duration);
	
	//DEBUG
	if (accepted)
		debug_print(MEDIUM , DEBUG_NODE , "received a frame from %d to %d (type %s, id %d, accepted %d, reply_required %d , nav main channel %f)\n", source , destination , pk_type_to_str(frame_type , msg, 100) , frame_id , accepted , is_reply_to_receive , get_nav_main_channel());
	
	//Valid frame ?
	if ((!accepted) && ((my_address == destination) || (destination == ADDR_BROADCAST)) ){
		//printf("Frame -> collision (%f)\n" , op_sim_time());
	}
	
	if (accepted){
		//---------------------------------------------------------------------------
		//						REPLY RECEIVED -> BAD or VALID ?
		//---------------------------------------------------------------------------
		//Verify that if we waited a reply, this frame is a valid reply
		//i.e. it does not come from another node, or it presents a bad type....
		if (is_reply_to_receive)
			switch(last_frame_sent.type)
			{		

			case RTS_PK_TYPE:
				if ((frame_type == CTS_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else 
					is_reply_bad = OPC_TRUE;
			break;
			
			case CTS_PK_TYPE:
				if ((frame_type == DATA_UNICAST_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else 
					is_reply_bad = OPC_TRUE;
			break;
			
			case DATA_UNICAST_PK_TYPE:
				if ((frame_type == ACK_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else 
					is_reply_bad = OPC_TRUE;
			break;
			
			case CTR_PK_TYPE:
				//ANY data frame -> ack since a ktree node is allowed to send a frame only when it becomes privileged
				if (
						(source == last_frame_sent.destination) 
							&&
						((frame_type == DATA_UNICAST_PK_TYPE) || (frame_type == DATA_MULTICAST_PK_TYPE))					
					){
					debug_print(MEDIUM, DEBUG_CONTROL, "This data frame acknowledges the last CTR\n");
					is_reply_received = OPC_TRUE;
				}
				//The CTR is acknowleged but the flow is finished (no data)
				else if ((source == last_frame_sent.destination) &&
							(
								(frame_type == CTR_PK_TYPE) 
									|| (frame_type == CTR_ACK_PK_TYPE) 
									|| (frame_type == CTR_END_PK_TYPE) 
									|| (frame_type == ACK_PK_TYPE && destination == my_address)
							)
						){
				
					debug_print(MAX, DEBUG_CONTROL, "The CTR was acknowledged and the destination has no more data to send\n");
					change_tx_rx_phy(CHANNEL_MAIN_ID);
					is_reply_received = OPC_TRUE;
				}
				else {
					debug_print(LOW, DEBUG_CONTROL, "This reply does not correspond (type %s, src %d = %d, dest %d)\n", pk_type_to_str(frame_type, msg, 20), source, last_frame_sent.destination, destination);
					is_reply_bad = OPC_TRUE;
				}
				//We are no longer privileged
				if (is_reply_received){
					debug_print(MEDIUM, DEBUG_CONTROL, "The CTR was acknowledged -> I am not anymore privileged\n");
					is_node_privileged = OPC_FALSE;
				}
			break;
		
			default:
				is_reply_bad = OPC_TRUE;
			break;
			}

		
		//---------------------------------------------------------------------------
		//						WHAT TO DO AFTER THIS FRAME ?
		//---------------------------------------------------------------------------
		switch(frame_type){
			case DATA_UNICAST_PK_TYPE :
			case DATA_MULTICAST_PK_TYPE :
			
				op_pk_nfd_get(frame, FIELD_PK_POWER_RATIO , &power_ratio);
				
				//If NAV & data reception -> drop the packet (I won't be able to acknowledge it !)
				if ((destination == my_address) || (destination == ADDR_BROADCAST)){
				 	
					//gets the payload
				 	op_pk_nfd_get(frame , FIELD_PK_DATA_PAYLOAD,	&payload);

					
					//Transmission to the upper layer
					if ((!is_frame_id_seen(source, frame_id)) && (is_sink)){
						debug_print(LOW, DEBUG_DATA, "The data frame was received by the sink (id %d)\n", frame_id);
						op_pk_send(op_pk_copy(payload), STREAM_TO_UP);
					}
					
					//Forwarding (max power, since we have no info)
					else if (!is_frame_id_seen(source, frame_id)){
						next_hop = get_next_hop();
						
						if (next_hop != ADDR_BROADCAST){
							int	data_id;
							op_pk_fd_get(payload, FIELD_PAYLOAD_ID, &data_id);							
							debug_print(LOW, DEBUG_DATA, "Data frame to forward (dataid %d)\n", data_id); 
							cmac_interface_add_in_route(data_id, my_address);
							
							prepare_data_frame(payload , frame_id , next_hop , 1);
							print_unicast_frame_buffer(DEBUG_CONTROL);
							is_reply_to_send 	= OPC_TRUE;
						}
					}
										
					//This frame is marked as seen
					add_frame_id_seen(source, frame_id);
					
					//sends an acknowledgement (unicast + n/o nav)
					Boolean rep_possible = is_reply_possible(destination , my_current_channel);
					debug_print(LOW, DEBUG_CONTROL, "destination %d rep possible %d\n", destination, rep_possible);
					if (!rep_possible){
						print_nav_list(DEBUG_CONTROL);
					}
					
					if ((destination != ADDR_BROADCAST) && (rep_possible)){
						generate_ack(source , nav_duration - compute_ack_time(), frame_id , power_ratio);
						is_reply_to_send 	= OPC_TRUE;
						debug_print(LOW, DEBUG_CONTROL, "ack because I just received a data (dest %d)\n", destination);
					}
				}
			
			break;
				
				
			//Deletes the corresponding DATA_PK from the buffer -> it was correctly transmitted
			case ACK_PK_TYPE:
			
				//Registers the ack
				if (destination == my_address){
					del_frame_buffer_with_id(last_frame_sent.frame_id, OPC_TRUE);
			}
				
			
			break;
			
			//We must generate a CTS
			case RTS_PK_TYPE:
			
				//Power ratio
				op_pk_nfd_get(frame, FIELD_PK_POWER_RATIO, 		&power_ratio);
			
				//We received a RTS for us -> we have to send now a CTS to accept the connection
				// -> No other reservation has been done by neighbors
				// -> I am not in communication (I am waiting for a reply for a transmitted frame)
				// -> If we are privileged, our privileged time has not expired
				//
				if ((destination == my_address) && (is_reply_possible(destination , my_current_channel)) && (!is_reply_to_receive) && (!is_node_privileged)){
					generate_cts(source , nav_duration - compute_cts_time() , frame_id , power_ratio);
					is_reply_to_send 	= OPC_TRUE;
				}

				//debug
				else if (destination == my_address)
					debug_print(LOW , DEBUG_DATA , "no reply authorized: reply_possible (%d), is rep_required (%d), piviledged %d\n" , is_reply_possible(destination , my_current_channel) , is_reply_to_receive , is_node_privileged);
			
			break;
			
			//We can send the DATA -> place it in the next_frame_to_send
			//The interruption will leave the current state, and we will enter in transmission for the data frame
			case CTS_PK_TYPE:
			
				//We received a CTS for us -> we have to send now the data packet
				//NB: it is unicast because multicast frame are sent in ADDR_BROADCAST, wihtout RTS / CTS
				if ((destination == my_address) && (is_reply_possible(destination , my_current_channel)) && (!is_frame_buffer_empty())){
					frame_ptr = get_unicast_frame_buffer(0);
					if (frame_ptr != NULL)
						change_next_frame(*frame_ptr);
					is_reply_to_send 	= OPC_TRUE;
				}

				//A particular case : we received a CTS and meanwhile, the data packet we wanted to send was timeouted and deleted
				else if ((destination == my_address) && (is_reply_possible(destination , my_current_channel))){
					
					debug_print(LOW, DEBUG_CONTROL , "ERROR: we received a CTS and we do not have any data frame to transmit\n");
					print_unicast_frame_buffer(DEBUG_CONTROL);
					print_multicast_frame_buffer(DEBUG_CONTROL);
				}
			
			break;
			
			//We become privileged node
			//-> automatically, we will send a DATA_PK (or a CTR if we have none)
			case CTR_PK_TYPE:
				op_pk_nfd_get(frame , FIELD_PK_CTR_CHANNEL, &channel);
				op_pk_nfd_get(frame , FIELD_PK_CTR_TSLOT, 	&t_slot);
				op_pk_nfd_get(frame , FIELD_PK_CTR_OFFSET, 	&offset);
				op_pk_nfd_get(frame , FIELD_PK_CTR_BRANCHID,&branch_id);
				
				//Multichannel -> this ktree node is in privileged mode (it will be unreachable during this timeslot)
				//I flush other entries for this channel since they are surely obsolete (i.e. the previous timeslot has finished)
				if (nb_channels > 1){
					flush_nav_time(channel);	
					update_nav_time(source, t_slot , channel);	
				}
				//	update_nav_time(source, t_slot - offset , channel);	
			
				//Remark: we answer even if a NAV is present -> the CTR should have a larger priority and we should enforce its delivery
				if (destination == my_address){
					
					//the node becomes privileged
					is_node_privileged 			= OPC_TRUE;
					time_start_privileged		= op_sim_time();
					slot_privileged_duration	= t_slot;
					slot_privileged_offset		= offset;
					my_privileged_channel	 	= channel;
					ctr_last_branch				= branch_id;
					
					//Error
					if (!my_sink_tree.is_in_ktree){
						if (!neighborhood_table_cmac_children_replace_for_node(source, branch_id, my_address))
							debug_print(LOW, DEBUG_CONTROL, "ERROR: we cannot update the list of children for the source of CTR\n");
						update_is_in_ktree_and_dist();
					}
					
					//Bad CTR -> gratuitous hello to solve inconsistencies
					if (!my_sink_tree.is_in_ktree){
						print_neighborhood_table(DEBUG_CONTROL);
						debug_print(LOW, DEBUG_CONTROL, "Error: I received a CTR although I am not in the k-tree. I immediately discard this CTR and send one hello\n");
						generate_hello(0);
						
						//exit -> I discard this CTR
						break;									
					}
					
					//Schedules the end of the privileged mode
					if (slot_privileged_duration > offset){
						op_intrpt_schedule_self(op_sim_time() + (slot_privileged_duration - slot_privileged_offset) * PRIVILEGED_MIN_TIME_RATIO , 	PRIVILEGED_MIN_CODE);
						op_intrpt_schedule_self(op_sim_time() + (slot_privileged_duration - slot_privileged_offset), 								PRIVILEGED_MAX_CODE);
					}
					else{
						op_intrpt_schedule_self(op_sim_time() , PRIVILEGED_MAX_CODE);
						debug_print(LOW, DEBUG_CONTROL, "The CTR is late, we have to forward it immediately\n");
					}
					debug_print(LOW, DEBUG_CONTROL, "I become privileged for the duration: %f (offset %f) -> min %f max %f\n",  slot_privileged_duration , slot_privileged_offset  , (slot_privileged_duration - offset) * PRIVILEGED_MIN_TIME_RATIO , (slot_privileged_duration - offset) );
					
					
					//Multi channel case (CTR_ACK -> in F1+F2 if no data)
					if (nb_channels > 1){
						generate_ctr_ack(source, frame_id);
						is_reply_to_send 	= OPC_TRUE;
					}					
					//No data frame -> ack to send (max power)
					//No ack if I have already finished my slot -> I will send a CTR which will act as a CTR-ACK
					else if ((is_frame_buffer_empty()) && ((slot_privileged_duration - slot_privileged_offset > 0) || (get_cmac_child(ctr_last_branch) == NULL))){
						generate_ack(source , 0, frame_id , 1);
						is_reply_to_send 	= OPC_TRUE;
						debug_print(LOW, DEBUG_CONTROL, "ack for a CTR I just received since I have no data frame to ack passively the CTR\n");
					}
					else if (!is_frame_buffer_empty())
						debug_print(MEDIUM, DEBUG_CONTROL, "I will send a data frame to acknowledge passively this CTR\n");
					
				}
				
			break;
		   	
			case CTR_ACK_PK_TYPE:
				//A node which sends a CTR-ACK will become unavailable during t_slot (and then will send a CTR through the main channel)
				op_pk_nfd_get(frame , FIELD_PK_CTR_CHANNEL, &channel);
				op_pk_nfd_get(frame , FIELD_PK_CTR_TSLOT, 	&t_slot);				
				
				//Multichannel -> this ktree node is in privileged mode (using another channel)
				//Thus, it will be unreachable during this timeslot
				//R: if it comes back before, he will send a CTR which will update automatically its NAV
				if (nb_channels > 1)
					update_nav_time(source, t_slot , channel);	

			break;
			
			
			//Channel switching for the destination
			case CTR_END_PK_TYPE:	
			
				if ((nb_channels > 1) && (destination == my_address)){
					debug_print(MEDIUM, DEBUG_CONTROL, "CTR-END received -> we can come back to the main channel\n");
					change_tx_rx_phy(CHANNEL_MAIN_ID);
				}
			
			break;
			
			
			//Updates the neighborhood table
			case HELLO_PK_TYPE:
				op_pk_nfd_get(frame , FIELD_PK_HELLO_NEXT, 	&next_hello);
			
				if (destination != ADDR_BROADCAST){
					op_pk_print(frame);
					printf("Addr %d incorrect / %d\n", destination, toto);
					op_sim_end("An hello is sent in unicast" , "not in ADDR_BROADCAST", "please correct the bug", "");
				}
				op_pk_nfd_get(frame , FIELD_PK_HELLO_SINK_DIST, 	&sink_dist);
				op_pk_nfd_get(frame , FIELD_PK_HELLO_KTREE_DIST, 	&ktree_dist);
				op_pk_nfd_get(frame , FIELD_PK_HELLO_SYNC_POWER, 	&sync_power);
				op_pk_nfd_get(frame , FIELD_PK_HELLO_PARENT, 		&parent);
				cmac_children_tmp = create_my_cmac_children_from_packet(frame);
							
				//k-tree construction
				if (op_pk_nfd_is_set(frame , FIELD_PK_HELLO_SUBTREE_SIZE)){
					op_pk_nfd_get(frame , FIELD_PK_HELLO_SUBTREE_SIZE, 	&subtree_size);
				}
				else
					subtree_size = -1;
				
				if (op_pk_nfd_is_set(frame , FIELD_PK_HELLO_SAVINGS))
					savings_tmp = create_savings_from_packet(frame);
				else
					savings_tmp = create_null_savings();
				
				//detection of unidirectional links
				bidirect = is_bidirect_from_packet(frame);
				
				//previous ktree values
				prev_is_ktree_node 	= my_sink_tree.is_in_ktree;
				prev_nb_children 	= op_prg_list_size(my_sink_tree.cmac_children);
				
				//changes the values in the neighborhood table
				update_neighborhood_table(source , bidirect, sink_dist , ktree_dist , sync_power , parent, subtree_size, savings_tmp, branch , cmac_children_tmp , next_hello);
			
				//a changed occured eventually in the ktree
				if (source == my_sink_tree.parent){
					update_current_cmac_children();
					update_is_in_ktree_and_dist();
				}
				
				//triggers immediately one hello (changes are important)
				if ((prev_is_ktree_node != my_sink_tree.is_in_ktree) || (op_prg_list_size(my_sink_tree.cmac_children) != prev_nb_children)){
					printf("special hello %d %f (%d, %d)\n", my_address, op_sim_time(), (prev_is_ktree_node != my_sink_tree.is_in_ktree), (op_prg_list_size(my_sink_tree.cmac_children) != prev_nb_children)); 
					generate_hello(0);
					is_reply_to_send = OPC_TRUE;
				}	
			break;
				
			//Reception of a sync frame from the sink 
			//in order to select ktree nodes
			case SYNC_PK_TYPE:			
				op_pk_nfd_get(frame , FIELD_PK_SYNC_BRANCH, 	&my_branch);
			
				my_sync_rx_power = last_rx_power * 1E14;
				debug_print(LOW , DEBUG_NODE , "%d -> SYNC Level reception : %f , branch %d\n", my_address , my_sync_rx_power , my_branch);
				
			break;
				
			default:
				snprintf(msg , 100, "TYPE %d" , frame_type);
				op_sim_end("Unknown received packet" , msg , "" , "");
			break;
		}
	}
	
	//NAV time
	if (destination != my_address)
		update_nav_time(source, nav_duration , my_current_channel);

	//This packet became useless -> destroy it !
	op_pk_destroy(frame);
	
	FOUT;
}



















//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												INTERRUPTIONS											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------















//-----------------------------------------------------------
//
//			  INTERRUPTIONS
//
//-----------------------------------------------------------



//handle all interruptions when It does not depend on the state machine
void interrupt_process(){
	FIN(interrupt_process());
	
	//control
	char		msg[200];
	char		str[10];
	int			nb_nodes = get_nb_nodes();
	int			i;
	//debug
	Boolean		old;
	//reception power 
	double		new_rx_power;
	//next hello to generate
	double		next_hello;
	//connectivity matrix
	Boolean		*connectivity;
	
	if (DEBUG_STATE_MACHINE)
		debug_print(MAX , DEBUG_GLOBAL, "type %d (self %d, stat %d , pk %d)\n", op_intrpt_type() , OPC_INTRPT_SELF , OPC_INTRPT_STAT , OPC_INTRPT_STRM);

	//verify that the graph is connected just before sending data packets
	if ((!connectivity_verification) && (op_sim_time() > TIME_START_DATA)){
		connectivity_verification = OPC_TRUE;
		tools_fig_generate();
		
		//initialization of the connectivity matrix
		connectivity = op_prg_mem_alloc(sizeof(Boolean) * nb_nodes);
		for(i=1; i<nb_nodes; i++)
			connectivity[i] = OPC_FALSE;
	
		//verify the connectivity
		if (!cmac_tools_graph_is_connected(connectivity)){
			strcpy(msg, "");
			for(i=1; i<nb_nodes; i++)
				if (!connectivity[i]){
					snprintf(str, 10, "%d ", nodeid_to_addr(i));
					strncat(msg, str, 200);
				}			
			op_sim_end("The graph is not connected", "I stop here the simulation process", "Disconnected nodes:", msg);
		}
		
		op_prg_mem_free(connectivity);
	}	
	
	switch (op_intrpt_type()){
	
		//A PACKET WAS RECEIVED !
		case OPC_INTRPT_STRM :
			switch (op_intrpt_strm()){
				case STREAM_FROM_RADIO :
					receive_packet_from_radio();
				break;
				
				case STREAM_FROM_UP:
					receive_packet_from_up();
				break;
				
				default:
					op_sim_end("An unregistered stream sent you a packet" , "" , "" , "");
				break;
			}	
		break;
		
		case OPC_INTRPT_REMOTE:
		
			// One of receiver channels is changing its status. Update the channel status flag (with power = 0)
			if (op_intrpt_code() - CHANNEL_RELEASED_CODE == my_current_channel){
				is_rx_busy = OPC_FALSE;
				debug_print(MAX, DEBUG_RADIO, "I have been notified that the channel is now free\n");
			}

		break;

		
		//Change in the medium state
		case OPC_INTRPT_STAT :
			
			switch(op_intrpt_stat()){
				
				//signal from radio receiver (and registers the power of the last received packet)
				case STAT_FROM_RX :
					new_rx_power = op_stat_local_read(op_intrpt_stat()); 
					old = 	is_rx_busy;

					if (new_rx_power > rx_power_threshold){
						is_rx_busy 		= OPC_TRUE;
						last_rx_power 	= new_rx_power;
						//debug_print(MAX, DEBUG_RADIO , "last_rx_power %f -> %f\n", last_rx_power , new_rx_power);
					}
					else
						is_rx_busy 		= OPC_FALSE;
				
					//debug_print(MEDIUM , DEBUG_RADIO , "rx_busy %d -> %d (rx pow %f)\n", old , is_rx_busy , new_rx_power * 1E14);
				break;
				
				//2 transmitters but considered logicaly as one single transmitter with a different antenna
				case STAT_FROM_TX_DIREC_SYNC:
				case STAT_FROM_TX :
					old = is_tx_busy ;				
				
					is_tx_busy = (op_stat_local_read(op_intrpt_stat()) == 1.0);
				
					//debug_print(MEDIUM , DEBUG_RADIO , "tx_busy %d -> %d\n", old , is_tx_busy);
				break;
				
				default :
					snprintf(msg, 100, "We are not configured to handle the stat from the line %d\n", op_intrpt_stat());
					op_sim_end(msg, "" , "" , "");
				break;
			}
		break;
		
		//SELF INTERRUPTS
		case OPC_INTRPT_SELF:
		
			//CTR from the sink
			if (op_intrpt_code() == SINK_CTR_CODE){
				generate_ctr();
				
				//The next CTR from the sink (if several channels, the period of CTR should be reduced)
				//the first channel is only used for common control channel (data for non-privileged nodes + CTR)
				if (nb_channels > 1)
					op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration * CTR_HOP_SPACING /  (nb_channels - 1), 	SINK_CTR_CODE);
				//one single channel is used for boththe data and the privileged transmissions
				else
					op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration * CTR_HOP_SPACING, 						SINK_CTR_CODE);
			}

			//SYNC from the sink
			if (op_intrpt_code() == SINK_SYNC_CODE)
				generate_sync();

		
			//HELLO
			if (op_intrpt_code() == HELLO_PK_CODE){
				
				//The next HELLO
				if (op_sim_time() > TIME_BEFORE_HELLO_CONVERGENCE)
					next_hello = HELLO_PK_PERIOD - op_dist_uniform(HELLO_PK_PERIOD / 10);
				else
					next_hello = HELLO_PK_PERIOD_BEFORE_CONVERGENCE - op_dist_uniform(HELLO_PK_PERIOD_BEFORE_CONVERGENCE / 10);
					
				//prepares the packet
				generate_hello(next_hello);
				
				//schedules the next interruption
				op_intrpt_schedule_self(op_sim_time() + next_hello , HELLO_PK_CODE);
			}
			
			
			//privileged END !
			//min code -> we should have no data frame to send before ending the privileged mode
			if (((op_intrpt_code() == PRIVILEGED_MIN_CODE) && (is_frame_buffer_empty())) || (op_intrpt_code() == PRIVILEGED_MAX_CODE)){
			
				//I must end my slot only if I am still privileged!
				if (is_node_privileged){
					
					//no more data to send
					if ((!is_main_channel_active()) && (op_intrpt_code() == PRIVILEGED_MIN_CODE) && (last_frame_sent.type != CTR_PK_TYPE || !is_reply_to_receive) && (next_frame_to_send.type != CTR_PK_TYPE)){
						debug_print(LOW, DEBUG_CONTROL, "Generates a CTR-END since we have no more data\n");
						generate_ctr_end();
					}
					//The node is not anymore privileged (not anymore data or the end of the maximum slot duration)
					else if ((last_frame_sent.type != CTR_PK_TYPE || !is_reply_to_receive) && (next_frame_to_send.type != CTR_PK_TYPE)){
						debug_print(LOW, DEBUG_CONTROL, "We have to forward the CTR now (ctr scheduled %d, is_priv %d, buffer_size %d)\n", next_frame_to_send.type == CTR_PK_TYPE, (is_node_privileged) , get_frame_buffer_size());
						generate_ctr();
					}
					//NB: the CTR will eventually replace the CTR-END => does not matter since the slot is finished
				}
			}
			
			//Returns to the main channel
			if (op_intrpt_code() == MAIN_CHANNEL_RETURN_CODE){
				debug_print(MEDIUM, DEBUG_CONTROL, "I have to switch back to my main channel\n");
				change_tx_rx_phy(CHANNEL_MAIN_ID);
			}
		
			
			
		break;
		
		//Stats, debug ...
		case OPC_INTRPT_ENDSIM :
			//direct function
			end_sim();
		break;
	
		
		//no default -> some interruptions can be managed directly by a particular state
		default:
		break;
	}
	FOUT;
}



//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												STATISTICS												  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------





//-----------------------------------------------------------
//
//			   ROUTES MANAGEMENT
//
//-----------------------------------------------------------


//Prints the content of a route (route_length, source, ..., destination)
void mac_print_route(List* route_tmp){
	FIN(mac_print_route(List* route_tmp));
	
	int		i;
	int		*int_ptr;

	printf("ROUTE : ");
	for(i=0 ; i < op_prg_list_size(route_tmp) ; i++){
		int_ptr = op_prg_list_access(route_tmp, i);
	
		printf(" %d" , *int_ptr);
		}
	printf("\n");

	FOUT;
}


//returns the route length
short get_route_length(List* route_tmp){
	FIN(get_route_length(List* route_tmp));
	
	int		*int_ptr;
	
	//route length -> firt elem
	int_ptr = op_prg_list_access(route_tmp , 0);
	FRET(*int_ptr);
}


//Returns the average route length
double get_average_route_length(List *route_list){
	FIN(get_average_route_length(List *route_list));
	
	//final values
	int		value = 0;
	int		nb_routes = 0;
	//Elems
	int		*int_ptr;
	List	*route_tmp;
	//control
	int		i;
	
	
	for(i=0 ; i < op_prg_list_size(route_list) ; i++){
	
		//Gets the it^h route
		route_tmp = op_prg_list_access(route_list , i);
		
		//Its length
		int_ptr = op_prg_list_access(route_tmp , 0);
		
		//Update values
		value +=  *int_ptr;
		if (*int_ptr != 0)
			nb_routes++;
	}
	
	FRET(value / nb_routes);
}


//is addr in the route ?
Boolean is_in_route(List* route_tmp , int addr){
	FIN(is_in_route(List* route_tmp , int addr));
	
	int		i;
	int		*int_ptr;
	
	//NB : the first element is the route length
	for(i=1 ; i < op_prg_list_size(route_tmp) ; i++){
		int_ptr = op_prg_list_access (route_tmp , i);
		if (*int_ptr == addr)
			FRET(OPC_TRUE);
	}
	FRET(OPC_FALSE);
}

//returns the ratio of routes which pass through addr
double get_ratio_of_traffic(List* route_list , int addr){
	FIN(get_ratio_of_traffic(List* route_list , int addr));
	
	//final values
	int		value = 0;
	int		nb_routes = 0;
	//Elems
	int		*int_ptr;
	List	*route_tmp;
	//control
	int		i;
	
	
	for(i=0 ; i < op_prg_list_size(route_list) ; i++){
	
		//Gets the it^h route
		route_tmp = op_prg_list_access(route_list , i);
		
		//Its length
		if (is_in_route(route_tmp , addr))
			value ++;

		//Number of routes
		int_ptr = op_prg_list_access(route_tmp , 0);
		if (*int_ptr != 0)
			nb_routes++;
	}
	
	FRET( (double)value / (double)nb_routes);
}











//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												DEBUG													  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------







//-----------------------------------------------------------
//
//			   			TOOLS
//
//-----------------------------------------------------------



//infinity conversion for debug messages
double convert_double(double value){
	FIN(convert_double(double value));
	
	if (value == OPC_DBL_INFINITY)
		FRET(-1);
	FRET(value);
}

//infinity conversion for debug messages
int convert_int(int value){
	FIN(convert_int(int value));
	
	if (value == OPC_INT_INFINITY)
		FRET(-1);
	FRET(value);
}



//-----------------------------------------------------------
//
//			   DEBUG FUNCTIONS
//
//-----------------------------------------------------------

//Converts a pk_type in string
char* pk_type_to_str(short pk_type , char *msg, int length){
	FIN(pk_type_to_str(short pk_type , char *msg, int length));

	switch(pk_type){
		case RTS_PK_TYPE:
			strncpy(msg, "RTS", length);
		break;
		case CTS_PK_TYPE:
			strncpy(msg, "CTS", length);
		break;
		case CTR_PK_TYPE:
			strncpy(msg, "CTR", length);
		break;
		case CTR_ACK_PK_TYPE:
			strncpy(msg, "CTR-ACK", length);
		break;
		case CTR_END_PK_TYPE:
			strncpy(msg, "CTR-END", length);
		break;
		case ACK_PK_TYPE:
			strncpy(msg, "ACK", length);
		break;
		case DATA_UNICAST_PK_TYPE:
			strncpy(msg, "DATA-UNI", length);
		break;
		case DATA_MULTICAST_PK_TYPE:
			strncpy(msg, "DATA-MULTI", length);
		break;
		case HELLO_PK_TYPE:
			strncpy(msg, "HELLO", length);
		break;
		case SYNC_PK_TYPE:
			strncpy(msg, "SYNC", length);
		break;
		default:
			snprintf(msg, length, "%d unknown", pk_type);
		break;
	}

	FRET(msg);
}


// Print all debug messages classified in different files
void debug_print(const int level, const int type , const char* fmt, ...){	
	FIN(debug_print(const int level, const int type , const char* fmt, ...));
	
	FILE		*pfile;
	va_list 	argptr;
	double		time = op_sim_time();
	
	//not the good level -> discard
	if (level > DEBUG)
		FOUT;
	
	//Special case: we call debug_print after having closed the debug file (this is the simulation end)
	if (op_intrpt_type() == OPC_INTRPT_ENDSIM)
		FOUT;
	
	//error
	if ((type <0) || (type > DEBUG_NODE))
		op_sim_end("Error, you specify an unkwnown type for debug_print()", "", "", "");
	
	//Prepares the args
	va_start(argptr, fmt);	
	
	//Particular case of my_debug_file (ths file is not shared with other nodes)
	if (type != DEBUG_NODE)
		pfile = debug_files[type];
	else
		pfile = my_debug_file;	
	
	//Normal debug
	if (type != DEBUG_GLOBAL){
		fprintf(pfile , "[%4ds, "	, (int) floor(time));
		fprintf(pfile , "%4dms, "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
		fprintf(pfile , "%4dus, "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
		fprintf(pfile , "%1.1ich, "	, my_current_channel);	
		fprintf(pfile , "%4.1i] "	, my_address);	
		vfprintf(pfile , fmt, argptr);     
	}		
		
	//print on the console some particular debug messages 
	if (OPC_FALSE){
		printf("[%4ds , "	, (int) floor(time));
		printf("%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
		printf("%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
		printf("%1.1ich, "	, my_current_channel);	
		printf("%4.1i] "	, my_address);	
		vprintf(fmt, argptr);   
	}
		
	//print some particular message per node
	if (OPC_FALSE){
		fprintf(my_debug_file , "[%4ds , "	, (int) floor(time));
		fprintf(my_debug_file , "%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
		fprintf(my_debug_file , "%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
		fprintf(my_debug_file , "%1.1ich, "	, my_current_channel);	
		fprintf(my_debug_file , "%4.1i] "	, my_address);	
		vfprintf(my_debug_file , fmt, argptr);     
	}
		
	//put all debugs in a gobal file (useful sometimes to see all the events)
	if (OPC_TRUE){
		fprintf(debug_files[DEBUG_GLOBAL] , "[%4ds , "	, (int) floor(time));
		fprintf(debug_files[DEBUG_GLOBAL] , "%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
		fprintf(debug_files[DEBUG_GLOBAL] , "%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
		fprintf(debug_files[DEBUG_GLOBAL] , "%1.1ich, "	, my_current_channel);	
		fprintf(debug_files[DEBUG_GLOBAL] , "%4.1i] "	, my_address);	
		vfprintf(debug_files[DEBUG_GLOBAL] , fmt, argptr);     
	}
	
	//fush the printed messages (for all opened file pointers)
	fflush(NULL);
	
	va_end(argptr);
	FOUT;
}	



//opens a debug file
void open_debug_file(FILE **fout , const char* fmt, ...){	
	FIN(open_debug_file(FILE **fout , const char* fmt, ...));
	
	char	filename[100];
	char	msg[100];	
	va_list argptr;
	
	//The file was already opened -> nothing to do
	if (*fout != NULL)
		FOUT;
	
	//Args
	va_start(argptr, fmt);
	
	//gets the filename
	strncpy(filename, "", 100);
	vsnprintf(filename , 100, fmt, argptr);     
	
	//And open it !
	*fout = fopen(filename, "w");
	if (*fout == NULL){
		snprintf(msg, 100, "%s -> %s", filename , strerror(errno));
		op_sim_end("I cannot open the debug file", msg , "" , "");	
	}	
	
	va_end(argptr);
	FOUT;
}












//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												END SIMULATION											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------






//end simulation (debug + eventual stats)
void end_sim(){
	FIN(end_sim());	
	int		i;
	
	if (DEBUG > NO){
		
		//Debug message
		print_neighborhood_table(DEBUG_HELLO);
		print_frame_buffer(DEBUG_NODE);

		//write a xfig file
		if (my_stat_id == 0)
			tools_fig_generate();
		
		//Close common debug files !
		if (my_stat_id == 0)
			for (i=0 ; i < 20 ; i++)
				if (debug_files[i] != NULL)
					fclose(debug_files[i]);

		//and the debug file reserved for this particular node
		if (my_debug_file != NULL)
			fclose(my_debug_file);
		
	}
	FOUT;
}













]]>
	</function-block>
	<termination-block>
<![CDATA[

]]>
	</termination-block>
	<states initial-state-id="40">
		<state id="40" x="90" y="90">
			<attribute name="name" type="string" value="INIT"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Ids
Objid	mac_params_comp_attr_objid;
Objid	params_attr_objid;
//Parameters
Objid	chann_params_comp_attr_objid;
Objid	subchann_params_attr_objid;
//transmitters
int		nb_radio;
//Channels
int		num_chann;
Objid	chann_objid;
Objid	monitor_id;
Objid	strm_id;
Objid	sub_chann_objid;
Objid	tx_id , rx_id;
double	bandwidth, frequency;
//Control
int		i , j;
char	str[300];
//char	msg[500];
//Statwires
Objid	statwire_objid;
int		num_statwires;
double	threshold;
//for debug files
char	dirname[200];
DIR		*pdir;
char 	log_dir_tmp[FILENAME_LOG_MAX];
//Id
//int		intf_id;

Objid 	rxch_objid, txch_objid;
Objid	tx_objid, rx_objid;
Objid	my_objid = op_id_self();
double	tx_power;
void	*temp_ptr;

op_ima_obj_attr_get(op_id_self() ,  "Transmission Power",	&tx_power);

	/* Obtaining transmitter objid for accessing channel data rate attribute.	*/
	tx_objid = op_topo_assoc (my_objid, OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX, 0);

	/* If no receiver is attach then generate error message and abort the simulation.	*/
	if (tx_objid == OPC_OBJID_INVALID)
		{
		wlan_error_print ("No transmitter attached to this MAC process", OPC_NIL, OPC_NIL);	
		}

	/* Obtaining number of channels available.									*/
	op_ima_obj_attr_get (tx_objid, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RATXCH);
	
	/* Check for error conditions. The transmitter is expected to have a single	*/
	/* channel.																	*/
	if (num_chann > 1)
		wlan_error_print ("The transmitter of the surrounding node has too many channels. This MAC",
						  "is implemented to use a single channel for all supported data rates.",
						  "Possibly, the new MAC process model is deployed in an old node model.");
	else if (num_chann == 0)
		wlan_error_print ("No channel is available for transmission.", OPC_NIL, OPC_NIL);
		
	/* Set the transmitter's transmission power.								*/	
	txch_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_set (txch_objid, "power", tx_power);

	/* Free the transmitter channel state information set at the rxgroup		*/
	/* pipeline stage.															*/
	temp_ptr = (void *) op_ima_obj_state_get (txch_objid);
	op_prg_mem_free (temp_ptr);	
	
	/* Reset the channel state. */
	op_ima_obj_state_set (txch_objid, OPC_NIL);

	/* Obtaining receiver's objid for accessing channel data rate attribute.	*/
	rx_objid = op_topo_assoc (my_objid, OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX, 0);

	/* If no receiver is attach then generate error message and abort the		*/
	/* simulation.																*/
	if (rx_objid == OPC_OBJID_INVALID)
		{
		wlan_error_print ("No receiver attached to this MAC process", OPC_NIL, OPC_NIL);	
		}

	/* Disable the apptracking capability for the receiver						*/
//	apptrack_rx_processing_disable (rx_objid);
	
	/* Obtaining number of channels available.									*/
	op_ima_obj_attr_get (rx_objid, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RARXCH);
	
	/* Check for error conditions. The receiver is expected to have a single	*/
	/* channel.																	*/
	if (num_chann > 1)
		wlan_error_print ("The receiver of the surrounding node has too many channels. This MAC",
						  "is implemented to use a single channel for all supported data rates.",
						  "Possibly, the new MAC process model is deployed in an old node model.");
	else if (num_chann == 0)
		wlan_error_print ("No channel is available for reception.", OPC_NIL, OPC_NIL);

	/* Free the receiver channel state information set at the rxgroup stage.	*/
	rxch_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RARXCH, 0);
	temp_ptr = (void *) op_ima_obj_state_get (rxch_objid);
	op_prg_mem_free (temp_ptr);
	
	/* Reset the channel state. */
	op_ima_obj_state_set (rxch_objid, OPC_NIL);

	
	
	


//-----------------------------------------------
//		   		IDENTIFICATION
//-----------------------------------------------


//Process IDS 	
my_stat_id		= nb_mac_nodes++;


if (cmac_timestamp == 0)
	cmac_timestamp = time(NULL);

//Address
op_ima_obj_attr_get(op_topo_parent(op_id_self()) , "name" , str);
my_address = atoi(str);
op_ima_obj_attr_set (op_id_self(), "Address", my_address);
//errors
if (my_address == ADDR_BROADCAST){
	snprintf(str, 300,"the address %d", ADDR_BROADCAST);
	op_sim_end("A node cannot have", str, "it is dedicated to", "broadcast");
}
if (my_address == ADDR_INVALID){
	snprintf(str, 300, "the address %d", ADDR_INVALID);
	op_sim_end("A node cannot have", str, "it is dedicated to", "unknown addresses");
}
			   
//-----------------------------------------------
//		  		 CHANNEL MONITOR
//-----------------------------------------------

my_current_channel_for_monitor = -1;

//memory sharing with the channel monitoring process
strm_id = op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STRM , MONITOR_OUTPUT_STREAM);
monitor_id = op_topo_assoc(strm_id , OPC_TOPO_ASSOC_IN , OPC_OBJTYPE_PROC , 0);
op_ima_obj_state_set(monitor_id , &my_current_channel_for_monitor);

//channel_busy_after_switch	= OPC_TRUE;

	
//-----------------------------------------------
//		  		 PARAMETERS
//-----------------------------------------------

//Parameters
op_ima_sim_attr_get(OPC_IMA_INTEGER , "debug_level",			&DEBUG);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "CTR_hop_spacing",		&CTR_HOP_SPACING);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "RTS",					&RTS_PK_SIZE);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "mac_layer",				&MAC_LAYER);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "ktree_algo",				&KTREE_ALGO);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "nb_branches",			&NB_BRANCHES);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "sink_address",			&sink_address);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "exponential_backoff",	&EXPONENTIAL_BACKOFF);

if (nb_channels == 0)
	op_ima_sim_attr_get(OPC_IMA_INTEGER , "nb_channels",		&nb_channels);

//log directory name
if (op_ima_sim_attr_exists("Result_Directory")){
	op_ima_sim_attr_get_str("Result_Directory", 	FILENAME_LOG_MAX, log_dir_tmp);
	set_log_dir(log_dir_tmp);
}
	
//No RTS / CTS -> pk_size set to the infinity value
if (RTS_PK_SIZE == -1)
	RTS_PK_SIZE = OPC_INT_INFINITY;
op_ima_obj_attr_get(op_id_self() ,  "Transmission Power",	&POWER_TX);


//A ktree node is allowed to send packets only when it is privileged
strict_privileged_mode = (MAC_LAYER == CMAC);

//error
if (CTR_HOP_SPACING == 0)
	op_sim_end("You must have CTR_HOP_SPACING > 0", "", "", "");


//-----------------------------------------------
//		   			ROUTING
//-----------------------------------------------


//-----------  IS_KTREE_NODE  --------------

my_sink_tree.is_in_ktree 	= OPC_FALSE;
my_sink_tree.subtree_size	= 0;
my_sink_tree.parent			= ADDR_INVALID;
my_sink_tree.cmac_children	= op_prg_list_create();


//--------------  IS_SINK  -----------------

//The upper process is connected to two out-streams -> It has a SINK process
/*intf_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC, 0);
if (op_topo_assoc_count(intf_id , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_STRM) > 1)
	is_sink = OPC_TRUE;
*/
if (sink_address == my_address){
	is_sink = OPC_TRUE;
	my_sink_tree.is_in_ktree 	= OPC_TRUE;
	my_sync_rx_power 			= OPC_DBL_INFINITY;
	
	//other nodes have to know my position (if we have a grid network)
	x_sink_int = get_x_coord_in_grid(my_address);
	y_sink_int = get_y_coord_in_grid(my_address);

	//time for privileged nodes
	op_ima_sim_attr_get(OPC_IMA_DOUBLE ,  "max_priv_duration",	&slot_privileged_duration);
	printf("privileged for %f seconds\n", slot_privileged_duration);
	TIME_MAX_PRIVILEGED = slot_privileged_duration;
}
else
	slot_privileged_duration 	= 0;




//---------  DISTANCES / ROUTING  ------------

if (is_sink){
	my_sink_tree.sink_dist 	= 0;
	my_sink_tree.ktree_dist = 0;
}
else{
	my_sink_tree.sink_dist 	= DIST_SINK_MAX;
	my_sink_tree.ktree_dist = DIST_SINK_MAX;
}






//-----------------------------------------------
//		   		PROPERTIES
//-----------------------------------------------

is_node_privileged			= OPC_FALSE;
last_frame_sent.type		= NO_PK_TYPE;
next_frame_to_send.type		= NO_PK_TYPE;

unicast_frame_buffer		= op_prg_list_create();
multicast_frame_buffer		= op_prg_list_create();
my_neighborhood_table		= op_prg_list_create();
my_frame_id_seen			= op_prg_list_create();
my_nav_list					= op_prg_list_create();



//Backoff distribution initialization
cw 							= MAX_BACKOFF;
backoff_intrpt				= op_ev_current();
	
//no reservation
is_reply_to_receive 		= OPC_FALSE;
is_reply_to_send			= OPC_FALSE;

//Power of the last received sync frame
my_sync_rx_power			= 0;

//Power of the last received packet (when rx busy -> !busy)
last_rx_power				= 0;

//next packet == hello
is_hello_to_send 			= OPC_FALSE;

//Branches id
ctr_last_branch 			= 0;
sync_last_branch			= 0;
my_branch					= -1;

//my currently active channel (what I am using for my current tx/rx)
my_current_channel	= CHANNEL_MAIN_ID;


//-----------------------------------------------
//		  				 DEBUG
//-----------------------------------------------

if (my_stat_id == 0)
	for(i=0 ; i < 20 ; i++)
		debug_files[i] = NULL;

if (DEBUG > NO){
	if (my_stat_id == 0){
	
		//create debug directories if they do not exist	
		pdir = opendir(get_log_dir());
		if (!pdir)
			mkdir(get_log_dir() , 0777);
		snprintf(dirname , 200, "%s/%s", get_log_dir() , LOG_SUFFIX_NODES);
		pdir = opendir(dirname);
		if (!pdir)
			mkdir(dirname , 0777);
	
		//open the associated debug files
		open_debug_file(&debug_files[DEBUG_GLOBAL] ,	"%s/%d_all.txt" , 		get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_BACKOFF] ,	"%s/%d_backoff.txt" ,	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_DATA] ,		"%s/%d_data.txt" , 		get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_RADIO] ,		"%s/%d_radio.txt" , 	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_CONTROL] ,	"%s/%d_control.txt" ,	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_KTREE] ,		"%s/%d_ktree.txt" , 	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_HELLO] ,		"%s/%d_hello.txt" , 	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_TIMEOUT] ,	"%s/%d_timeout.txt" ,	get_log_dir(), cmac_timestamp);
	}
	open_debug_file(&my_debug_file,						"%s/%s/%d.txt" , 		get_log_dir(), LOG_SUFFIX_NODES, my_address);
		
}

//-----------------------------------------------
//		  	 COM WITH OTHER PROCESSES
//-----------------------------------------------

//objid of the monitor process
strm_id = op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_IN , OPC_OBJTYPE_STRM , MONITOR_INPUT_STREAM);
monitor_objid = op_topo_assoc(strm_id , OPC_TOPO_ASSOC_IN , OPC_OBJTYPE_PROC ,0);

//recovered error
if ((my_address == 0) && (monitor_objid == OPC_OBJID_INVALID)){
	printf("No monitor process was identified, that's not blocking!\n");
	printf("However, we will surely create collisions if we switch our channel (OPNET bug)\n");
}
	
//shared infos
my_mac_info = op_prg_mem_alloc(sizeof(mac_info));
my_mac_info->address 				= my_address;
my_mac_info->current_channel 		= &my_current_channel;
my_mac_info->channel_status_notif 	= &my_channel_status_notif;
op_ima_obj_state_set(op_id_self(), my_mac_info);



//-----------------------------------------------
//		  	 	TRANSMISSION
//-----------------------------------------------


//RADIO Parameters
op_ima_obj_attr_get (op_id_self(), "Wireless LAN Parameters", &mac_params_comp_attr_objid);
params_attr_objid = op_topo_child (mac_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);

	
//Parameters
op_ima_obj_attr_get (params_attr_objid, "Data Rate", 						&operational_speed);

//Power reception (to detect radio activity)
op_ima_obj_attr_get (params_attr_objid, "Packet Reception-Power Threshold", &rx_power_threshold);

//Channel
op_ima_obj_attr_get (params_attr_objid, "Channel Settings", &chann_params_comp_attr_objid);
subchann_params_attr_objid = op_topo_child (chann_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
op_ima_obj_attr_get (subchann_params_attr_objid, "Bandwidth", 				&bandwidth);	
op_ima_obj_attr_get (subchann_params_attr_objid, "Min frequency", 			&frequency);	

	

//-----------------------------------------------
//				DATA RADIO
//-----------------------------------------------

//For 80211a
if (channel_to_freq(0) > 5000)
	bandwidth = BANDWIDTH_MHZ_80211A;
//For 802.11bg
else
	bandwidth = BANDWIDTH_MHZ_80211BG;


//----- TRANSMISSION ----

nb_radio = op_topo_assoc_count(op_id_self() , OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX);

for (i=0; i<nb_radio ; i++){
	

	tx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX, i);
	if (tx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached transmitter\n", "" , "" , "");

	//Channels nb
	op_ima_obj_attr_get (tx_id, "channel", &chann_objid);

	//id access
	sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RATXCH, 0);

	//Frequency + bandwidth
	op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		bandwidth);
	op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	channel_to_freq(CHANNEL_MAIN_ID));
	op_ima_obj_attr_set (sub_chann_objid, "power", 			POWER_TX);

}

my_current_tx_power = POWER_TX ;


//----- RECEPTION ----

nb_radio = op_topo_assoc_count(op_id_self() , OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX);

for (i=0; i<nb_radio ; i++){

	rx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX, i);
	if (rx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached receiver\n", "" , "" , "");


	//Nb channels
	op_ima_obj_attr_get (rx_id, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RARXCH);
	

	//Frequency + bandwidth of the first received
	for (j = 0; j < num_chann; j++){ 	
		//Id
		sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RARXCH, j);
	
		//Frequency + bandwidth
		op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		bandwidth);
		op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	channel_to_freq(CHANNEL_MAIN_ID));		
		
		//Reception power threshold
		op_ima_obj_state_set (sub_chann_objid, &rx_power_threshold);
	}
}








//-----------------------------------------------
//		   			STATWIRES
//-----------------------------------------------

//for all statswirs (tx, rx, busy tone, normal ...)
num_statwires = op_topo_assoc_count (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE);
for (i = 0; i < num_statwires; i++){
	//Id														*/
	statwire_objid = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE, i);
	op_ima_obj_attr_get (statwire_objid, "high threshold trigger", &threshold);
	
	//value
	op_ima_obj_attr_set (statwire_objid, "high threshold trigger", rx_power_threshold);	
}


















//-----------------------------------------------
//		   	SYNCHRO WITH OTHER LAYERS
//-----------------------------------------------

op_intrpt_schedule_self (op_sim_time (), 0);


]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//position in the grid
int	x_int = get_x_coord_in_grid(my_address);
int	y_int = get_y_coord_in_grid(my_address);


//how many directions have I got in the network (if we have a grid...)
if (x_int < x_sink_int)
	is_node_present_for_direction[0] = OPC_TRUE;
if (x_int > x_sink_int)
	is_node_present_for_direction[1] = OPC_TRUE;
if (y_int < y_sink_int)
	is_node_present_for_direction[2] = OPC_TRUE;
if (y_int > y_sink_int)
	is_node_present_for_direction[3] = OPC_TRUE;


]]>
				</value-text>
			</attribute>
		</state>
		<state id="41" x="450" y="90">
			<attribute name="name" type="string" value="IDLE"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[




]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - IDLE2 - %d\n", my_address);

//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


if (DEBUG_STATE_MACHINE){
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - IDLE2 - %d (pk_to_send %d -> (%d & %d) || %d\n", my_address, IS_PK_TO_SEND, IS_DATA_OK , !is_frame_buffer_empty() ,next_frame_to_send.type != NO_PK_TYPE);
	debug_print(LOW , DEBUG_GLOBAL , "DTA_OK: %d | (%d & %d) | %d | %d | %d\n", !strict_privileged_mode, is_hello_to_send, !IS_BROADCAST_FORBIDDEN, !my_sink_tree.is_in_ktree, is_node_privileged, is_sink);
}
]]>
				</value-text>
			</attribute>
		</state>
		<state id="52" x="270" y="90">
			<attribute name="name" type="string" value="INFO_SYNCHRO"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
/* Schedule a self interrupt to wait for mac interface 	*/
/* to move to next state after registering				*/
op_intrpt_schedule_self (op_sim_time (), 0);
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
int		i;

//----------------------------------------------
//					IDENTIFICATION
//----------------------------------------------



//nodeid/addr conversion
if (nodeid_to_addr_var == NULL){
	nodeid_to_addr_var 	= op_prg_mem_alloc(sizeof(int) * get_nb_nodes());
	ktree_static_ok 	= op_prg_mem_alloc(sizeof(Boolean) * get_nb_nodes());
}
nodeid_to_addr_var[my_stat_id] = my_address;
ktree_static_ok[my_stat_id] = OPC_FALSE;

//----------------------------------------------
//					BRANCH LENGTH
//----------------------------------------------


//if (my_stat_id == 0)
//	MAX_BRANCH_LENGTH = 5;//min_int(BETA + 1 , (int)(pow(nb_mac_nodes , 0.5) / 2) - 1);

//the branch_id associated to each direction (grid case)
if (is_sink){
	short branch_id = 0;
	
	//an increasing branch_id for each existing direction
	for(i=0; i<4; i++)
		if (is_node_present_for_direction[i])
			direction_to_branch_id[i] = branch_id++;

}

//----------------------------------------------
//					SINK 
//----------------------------------------------

//The sink must send periodically a CTR (create it, not forward it)
//NB: let the routing info converge (dist_sink and dist_ktree)
if (is_sink)
	if (MAC_LAYER == CMAC){
		op_intrpt_schedule_self(TIME_BEFORE_HELLO_CONVERGENCE , SINK_CTR_CODE); 
		op_intrpt_schedule_self(op_sim_time() + 0.1 , SINK_SYNC_CODE); 
	}




//----------------------------------------------
//					HELLOS 
//----------------------------------------------

//periodical hello for everyone (initally, shorter hello_interval to decrease convergence delays)
op_intrpt_schedule_self(op_sim_time() + 5.0 + op_dist_uniform(3.0) , HELLO_PK_CODE);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="54" x="690" y="510">
			<attribute name="name" type="string" value="EMISSION"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//----------------------------------------------------------------
//
//				FRAME TRANSMISSION
//
// - The medium is free
// - The backoff was decremented or not required
// - The frame 'next_frame_to_send' is ready to be transmitted
//
//-----------------------------------------------------------------

//Control
char		msg[100];
//Packet
Packet*		frame_pk;

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - EMISSION1 - %d\n", my_address);


//------------------------------------------
//			  TRANSMISSION
//------------------------------------------

//The transmitter is not busy -> we are not in transmission -> we send our packet
//- We have a default state self-transition (if the medium keeps on being used)
//  Consequently we must avoid to send the same frame although the current frame is already in transmission
if (!is_tx_busy){

	//debug
	debug_print(LOW , DEBUG_DATA , "sends a packet to %d (type %s, id %d, my_nav %f)\n",  next_frame_to_send.destination , pk_type_to_str(next_frame_to_send.type , msg, 100) , next_frame_to_send.frame_id , get_nav_main_channel());

	//Prepares the packet
	is_tx_busy = OPC_TRUE;
	frame_pk = create_packet(next_frame_to_send);
	
	//for any reason, the packet can have been canceled
	if (frame_pk != OPC_NIL){
	
		// -----  SPECIAL ACTIONS  -----

	
		if (next_frame_to_send.destination == ADDR_BROADCAST)
			print_nav_list(DEBUG_HELLO);
	
		switch (next_frame_to_send.type){
	
			//Increases power (to 10W, that is enormous and all the nodes will get it)
			//If a node does not receive the SYNC it is not a problem: the branch will not expand to the network extremities
			case SYNC_PK_TYPE:
	
				if (is_sync_direct_antenna)	
					change_antenna_direction(STREAM_TO_DIRECT_SYNC , sync_last_branch);
				else
					change_tx_power(1000 , STREAM_TO_RADIO);
			break;
		
			case HELLO_PK_TYPE:
				is_hello_to_send = OPC_FALSE;
			break;
		}
	
		// -----  TRANSMISSSION  -----
		if ((next_frame_to_send.type == SYNC_PK_TYPE) && (is_sync_direct_antenna))
			op_pk_send(frame_pk , STREAM_TO_DIRECT_SYNC);
		else 
			op_pk_send(frame_pk , STREAM_TO_RADIO);
	
		//Registers the frame as sent (if a reply is required: ACK/CTS/...)
		last_frame_sent = next_frame_to_send;
		last_frame_sent.released = OPC_FALSE;
		set_next_frame_null();
		is_reply_to_send = OPC_FALSE;
	}
	//the transmission was canceled => self-interrupt to directly exit the transition STATE
	else
		op_intrpt_schedule_self(op_sim_time(), NOTHING_CODE);
}
//else -> nothing, we just stay in this state while the transmission and keep to treat other interrupts









//Timeouts -> an interruption will be scheduled when we finished the transmission (the medium becomes idle)
if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - EMISSION1 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
char	str[20];


if (DEBUG_STATE_MACHINE)
	debug_print(MAX , DEBUG_GLOBAL , "ENTER - EMISSION2 - %d\n", my_address);


//Handles the possible interruptions (STREAM || STAT)
interrupt_process();




	
	
//Transmission finished !
if (!is_tx_busy){
	debug_print(MEDIUM , DEBUG_RADIO, "transmission ended\n");


	//-----------------------------------------------------
	//	NORMAL TRANSMISSION POWER
	//-----------------------------------------------------


	//Decrease the power to a normal value
	if (last_frame_sent.type == SYNC_PK_TYPE){
		
		//normal power transmission
		if (!is_sync_direct_antenna)
			change_tx_power(POWER_TX , STREAM_TO_RADIO);
		
		//Next sync if we have a directional antenna
		if ((sync_last_branch != NB_BRANCHES - 1) && (is_sync_direct_antenna)){
			sync_last_branch++;
			generate_sync();
		}
		else
			sync_last_branch = 0;
	}
		
	
	
	//-----------------------------------------------------
	//	MULTI_CHANNEL -> SWITCHING
	//-----------------------------------------------------

	if (nb_channels > 1){
	
		//CTR sent -> changes to the privileged channel
		if (last_frame_sent.type == CTR_PK_TYPE){
			debug_print(LOW, DEBUG_CONTROL, "CTR sent, go to the privileged channel for the reply\n");
			change_tx_rx_phy(my_privileged_channel );
			
			if (op_ev_valid(main_channel_return_intrpt))
				op_ev_cancel(main_channel_return_intrpt);
			
			main_channel_return_intrpt = op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration , MAIN_CHANNEL_RETURN_CODE);
		}
		
		
		//CTR-ACK sent -> changes to the privileged channel
		if ((last_frame_sent.type == CTR_ACK_PK_TYPE) && (is_main_channel_active()) && (last_frame_sent.nb_retry == 0)){
		
			//Channel change
			debug_print(MEDIUM, DEBUG_CONTROL, "the CTR-ACK was sent\n");
			change_tx_rx_phy(my_privileged_channel);
			
			//sends a CTR-END through the privileged channel if no data frame to send
			if (is_frame_buffer_empty()){
				print_frame_buffer(DEBUG_CONTROL);
				debug_print(MAX, DEBUG_CONTROL, "privileged -> I switched and I will send now ctr-end\n");
				generate_ctr_end();
			}
			else
				debug_print(MAX, DEBUG_CONTROL, "privileged -> I switched and I will send now a data frame\n");
			
		}
		//CTR-ACK sent over the privileged channel -> changes to the main channel
		else if ((last_frame_sent.type == CTR_ACK_PK_TYPE) && (!is_main_channel_active())){
			debug_print(LOW, DEBUG_CONTROL,"no more data and CTR-ACK sent\n");
			change_tx_rx_phy(CHANNEL_MAIN_ID);
		}
	
		//We must now send a CTR for our child
		if ((last_frame_sent.type == CTR_END_PK_TYPE) && (last_frame_sent.nb_retry == 0)){
			debug_print(MAX, DEBUG_CONTROL, "the transmission of the CTR-END is fnished, let now propagate the CTR\n");
			generate_ctr();
		}
	}
		
		
	//-----------------------------------------------------
	//	Must the node wait a reply for this frame ?
	//-----------------------------------------------------

	//BROADCAST Frame 
	if (last_frame_sent.destination == ADDR_BROADCAST)
		is_reply_to_receive = OPC_FALSE;
	
	//Ack Frame
	else if (last_frame_sent.type == ACK_PK_TYPE)
		is_reply_to_receive = OPC_FALSE;
	
	//CTR
	else if (last_frame_sent.type == CTR_END_PK_TYPE)
		is_reply_to_receive = OPC_FALSE;
	
	else if (last_frame_sent.type == CTR_ACK_PK_TYPE)
		is_reply_to_receive = OPC_FALSE;

	//default behavior	
	else	
		is_reply_to_receive = OPC_TRUE;

	
	
	
	
	//-----------------------------------------------------
	//					Privileged mode
	//-----------------------------------------------------	
	//I sent a CTR-END -> I am no longer priviledged
	if (last_frame_sent.type == CTR_END_PK_TYPE){
		is_node_privileged = OPC_FALSE;
		debug_print(LOW , DEBUG_CONTROL , "the node becomes unpriviledged\n");
	}

	
	
	
	//-----------------------------------------------------
	//						Timeout
	//-----------------------------------------------------	
	//Timeout of a reply is required
	if (is_reply_to_receive){

		//DATA sent -> an ack only is required
		if (last_frame_sent.type == DATA_UNICAST_PK_TYPE)
			add_frame_timeout(compute_ack_time());
		
		//RTS -> I must wait a CTS
		else if (last_frame_sent.type == RTS_PK_TYPE)
			add_frame_timeout(compute_cts_time());

		//CTR -> the destination can reply to my CTR directly with a DATA packet
		else if ((nb_channels == 1) && (last_frame_sent.type == CTR_PK_TYPE))
			add_frame_timeout(compute_data_time(MTU_MAX));
		
		//CTR -> I must wait a DATA packet (the time for the ctr-ack + for the data frame in multichannel)
		else if ((nb_channels > 1) && (last_frame_sent.type == CTR_PK_TYPE))
			add_frame_timeout(compute_ctr_ack_time() + compute_data_time(MTU_MAX));
		else
			debug_print(LOW, DEBUG_CONTROL, "BUG for pk type %s\n", pk_type_to_str(last_frame_sent.type, str, 20));
	}
		
	//-----------------------------------------------------
	//						Acks
	//-----------------------------------------------------	
	//Deletes the corresponding data frame (no ack required)
	else if ((last_frame_sent.type == DATA_MULTICAST_PK_TYPE) || (last_frame_sent.type == HELLO_PK_TYPE))
		del_frame_buffer_with_id(last_frame_sent.frame_id , OPC_FALSE);
	

}

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - EMISSION2 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="56" x="510" y="270">
			<attribute name="name" type="string" value="DEFER"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Next data frame to send
frame_struct	*frame_ptr;
frame_struct	data_frame;
frame_struct	next_data_frame;
//transmission time
double			time_for_first_data;
double			time_for_second_data;
//Control
//char			msg[100];


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - DEFER1 - %d\n", my_address);


//------------------------------------------
//			   GET DATA FRAME
//------------------------------------------


//debug_print(MAX , DEBUG_CONTROL , "STATE_DEFER: data_buffer_empty %d, frame_to_send %d (type %s), IS_PK_TO_SEND %d, ktree %d, priviledged %d\n", is_frame_buffer_empty() , next_frame_to_send.type != NO_PK_TYPE , pk_type_to_str(next_frame_to_send.type , msg, 100) ,  IS_PK_TO_SEND , my_sink_tree.is_in_ktree , is_node_privileged);
//if (is_node_privileged)
//	debug_print(MAX , DEBUG_CONTROL , "start_priviledged %f, time_min %f, CAN_SLOT_BE_ENDED %d, PRIVILEDGE_END %d (medium %d, high %d)\n", time_start_privileged , slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO , time_start_privileged + slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO <= op_sim_time() , PRIVILEGED_END , PRIVILEGED_MEDIUM_LIMIT , PRIVILEGED_HIGH_LIMIT);
		

//We have no frame which is scheduled to be transmitted
if (next_frame_to_send.type == NO_PK_TYPE){


	//----------------------------------------------
	//			KTREE NODE & PRIVILEGED 
	//----------------------------------------------
	if (is_node_privileged){
	
		//Buffer empty -> I will lose my priviledged status
		if ((PRIVILEGED_MEDIUM_LIMIT) || (PRIVILEGED_HIGH_LIMIT)){
			if (nb_channels > 1)
				generate_ctr_end();
			else
				generate_ctr();
		}
		else if ((is_frame_buffer_empty()) && (!PRIVILEGED_MEDIUM_LIMIT))
			op_sim_end("We should not be in this state if we have nothing to send", "and we cannot end the priviledge mode" , "" , "");
			
		//I send the first data_frame of the queue
		else{
			//first frame
			frame_ptr			= get_frame_buffer(0);
			data_frame 			= *frame_ptr;
			time_for_first_data = compute_rts_time() + compute_cts_time() + compute_data_time(data_frame.pk_size)  + compute_ack_time();
			
			//An eventual second frame
			frame_ptr	= get_frame_buffer(1);
			if (frame_ptr != NULL){
				next_data_frame 		= *frame_ptr;
				time_for_second_data 	= compute_rts_time() + compute_cts_time() + compute_data_time(data_frame.pk_size)  + compute_ack_time();
			}
			else
				time_for_second_data = 0;
			
			//We have not the time to send this data packet !
			if (time_for_first_data + op_sim_time() >= slot_privileged_duration + time_start_privileged)
				generate_ctr();
			
			else{
				
				//Medium reservation if a second packet has to be transmitted
				if ((time_for_second_data == 0) || (time_for_first_data + time_for_second_data + op_sim_time() >= slot_privileged_duration + time_start_privileged))
					data_frame.nav_duration = compute_ack_time();
				else
					data_frame.nav_duration = compute_data_time(next_data_frame.pk_size) + compute_ack_time();
				
				//Prepare the next transmission
				change_next_frame(data_frame);
			}
			
			
		}
	}
	
	//----------------------------------------------
	//			NORMAL NODE
	//----------------------------------------------
	else if (!is_frame_buffer_empty()){

		//get the first data packet to send
		frame_ptr = get_frame_buffer(0);		
		if (frame_ptr != NULL)
			data_frame = *frame_ptr;
	
		//broadcast frames do not need any RTS
		if ((data_frame.destination == ADDR_BROADCAST) || (data_frame.pk_size  < RTS_PK_SIZE))
			change_next_frame(data_frame);
		
		//Generates a new RTS, it will be automatically registered as the new frame to send
		else{
			
			double nav_duration = 10e6 * ((double)compute_cts_time() + compute_data_time(data_frame.pk_size) + compute_ack_time());
			generate_rts(data_frame.destination , (int)nav_duration , data_frame.frame_id , data_frame.power_ratio);

			if (DEBUG >= MAX){
				print_unicast_frame_buffer(DEBUG_DATA);
				print_multicast_frame_buffer(DEBUG_DATA);
			}
		}
	}
	else
		printf("It is strange, I entered in DEFER wihtout any packet to send\n");
}







//debug
//debug_print(MEDIUM , DEBUG_DATA , "has a packet to send to %d (type %s, id %d, nb_retry %d)\n", next_frame_to_send.destination , pk_type_to_str(next_frame_to_send.type , msg, 100) , next_frame_to_send.frame_id , next_frame_to_send.nb_retry);



//------------------------------------------
//			   INTER FRAME TIME
//------------------------------------------


//The medium becomes free -> we must wait the inter_frame time
if (!IS_MEDIUM_BUSY){
	if ((is_node_privileged) && ((next_frame_to_send.type == CTR_ACK_PK_TYPE) || (next_frame_to_send.type == CTR_PK_TYPE) || (next_frame_to_send.type == CTR_END_PK_TYPE)) )
		next_frame_to_send.ifs = PIFS;
	else if ((is_node_privileged) && (nb_channels > 1))
		next_frame_to_send.ifs = 0;
	else if (is_node_privileged)
		next_frame_to_send.ifs = SIFS;
	else if ((next_frame_to_send.type == RTS_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == DATA_UNICAST_PK_TYPE) || (next_frame_to_send.type == HELLO_PK_TYPE))
		next_frame_to_send.ifs = DIFS;
	else
		next_frame_to_send.ifs = SIFS;

	//We will verify that the medium remains idle
	debug_print(MEDIUM, DEBUG_BACKOFF, "self interrupt, ifs %f\n", next_frame_to_send.ifs);
	op_intrpt_schedule_self(op_sim_time() + next_frame_to_send.ifs , DEFER_CODE);
}
/*else{
	debug_print(MEDIUM, DEBUG_BACKOFF, 
		"IS MED BUSY %d = %d | %d | %d\n",
		IS_MEDIUM_BUSY,
		(is_rx_busy),
		(is_tx_busy),
		(get_nav_main_channel() >= op_sim_time()));
	print_nav_list(DEBUG_CONTROL);
	}
*/


if (DEBUG_STATE_MACHINE){
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - DEFER1 - %d - timeout %f\n", my_address , next_frame_to_send.ifs *1E6);
	print_nav_list(DEBUG_GLOBAL);
}
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//The inter-frame time
//double		time_to_wait;



if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - DEFER2 - %d\n", my_address);



//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


//------------------------------------------
//			   BACKOFF
//------------------------------------------

// STAT_INTRPT + !MEDIUM_BUSY -> I must wait the IFS (and not take directly a transition)
// If such an interruptions occurs, we schedule the IFS verification, but don't change the backoff
// Thus, the default behavior is to have an invalid backoff in order to avoid any state transition
my_backoff = -1;



//I try to transmit or decrement the backoff only if :
// -> No transmission (this is never the case since the transmission state is not here)
// -> No reception
// -> The medium was not previously reserved (verify the value of my NAV)
//
if ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE)){


	if (!IS_MEDIUM_BUSY){
		//broadcast -> the frame can be data, multicast, etc. if the destination is the broadcast address, we need a backoff
		if ((!is_node_privileged) &&     (     (next_frame_to_send.type == RTS_PK_TYPE) || (next_frame_to_send.destination == ADDR_BROADCAST) || ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE))   )      ){
		
			//nex backoff value
			my_backoff = (int)op_dist_uniform(cw + 1);
			debug_print(MAX , DEBUG_BACKOFF , "new backoff %d (condition from backoff state %d %d) (cw(%d) %d)\n", my_backoff, IS_FRAME_RECEIVED , IS_BACK_TO_DEFER, cw >32, cw);
				
			//Schedules the backoff interrupt (deletes an eventual old interruption)
			op_ev_cancel_if_pending(backoff_intrpt);			
			backoff_intrpt = op_intrpt_schedule_self(op_sim_time() + SLOT_BACKOFF * my_backoff , BACKOFF_CODE);
		}
		else{
	
			//debug_print(MEDIUM , DEBUG_BACKOFF , "No backoff needed: privileged %d & \n", (!is_node_privileged));
			//debug_print(MEDIUM , DEBUG_BACKOFF , "rts %d | broadcast %d | data without rts %d\n", (next_frame_to_send.type == RTS_PK_TYPE) , (next_frame_to_send.destination == ADDR_BROADCAST) , ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE)));
			//debug_print(MEDIUM , DEBUG_BACKOFF , "%d = %d & %f < %f\n", next_frame_to_send.type, DATA_UNICAST_PK_TYPE, next_frame_to_send.pk_size, RTS_PK_SIZE);
			debug_print(MEDIUM , DEBUG_BACKOFF , "no backoff required (priviledged %d, next=rts %d, broadcast %d, data_without_rts %d, rts_thresh %f)\n", is_node_privileged , next_frame_to_send.type == RTS_PK_TYPE , next_frame_to_send.destination == ADDR_BROADCAST, ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE)), RTS_PK_SIZE);
			my_backoff = 0;
		}		
	}
	//The medium is busy and we have the priority -> that is not regular !
	else if (PRIORITY_AND_MEDIUM_BUSY){
		debug_print(LOW , DEBUG_DATA , "a collision occurred (we have the priority and the medium is busy, we discard the current transmission (this was a reply)\n");
		debug_print(LOW , DEBUG_DATA , "%d %d %d %d\n",  CTS_PK_TYPE, ACK_PK_TYPE, DATA_UNICAST_PK_TYPE, next_frame_to_send.type);

		//Discard the current packet
		set_next_frame_null();		
	}	
	//We have to wait (another node is transmitting something)
	else
		debug_print(MEDIUM , DEBUG_DATA , "the medium is busy, we must wait\n");
}


//------------------------------------------
//		  CANCEL OBSOLETE TRANSMISSIONS
//------------------------------------------

if 	((next_frame_to_send.type == RTS_PK_TYPE) && (is_unicast_frame_buffer_empty())){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: RTS and the frame buffer is empty\n");
	set_next_frame_null();
}


if 	(((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && (!is_in_frame_buffer(next_frame_to_send.frame_id))){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the frame is no longer present in the frame buffer\n");
	set_next_frame_null();
}

if 	(((next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && IS_BROADCAST_FORBIDDEN){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the broadcast is currently not authorized\n");
	set_next_frame_null();
}




if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - DEFER2 - %d (%d, %d)\n", my_address, IS_MEDIUM_BUSY , my_backoff);


//debug_print(MAX , DEBUG_DATA , "busy -> rx_busy %d tx_busy %d nav %f -> %d medium busy %d\n", is_rx_busy , is_tx_busy , get_nav_main_freq() , get_nav_main_freq() > op_sim_time() , IS_MEDIUM_BUSY);

]]>
				</value-text>
			</attribute>
		</state>
		<state id="58" x="270" y="510">
			<attribute name="name" type="string" value="BACKOFF"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "Enter in backoff state\n");


]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//Inter frame time
//double		time_to_wait;

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - BACKOFF2 - %d\n", my_address);




//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


//The backoff is finished
if ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == BACKOFF_CODE)){
	debug_print(MEDIUM, DEBUG_BACKOFF , "the backoff is finished, we can transmit our frame\n");
	my_backoff = 0;
}




//------------------------------------------
//			   STOP  BACKOFF
//------------------------------------------

//The medium is busy OR medium reserved -> stop the backoff
if ((op_ev_valid(backoff_intrpt)) && (IS_MEDIUM_BUSY)){
	
	//Stores the remaining backoff
	my_backoff = ceil((op_ev_time(backoff_intrpt) - op_sim_time()) / SLOT_BACKOFF);
	//debug_print(MEDIUM, DEBUG_BACKOFF, "%f - %f / %f\n", op_ev_time(backoff_intrpt) , op_sim_time() , SLOT_BACKOFF);

	//disable the previous backoff interrupt (the backoff must not be decremented during medium activity)
	op_ev_cancel(backoff_intrpt);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "stoping backoff %d (busy %d, nav %3f, cancel %d, rec %d, back defer %d)\n", my_backoff , is_rx_busy , (get_nav_main_channel() - op_sim_time()) * 1E6, TRANSMISSION_CANCELED, IS_FRAME_RECEIVED, IS_BACK_TO_DEFER);
}





//------------------------------------------
//			  RESTART  BACKOFF
//------------------------------------------

//the medium becomes idle OR reservation expired -> resume the backoff
if ((!op_ev_valid(backoff_intrpt)) && (!IS_MEDIUM_BUSY) && ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE))){

	//Schedules the backoff interrupt
	backoff_intrpt = op_intrpt_schedule_self(op_sim_time() + SLOT_BACKOFF * my_backoff , BACKOFF_CODE);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "resuming backoff %d (busy %d nav %3f)\n", my_backoff , is_rx_busy , (get_nav_main_channel() - op_sim_time()) * 1E6);
}







//------------------------------------------
//			   INTER FRAME TIME
//------------------------------------------


//The medium becomes free -> we must wait the inter_frame time
if ((!op_ev_valid(backoff_intrpt)) && (!IS_MEDIUM_BUSY) && (!op_ev_valid(defer_intrpt))){

	//We will verify that the medium remains idle (inter frame space was already computed in the state DEFER)
	defer_intrpt = op_intrpt_schedule_self(op_sim_time() + next_frame_to_send.ifs , DEFER_CODE);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "defer %f for the inter frame time\n", next_frame_to_send.ifs * 1E6);
}






//------------------------------------------
//		  CANCEL OBSOLETE TRANSMISSIONS
//------------------------------------------
// This case can occur if we received an ack athough we already entered in backoff mode

if 	((next_frame_to_send.type == RTS_PK_TYPE) && (is_unicast_frame_buffer_empty())){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: RTS and the frame buffer is empty\n");
	set_next_frame_null();
}


if 	(((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && (!is_in_frame_buffer(next_frame_to_send.frame_id))){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the frame is no longer present in the frame buffer\n");
	set_next_frame_null();
}

if 	(((next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && IS_BROADCAST_FORBIDDEN){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the broadcast is currently not authorized\n");
	set_next_frame_null();
}




//------------------------------------------
//			   DEBUG
//------------------------------------------

/*
//Debug
debug_print(MAX , DEBUG_BACKOFF , "IS_BACK_TO_DEFER %d backoff %d (conditions %d %d %d %d)\n", IS_BACK_TO_DEFER , my_backoff , next_frame_to_send.type == CTR_PK_TYPE , IS_FRAME_RECEIVED , IS_REPLY_TO_SEND , is_rx_busy);


debug_print(MAX , DEBUG_BACKOFF , "TYPE %d (self %d stream %d stat %d), code %d\n", op_intrpt_type() , OPC_INTRPT_SELF , OPC_INTRPT_STRM , OPC_INTRPT_STAT , op_intrpt_code());
if (op_intrpt_type() == OPC_INTRPT_STRM){
	debug_print(MAX , DEBUG_BACKOFF , "stream %d\n", op_intrpt_strm());
	debug_print(MAX , DEBUG_BACKOFF , "%d %d %d %d %d\n", op_intrpt_type() , OPC_INTRPT_STRM , (op_intrpt_type() == OPC_INTRPT_STRM) , (op_intrpt_strm() == STREAM_FROM_RADIO) , IS_FRAME_RECEIVED);
}
*/






//---------------------------------------------
//		EXIT BACKOFF -> CANCEL the INTRPT
//---------------------------------------------

if ((IS_BACK_TO_DEFER) || (TRANSMISSION_CANCELED))
	if (op_ev_valid(backoff_intrpt))
		op_ev_cancel(backoff_intrpt);












if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - BACKOFF2 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="62" x="810" y="150">
			<attribute name="name" type="string" value="END_TRANSMIT"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Control
char	msg[100];



//Just a debug message when we start to wait the reply for one of our frame
if (is_reply_to_receive){
	//debug
	debug_print(MAX , DEBUG_RADIO , "%s sent, it must wait a reply\n", pk_type_to_str(last_frame_sent.type , msg, 100));


	//We did not received yet a reply for our transmission (we just leave it !)
	is_reply_received = OPC_FALSE;
}
]]>
				</value-text>
			</attribute>
			<attribute name="status" type="toggle" value="1"/>
		</state>
		<state id="63" x="1050" y="90">
			<attribute name="name" type="string" value="WAIT_NEXT"/>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//Control
char		msg[100];


//Default (will change of the received packet is not that we expect
is_reply_bad = OPC_FALSE;


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - WAIT_NEXT2 - %d\n", my_address);


//Handles the possible interruptions (STREAM || STAT)
//NB: if we had a timeout, and we received a packet, we can answer to the received packet and discard temporarily the retransmission (rather delay it)
interrupt_process();



//The frame timeouted -> we must retransmit it
if ((is_reply_bad) || (IS_FRAME_TIMEOUT)){
	
	//Failed -> we increments the nb_retry for the corresponding data_frame
	//NB: it is a unicast frame since multicast frame are not acknowledged
	if ((last_frame_sent.type == DATA_UNICAST_PK_TYPE) || (last_frame_sent.type == RTS_PK_TYPE))
		increment_nb_retry_unicast_frame_buffer(last_frame_sent.frame_id);
	debug_print(LOW , DEBUG_TIMEOUT , "the flow to %d is broken for one of my frame (type %s, retry %d , id %d, next type %d, dataok %d, empty %d) (timeout %d bad_reply %d)\n", last_frame_sent.destination , pk_type_to_str(last_frame_sent.type, msg, 100) , last_frame_sent.nb_retry , last_frame_sent.frame_id , next_frame_to_send.type , IS_DATA_OK , is_frame_buffer_empty() , IS_FRAME_TIMEOUT , is_reply_bad);
	
	
	//CTR -> we must retransmit it
	if ((last_frame_sent.type == CTR_PK_TYPE) && (last_frame_sent.nb_retry < MAX_NB_RETRY)){
	
		//increase the nb of retries
		last_frame_sent.nb_retry ++;
		
		//And retransmission !
		change_next_frame(last_frame_sent);
		
		//Failed -> go to the main channel
		if (nb_channels > 1){
			debug_print(MEDIUM, DEBUG_CONTROL, "Failure for the CTR -> we come back to the main channel\n");
			change_tx_rx_phy(CHANNEL_MAIN_ID);
		}	
	}
	
	//We are privileged, we have no more data, and the last one failed -> come back to the main channel
	if ((is_frame_buffer_empty()) && (last_frame_sent.type == DATA_UNICAST_PK_TYPE) && (last_frame_sent.nb_retry >= MAX_NB_RETRY) && (nb_channels > 1)){
		debug_print(MEDIUM, DEBUG_CONTROL, "Failure for the DATA although I am privileged on a dedicated channel -> we come back to the main channel\n");
		change_tx_rx_phy(CHANNEL_MAIN_ID);
	}
}

if (is_reply_received)
	cw = MAX_BACKOFF;


//The medium is no longer reserved for this flow
if ((is_reply_received) || (IS_FRAME_TIMEOUT) || is_reply_bad) {
	is_reply_to_receive		= OPC_FALSE;
}


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - WAIT_NEXT2 - %d\n", my_address);

]]>
				</value-text>
			</attribute>
		</state>
	</states>
	<transitions>
		<transition source-state-id="40" destination-state-id="52" label-x="181" label-y="88">
			<path-point x="116" y="88"/>
			<path-point x="243" y="88"/>
			<attribute name="name" type="string" value="tr_292"/>
		</transition>
		<transition source-state-id="52" destination-state-id="41" label-x="360" label-y="88">
			<path-point x="297" y="90"/>
			<path-point x="428" y="90"/>
			<attribute name="name" type="string" value="tr_293"/>
		</transition>
		<transition source-state-id="41" destination-state-id="56" label-x="484" label-y="167">
			<path-point x="436" y="94"/>
			<path-point x="506" y="265"/>
			<attribute name="name" type="string" value="tr_307"/>
			<attribute name="condition" type="string" value="IS_PK_TO_SEND || PRIVILEGED_END"/>
		</transition>
		<transition source-state-id="56" destination-state-id="54" label-x="600" label-y="416">
			<path-point x="506" y="268"/>
			<path-point x="687" y="509"/>
			<attribute name="name" type="string" value="tr_308"/>
			<attribute name="condition" type="string" value="GO_TO_SEND"/>
		</transition>
		<transition source-state-id="56" destination-state-id="58" label-x="409" label-y="391">
			<path-point x="510" y="274"/>
			<path-point x="274" y="501"/>
			<attribute name="name" type="string" value="tr_309"/>
			<attribute name="condition" type="string" value="GO_TO_BACKOFF"/>
		</transition>
		<transition source-state-id="58" destination-state-id="54" label-x="485" label-y="565">
			<path-point x="278" y="513"/>
			<path-point x="666" y="515"/>
			<attribute name="name" type="string" value="tr_310"/>
			<attribute name="condition" type="string" value="!IS_BACK_TO_DEFER &amp;&amp; !TRANSMISSION_CANCELED  &amp;&amp; (my_backoff == 0)"/>
		</transition>
		<transition source-state-id="58" destination-state-id="56" label-x="291" label-y="324">
			<path-point x="267" y="503"/>
			<path-point x="300" y="334"/>
			<path-point x="480" y="277"/>
			<attribute name="name" type="string" value="tr_312"/>
			<attribute name="condition" type="string" value="!TRANSMISSION_CANCELED &amp;&amp; IS_BACK_TO_DEFER"/>
		</transition>
		<transition source-state-id="54" destination-state-id="62" label-x="755" label-y="323">
			<path-point x="692" y="497"/>
			<path-point x="817" y="149"/>
			<attribute name="name" type="string" value="tr_314"/>
			<attribute name="condition" type="string" value="!is_tx_busy"/>
		</transition>
		<transition source-state-id="62" destination-state-id="63" label-x="918" label-y="85">
			<path-point x="807" y="134"/>
			<path-point x="1042" y="82"/>
			<attribute name="name" type="string" value="tr_315"/>
			<attribute name="condition" type="string" value="is_reply_to_receive"/>
		</transition>
		<transition source-state-id="63" destination-state-id="62" label-x="1013" label-y="162">
			<path-point x="1047" y="99"/>
			<path-point x="827" y="151"/>
			<attribute name="name" type="string" value="tr_316"/>
			<attribute name="condition" type="string" value="is_reply_received || IS_FRAME_TIMEOUT || is_reply_bad"/>
		</transition>
		<transition source-state-id="62" destination-state-id="41" label-x="681" label-y="66">
			<path-point x="794" y="147"/>
			<path-point x="444" y="73"/>
			<attribute name="name" type="string" value="tr_317"/>
			<attribute name="condition" type="string" value="!is_reply_to_receive &amp;&amp; !IS_PK_TO_SEND &amp;&amp; ! PRIVILEGED_END"/>
		</transition>
		<transition source-state-id="62" destination-state-id="56" label-x="671" label-y="212">
			<path-point x="817" y="159"/>
			<path-point x="520" y="266"/>
			<attribute name="name" type="string" value="tr_318"/>
			<attribute name="condition" type="string" value="!is_reply_to_receive &amp;&amp; (IS_PK_TO_SEND || PRIVILEGED_END)"/>
		</transition>
		<transition source-state-id="54" destination-state-id="54" label-x="821" label-y="512">
			<path-point x="704" y="507"/>
			<path-point x="791" y="499"/>
			<path-point x="781" y="534"/>
			<path-point x="705" y="517"/>
			<attribute name="name" type="string" value="tr_321"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="58" destination-state-id="58" label-x="238" label-y="587">
			<path-point x="257" y="518"/>
			<path-point x="236" y="553"/>
			<path-point x="257" y="573"/>
			<path-point x="259" y="525"/>
			<attribute name="name" type="string" value="tr_323"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="41" destination-state-id="41" label-x="457" label-y="10">
			<path-point x="452" y="78"/>
			<path-point x="424" y="29"/>
			<path-point x="476" y="28"/>
			<path-point x="446" y="65"/>
			<attribute name="name" type="string" value="tr_327"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="56" destination-state-id="56" label-x="611" label-y="280">
			<path-point x="527" y="276"/>
			<path-point x="579" y="292"/>
			<path-point x="580" y="260"/>
			<path-point x="529" y="273"/>
			<attribute name="name" type="string" value="tr_329"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="56" destination-state-id="41" label-x="279" label-y="223">
			<path-point x="497" y="255"/>
			<path-point x="282" y="224"/>
			<path-point x="439" y="106"/>
			<attribute name="name" type="string" value="tr_332"/>
			<attribute name="condition" type="string" value="TRANSMISSION_CANCELED"/>
		</transition>
		<transition source-state-id="58" destination-state-id="41" label-x="91" label-y="251">
			<path-point x="261" y="501"/>
			<path-point x="106" y="279"/>
			<path-point x="206" y="172"/>
			<path-point x="440" y="97"/>
			<attribute name="name" type="string" value="tr_337"/>
			<attribute name="condition" type="string" value="TRANSMISSION_CANCELED"/>
		</transition>
		<transition source-state-id="63" destination-state-id="63" label-x="1176" label-y="93">
			<path-point x="1064" y="78"/>
			<path-point x="1137" y="88"/>
			<path-point x="1124" y="142"/>
			<path-point x="1062" y="94"/>
			<attribute name="name" type="string" value="tr_322"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
	</transitions>
	<external-sources>
<![CDATA[
ams_basetraf_supp
ams_support_v2
apptrack_support
ip_addr_v4
oms_auto_addr_support
oms_basetraf
oms_bgutil
oms_data_def
oms_dim_stat_support
oms_dist_support
oms_ext_file_support
oms_ot_support
oms_pipeline
oms_pr
oms_rr
oms_sim_attr_cache
oms_string_support
oms_sv
oms_tan
tools_fig
wlan_support
]]>
	</external-sources>
	<packet-formats>
<![CDATA[
wlan_control
wlan_mac
]]>
	</packet-formats>
	<local-statistics>
		<statistic name="Backoff Slots (slots)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of slots station needs to backoff before transmission while contenting for the medium, and the number of slots in the contention windows after station's successful transmissions.
]]>
			</description>
		</statistic>
		<statistic name="Channel Reservation (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The amount of time the channel will be 
busy (network allocation vector). 



]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Rcvd (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
received by the station in bits/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Rcvd (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack( traffic 
received by the station in packets/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Sent (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
transmitted by the station in bits/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Sent (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
transmitted by the station in 
packets/sec 

]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Rcvd (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic received by the 
station in bits/sec 
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Rcvd (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic rcvd by the station 
from the network.  
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Sent (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic transmitted by the 
station in bits/sec  
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Sent (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic transmitted by the 
station. 
]]>
			</description>
		</statistic>
		<statistic name="Delay (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the end to end delay of all the packets received by the wireless LAN MAC of this node and forwarded to the higher layer.

This delay includes medium access delay at the source MAC, reception of all the fragments individually, and the transfer of the frame via AP, if acccess point functionality is enabled.
]]>
			</description>
		</statistic>
		<statistic name="Dropped Data Packets (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The packets dropped in bits by the WLAN MAC due to 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.

]]>
			</description>
		</statistic>
		<statistic name="Dropped Data Packets (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The packets dropped by the WLAN MAC due to 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.

]]>
			</description>
		</statistic>
		<statistic name="Hld Queue Size (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/time average" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Size of the queue that holds the frames received from higher layer until they are forwarded to the physical layer by the MAC for transmission.   



]]>
			</description>
		</statistic>
		<statistic name="Load (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Load (in bits/sec) submitted to wlan 
layer by all other higher layers in 
this node. 
]]>
			</description>
		</statistic>
		<statistic name="Load (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Load (in packets) submitted to wlan 
layer by all other higher layers in 
this node. 
]]>
			</description>
		</statistic>
		<statistic name="Media Access Delay (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The total of queue and contention delays of data packets received by WLAN MAC from higher layer. For each packet, the delay is recorded when the packet is sent to the physical layer for the first time. 
Hence, it also includes the period for the successful RTS/CTS exchange, if this exchange is used for that packet.
]]>
			</description>
		</statistic>
		<statistic name="Retransmission Attempts (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of retransmission attempts 
before the packet was successfully 
transmitted.



]]>
			</description>
		</statistic>
		<statistic name="Throughput (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of bits sent to the higher layer.

]]>
			</description>
		</statistic>
	</local-statistics>
	<global-statistics>
		<statistic name="Data Dropped (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The total size of higher layer data packets (in bits/sec) dropped by all the WLAN MACs in the network due to: 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.
]]>
			</description>
		</statistic>
		<statistic name="Delay (sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the end to end delay of all the packets received by the wireless LAN MACs of all WLAN nodes in the network and forwarded to the higher layer. 

This delay includes medium access delay at the source MAC, reception of all the fragments individually, and transfer of the frames via AP, if acccess point functionality is enabled.
]]>
			</description>
		</statistic>
		<statistic name="Load (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the total load (in bits/sec) submitted to wireless LAN layers by all other higher layers in all WLAN nodes of the network.
]]>
			</description>
		</statistic>
		<statistic name="Media Access Delay (sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the global statistic for the total of queue and contention delays of data packets received by all WLAN MACs in the network from higher layer.

For each packet, the delay is recorded when the packet is sent to the physical layer for the first time. Hence, it also includes the period for the successful RTS/CTS exchange, if this exchange is used for that packet.
]]>
			</description>
		</statistic>
		<statistic name="Throughput (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the total number of bits (in bits/sec) forwarded from wireless LAN layers to higher layers in all WLAN nodes of the network.
]]>
			</description>
		</statistic>
	</global-statistics>
	<comments>
<![CDATA[
General Process Description:

----------------------------

The IEEE802.11 (wireless lan) process model is a MAC layer protocol. The 
role of the wlan_mac is to accept data packets from the higher layer 
protocols, encapsulate this data into wlan frames, and to send these 
frames in first-in-first-out order to the destination station. It provides 
efficient and fair sharing of bandwidth among all the stations attached to 
the wireless lan. Collision avoidance and deference is handled by the   
individual station.  



 Packet Formats:

---------------

"wlan_mac" packet format is used to encapsulate higher layer data into 
wireless lan frames. It carries control fields such as the source and 
destination addresses and the protocol type. In addition, the frame check 
sequence and preamble components are modeled as fields of the packet.



Statistic Wires:

----------------

On input statistic 1, the wlan_mac process expects to receive a boolean 
statistic indicating whether a transmission is in progress by this 
station. This statistic wire comes from the busy statistic of the 
transmitter channel. The "rising edge trigger" should only be enabled for 
this statistic wire.



On input statistic 2, the wlan_mac process expects to receive a boolean 
statistic indicating whether a reception is in progress or a complete 
packet has been received by this station. This statistic wire comes from 
the busy statistic of the receiver channel. The "rising edge trigger"  
should only be enabled for this statistic wire.



Process Registry:

-----------------

Published Attributes: protocol, address

Expected Attributes: None



Streams:



-------

There are four input streams from the receiver to the MAC process and four 
output streams from the MAC process to the transmitter. Each of these 
streams are dedicated to a data rate (1Mbps, 2Mbps, 5.5Mbps, and 11Mbps). 
The stream numbers are hardwired to be (0,1,2,and 3). The process model 
use these stream numbers to process incoming and outgoing packets. 



]]>
	</comments>
</process-model>
