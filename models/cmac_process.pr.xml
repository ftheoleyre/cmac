<?xml version="1.0"?>
<process-model model-name="cmac_process" code-language="C" tv-in-db="yes" tv-in-tb="yes">
	<OPNET-info OPNET-release="12.0.A" OPNET-patchlevel="5" OPNET-model-data-version="10.7.A"/>
	<model-attributes>
		<attribute name="Wireless LAN Parameters" type="compound">
			<properties type="compound" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="Default"/>
				<symbol-map>
					<symbol name="Default">
						<sub-object>
							<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
							<attribute creation-mechanics="Model" name="list" type="object list">
								<object-list>
									<sub-object>
										<attribute creation-mechanics="Model" name="Channel Settings" type="compound" spectype="0">
											<sub-object>
												<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
												<attribute creation-mechanics="Model" name="list" type="object list">
													<object-list>
														<sub-object/>
													</object-list>
												</attribute>
											</sub-object>
										</attribute>
									</sub-object>
								</object-list>
							</attribute>
						</sub-object>
					</symbol>
				</symbol-map>
				<comments>
<![CDATA[
Specifies parameters used by 
the Wireless LAN Protocol 
(WLAN). WLAN is used as the 
MAC layer protocol in the 
surrounding node. 







]]>
				</comments>
				<count-properties name="count" type="integer">
					<properties type="integer" auto-assign="yes" symbolic-only="no">
						<default-value value="1"/>
						<lower-limit value="1" exclusive="no"/>
						<upper-limit value="1" exclusive="no"/>
						<comments>
<![CDATA[


]]>
						</comments>
					</properties>
				</count-properties>
				<list-properties name="list" type="object list">
					<properties type="object list" auto-assign="yes" symbolic-only="no">
						<object-list>
							<sub-object name="Data Rate" type="double">
								<properties type="double" units="bps" auto-assign="yes" symbolic-only="yes">
									<default-value value-symbol="11 Mbps"/>
									<symbol-map>
										<symbol name="1 Mbps" value="1,000,000"/>
										<symbol name="2 Mbps" value="2,000,000"/>
										<symbol name="5.5 Mbps" value="5,500,000"/>
										<symbol name="11 Mbps" value="11,000,000"/>
									</symbol-map>
									<comments>
<![CDATA[
1 Mbps, 2 Mbps, 5.5 Mbps and 
11 Mbps  data rates 
supported by the wlan model. 
   
]]>
									</comments>
								</properties>
							</sub-object>
							<sub-object name="Packet Reception-Power Threshold" type="double">
								<properties type="double" units="W" auto-assign="yes" symbolic-only="no">
									<default-value value="7.33E-14"/>
									<lower-limit value="0.0" exclusive="yes"/>
									<symbol-map>
										<symbol name="7.33E-14" value="7.33E-14"/>
									</symbol-map>
									<comments>
<![CDATA[
Defines the received power 
threshold value in Watts at the 
radio receiver for arriving WLAN 
packets. Packets with a power 
less than threshold considered as 
noise packets and they don't 
change the status of the receiver 
to "busy" from MAC's point of 
view, and don't turn on the 
signal lock at the receiver. 
These packets serve as 
interference source against the 
valid packets.

The packets with a power higher
than threshold are considered as 
valid packets. Unless the default 
transmission power is changed, 
all the WLAN packets should reach 
at their destinations with 
sufficient power to be a valid 
packet if the propagation 
distance between the source and 
destination is less than 300 
meters as required by IEEE 802.11 
WLAN standard.

The value of the "high threshold 
trigger" of the statwires between 
the radio receiver and the MAC 
module in the surrounding node 
model will be overwritten by the 
value of this attribute.

]]>
									</comments>
								</properties>
							</sub-object>
							<sub-object name="Channel Settings" type="compound">
								<properties type="compound" auto-assign="yes" symbolic-only="no">
									<default-value>
										<sub-object>
											<attribute creation-mechanics="Model" name="count" type="integer" value="1"/>
											<attribute creation-mechanics="Model" name="list" type="object list">
												<object-list>
													<sub-object/>
												</object-list>
											</attribute>
										</sub-object>
									</default-value>
									<comments>
<![CDATA[
In the wlan model there are 
4 transmitting and receiving 
channels. Each channel is 
associated with a data rate 
of (1, 2, 5,5, and 11 Mbps). 
The user can set the minimum 
frequency and the bandwidth 
of these channels. Note that 
these settings will be for 
all four channels because 
they belong to same station. 
   



]]>
									</comments>
									<count-properties name="count" type="integer">
										<properties type="integer" auto-assign="yes" symbolic-only="no">
											<default-value value="1"/>
											<lower-limit value="1" exclusive="no"/>
											<upper-limit value="1" exclusive="no"/>
											<comments>
<![CDATA[


]]>
											</comments>
										</properties>
									</count-properties>
									<list-properties name="list" type="object list">
										<properties type="object list" auto-assign="yes" symbolic-only="no">
											<object-list>
												<sub-object name="Bandwidth" type="double">
													<properties type="double" units="Khz" auto-assign="yes" symbolic-only="no">
														<default-value value="1,000"/>
														<lower-limit value="0.0" exclusive="no"/>
														<symbol-map>
															<symbol name="10" value="10"/>
														</symbol-map>
														<comments>
<![CDATA[
This attribute specifies the 
bandwidth of the channel. 







]]>
														</comments>
													</properties>
												</sub-object>
												<sub-object name="Min frequency" type="double">
													<properties type="double" units="MHz" auto-assign="yes" symbolic-only="no">
														<default-value value="2,405"/>
													</properties>
												</sub-object>
											</object-list>
										</properties>
									</list-properties>
								</properties>
							</sub-object>
							<sub-object name="Max Receive Lifetime" type="double">
								<properties type="double" units="secs" auto-assign="yes" symbolic-only="no">
									<default-value value-symbol="0.5"/>
									<lower-limit value="0.0" exclusive="yes"/>
									<symbol-map>
										<symbol name="0.5" value="0.5"/>
										<symbol name="1.0" value="1.0"/>
										<symbol name="1.5" value="1.5"/>
										<symbol name="2.0" value="2.0"/>
									</symbol-map>
									<comments>
<![CDATA[
Maximum time after the 
initial reception of the 
fragmented MSDU	after which 
further attempts to  
reassemble the MSDU will be 
terminated.	 
]]>
									</comments>
								</properties>
							</sub-object>
						</object-list>
					</properties>
				</list-properties>
			</properties>
		</attribute>
		<attribute name="Address" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="From MAC Intf"/>
				<lower-limit value="0" exclusive="no"/>
				<symbol-map>
					<symbol name="From MAC Intf" value="-2"/>
				</symbol-map>
				<comments>
<![CDATA[
MAC layer address of the 
surrounding node.  This 
address should be unique 
across all stations in the 
network. 

]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="Transmission Power" type="double">
			<properties type="double" auto-assign="no" symbolic-only="no">
				<default-value value="0.001"/>
			</properties>
		</attribute>
	</model-attributes>
	<simulation-attributes>
		<attribute name="debug_level" group="debug" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="yes">
				<default-value value-symbol="NO"/>
				<symbol-map>
					<symbol name="NO" value="0"/>
					<symbol name="LOW" value="1"/>
					<symbol name="MEDIUM" value="2"/>
					<symbol name="MAX" value="3"/>
				</symbol-map>
				<comments>
<![CDATA[

]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="RTS" group="cmac" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value-symbol="NO"/>
				<symbol-map>
					<symbol name="NO" value="-1"/>
				</symbol-map>
			</properties>
		</attribute>
		<attribute name="mac_layer" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="CMAC"/>
				<symbol-map>
					<symbol name="CMAC" value="1"/>
					<symbol name="IEEE80211" value="2"/>
				</symbol-map>
				<comments>
<![CDATA[
The CTR are activated (optimization 
in order to improve the capacity of 
convergecast networks) 
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="max_time_priv_mode" group="cmac" type="double">
			<properties type="double" auto-assign="no" symbolic-only="no">
				<default-value value="0.01"/>
				<comments>
<![CDATA[
The time during which a node 
remains privileged
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="beta" group="routing" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="no">
				<default-value value="4"/>
			</properties>
		</attribute>
		<attribute name="routing" group="routing" type="integer">
			<properties type="integer" auto-assign="no" symbolic-only="yes">
				<default-value value-symbol="KTREE"/>
				<symbol-map>
					<symbol name="KTREE" value="2"/>
					<symbol name="SHORT" value="1"/>
					<symbol name="NO" value="0"/>
				</symbol-map>
				<comments>
<![CDATA[
the routing algorihtm used in the MAC layer:
-KTREE: traffic is first forwarded to the closest ktree node, and then forwarded uniquely through the ktree-core
-short: shortest routes
-no: no mac routing is implemented (it has to be specified in the application layer)
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="nb_channels" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="no">
				<default-value value="1"/>
				<comments>
<![CDATA[
number of channels
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="ktree_algo" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="SYNC"/>
				<symbol-map>
					<symbol name="SYNC" value="1"/>
					<symbol name="MTree" value="2"/>
				</symbol-map>
				<comments>
<![CDATA[
The algorithm used to select the k-tree nodes:

SYNC: a SYNC packets is sent by the sink, with a maximum power. Any node receives this packet and records the reception power. The children will be chosen among the nodes with the minimum rx=power

MTree: firstly, a tree which maximizes the leaves is constructed. Then, we construct a node-disjoint k-tree core (i.e. selection of the k different branches which maximizes the number of descendants)
]]>
				</comments>
			</properties>
		</attribute>
		<attribute name="busy_tone" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="yes">
				<default-value value-symbol="NO"/>
				<symbol-map>
					<symbol name="YES" value="1"/>
					<symbol name="NO" value="0"/>
				</symbol-map>
			</properties>
		</attribute>
		<attribute name="nb_branches" group="cmac" type="integer">
			<properties type="integer" auto-assign="yes" symbolic-only="no">
				<default-value value="4"/>
				<comments>
<![CDATA[
The number of leaves for the k-tree core (in our case, the number of branches starting from the sink) 
]]>
				</comments>
			</properties>
		</attribute>
	</simulation-attributes>
	<attribute-assignments>
		<assignment attribute-name="Address" type="integer" status="promoted"/>
		<assignment attribute-name="Transmission Power" type="double" status="promoted"/>
		<assignment attribute-name="Wireless LAN Parameters" type="compound" status="promoted"/>
		<assignment attribute-name="begsim intrpt" type="toggle" status="hidden" value="1"/>
		<assignment attribute-name="doc file" type="string" status="hidden"/>
		<assignment attribute-name="endsim intrpt" type="toggle" status="hidden" value="1"/>
		<assignment attribute-name="failure intrpts" type="enumerated" status="hidden"/>
		<assignment attribute-name="intrpt interval" type="toggle double" status="hidden"/>
		<assignment attribute-name="priority" type="integer" status="hidden"/>
		<assignment attribute-name="recovery intrpts" type="enumerated" status="hidden"/>
		<assignment attribute-name="subqueue" type="compound" status="hidden">
			<sub-object>
				<attribute creation-mechanics="EMA" name="count" type="integer" value="4"/>
				<attribute creation-mechanics="EMA" name="list" type="object list">
					<object-list>
						<sub-object/>
						<sub-object/>
						<sub-object/>
						<sub-object/>
					</object-list>
				</attribute>
			</sub-object>
		</assignment>
		<assignment attribute-name="super priority" type="toggle" status="hidden"/>
	</attribute-assignments>
	<interfaces>
		<interface promoted-name="subqueue" type="compound" inherit-limits="yes" inherit-symbol-only="yes" inherit-comments="yes" inherit-units="yes" inherit-default-value="yes">
			<attribute-names>
<![CDATA[
subqueue
]]>
			</attribute-names>
			<properties type="compound" auto-assign="no" symbolic-only="no">
				<count-properties name="count" type="integer">
					<properties type="integer" auto-assign="no" symbolic-only="no">
						<default-value value="1"/>
					</properties>
				</count-properties>
				<list-properties name="list" type="object list">
					<properties type="object list" auto-assign="no" symbolic-only="no"/>
				</list-properties>
			</properties>
		</interface>
	</interfaces>
	<state-variables>
<![CDATA[
/* Station's own address */
int	\my_address;

/* The node must wait for a reply to its frame (CTS, ACK...) */
Boolean	\is_reply_required;

/* The reply to a frame is not what we expected */
/* -> consider that the frame has timeouted     */
Boolean	\is_reply_bad;

/* We sent a packet, and we had a valid reply */
/* (RTS -> CTS, or DATA->ACK...)              */
Boolean	\is_reply_received;

/* The next frame to send */
/*                        */
frame_struct	\next_frame_to_send;

/* The last frame that was transmitted */
frame_struct	\last_frame_sent;

/* The buffer containing all the unicast data frames we must send */
List*	\unicast_frame_buffer;

/* The buffer containing all the multicast data frames we must send */
List*	\multicast_frame_buffer;

/* Used in storing data rate attribute. This is the rate at which	 */
/* data frame is transmitted.										                            */
double	\operational_speed;

/* Is this node part of the ktree? */
Boolean	\is_in_ktree;

/* Has this node the priority to send all its data packets */
/* (it received a CTR from its parent)                     */
Boolean	\is_node_privileged;

/* Is the node a sink ? */
Boolean	\is_sink;

/* The neighborhood table */
List*	\my_neighborhood_table;

/* Number of channels to use */
int	\nb_channels;

/* The transmitter is busy, i.e. a frame is transmitted */
Boolean	\is_tx_busy;

/* current power transmission for my main radio */
double	\my_current_tx_power;

/* the receive is busy, i.e. a frame has been transmitted by a neighbor */
Boolean	\is_rx_busy;

/* The power above we consider the channel is busy */
double	\rx_power_threshold;

/* The power of the last received SYNC frame */
/* in 1E-14 W                                */
double	\my_sync_rx_power;

/* The list of the nodes which reserved the medium             */
/* We can have several reservations in a multi-channel network */
List*	\my_nav_list;

/* my max backoff */
int	\cw;

/* My current backoff value */
int	\my_backoff;

/* The interruption for the backoff (can be stopped by a medium activity) */
Evhandle	\backoff_intrpt;

/* When did I become privileged ? */
double	\time_start_privileged;

/* The timeout interruption */
Evhandle	\frame_timeout_intrpt;

/* The interruption which triggers a timeout if the frame was not received */
Evhandle	\timeout_intrpt;

/* The interruption which triggers a return to the main frequency */
Evhandle	\main_freq_return_intrpt;

/* the debug level for the simulations */
int	\DEBUG;

/* The interruption for stop defering */
Evhandle	\defer_intrpt;

/* The next branch which will be polled by the sink */
/* (with a CTR)                                     */
int	\ctr_last_branch;

/* The rx_power of the last received transmission    */
/* (just before the rx_module leaves its busy state) */
double	\last_rx_power;

/* The frequency for my main radio (in Khz) */
double	\my_main_frequency;

/* The bandwidth for my main radio (in KHz) */
double	\my_main_bandwidth;

/* I am currently receiving a busy tone signal */
Boolean	\is_busy_tone_rx;

/* the speed for the busy tone channel */
double	\busy_tone_speed;

/* I must maintain the busy tone transmission */
Boolean	\is_busy_tone_tx;

/* The busy tone is activated in reception                             */
/* But we do not care: the destination itself maintains this busy tone */
/* (or we believe that)                                                */
Boolean	\busy_tone_rx_ignored;

/* Is the busy tone channel used ? */
Boolean	\BUSY_TONE_ACTIVATED;

/* The debug file (perso) */
FILE*	\my_debug_file;

/* local identification of the node                    */
/* (id which has no signification outside the process) */
int	\my_stat_id;

/* Must an hello to be transmitted ? */
Boolean	\is_hello_to_send;

/* The list of frame_id already received */
List*	\my_frame_id_seen;

/* My mac layer protocol */
int	\MAC_LAYER;

/* ktree nodes are allowed to send packets only when they are privileged */
Boolean	\strict_privileged_mode;

/* IS the directional antenna activated for the SYNC ? */
int	\is_sync_direct_antenna;

/* The branch pointed by the last SYNC frame */
int	\sync_last_branch;

/* My branch number (if I identified it) */
int	\my_branch;

/* The frequency used for my current transmissions */
double	\my_privileged_frequency;

/* The time during which a node remains privileged */
double	\slot_privileged_duration;

/* Offset time before I received the CTR from my parent */
double	\slot_privileged_offset;

/* The list of my children in the ktree */
List*	\my_ktree_children;

/* BETA interference range */
int	\BETA;

/* A RTS/CTS is required gor longer packets (OPC_INT_INFINITY -> never required) */
int	\RTS_PK_SIZE;

/* Type of routing in the MAC layer */
int	\MAC_ROUTING;

/* transmission power */
double	\POWER_TX;

/* The distribution lav for backoff values */
Distribution *	\backoff_dist;

/* the algo I am executing to form the ktree-core */
int	\KTREE_ALGO;

/* the number of branches for the tree of cMAC */
int	\NB_BRANCHES;

/* Information about the tree rooted at the sink: */
/* -parent                                        */
/* -distance to the sink                          */
/* -size of my subtree (descendant + myself)      */
sink_tree_struct	\my_sink_tree;

]]>
	</state-variables>
	<header-block>
<![CDATA[
/*
 *  cmac_process.c
 *  
 *  Created by Fabrice Theoleyre on 29/09/09.
 *  Copyright 2009 CNRS / LIG. All rights reserved.
 *
 */


#include	"cmac_process.h"
#include	"cmac_tools.h"
#include	"cmac_interface.h"



//-----------------------------------------------
//				SPECIAL DEBUG
//-----------------------------------------------

#define		DEBUG_STATE_MACHINE				OPC_FALSE




//-----------------------------------------------
//				STREAM & STAT
//-----------------------------------------------

#define		STREAM_TO_UP					5
#define		STREAM_FROM_UP					5

#define		STREAM_TO_RADIO					0
#define		STREAM_FROM_RADIO				0

#define		STREAM_TO_BUSY_TONE				1
#define		STREAM_FROM_BUSY_TONE			1

#define		STREAM_TO_DIRECT_SYNC			2


#define		STAT_FROM_RX					0
#define		STAT_FROM_TX					1

#define		STAT_FROM_RX_BUSY_TONE			2
#define		STAT_FROM_TX_BUSY_TONE			3

#define		STAT_FROM_TX_DIREC_SYNC			4







//-----------------------------------------------
//		   	WLAN_SUPPORT.h
//-----------------------------------------------

// Define the WLAN global variables, which are declared in wlan_support.h.

// Global linked list of AP position info
WlanT_AP_Position_Info* 			global_ap_pos_info_head = OPC_NIL;

// Global variable to keep note of the nature of the subnet
// This variable is initialized to not set
WlanT_Bss_Identification_Approach	bss_id_type = WlanC_Not_Set;

// Read-only array of the minimum frequencies of the 12 operational 802.11a
// WLAN channels.
double	WLANC_11a_CHNL_MIN_FREQ_ARRAY [WLANC_11a_OPER_CHNL_COUNT] = 
			{5170.0, 5190.0, 5210.0, 5230.0, 5250.0, 5270.0, 5290.0, 5310.0, 5735.0, 5755.0, 5775.0, 5795.0};

// Read-only arrays for mandatory 802.11a and 802.11g data rates.
double	WLANC_11a_MANDATORY_DRATE_ARRAY [3] = {24000000.0, 12000000.0, 6000000.0};
double	WLANC_11g_MANDATORY_DRATE_ARRAY [7] = {24000000.0, 12000000.0, 11000000.0, 6000000.0, 5500000.0, 2000000.0, 1000000.0};

// Reset one of the packet field index global variables so its value can be
// checked to determine whether all of those variables are initialized or not
int		WLANC_DATA_TYPE_FD = OPC_FIELD_INDEX_INVALID;
int		WLANC_DATA_HEADER_FD, WLANC_DATA_QOS_FD, WLANC_DATA_BODY_FD, WLANC_DATA_ACCEPT_FD, WLANC_DATA_PKID_FD;
int		WLANC_CNTL_TYPE_FD, WLANC_CNTL_HEADER_FD, WLANC_CNTL_BA_FD, WLANC_CNTL_ACCEPT_FD;
int		WLANC_BEACON_BODY_FD;
int 	WLANC_ACT_MGMT_CAT_ACT_FD, WLANC_ACT_MGMT_TID_FD, WLANC_ACT_MGMT_PARAMS_FD;






//-----------------------------------------------
//		   	INTERRUPTIONS
//-----------------------------------------------

#define		PK_FROM_UPPER					((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() == STREAM_FROM_UP))
#define		PK_FROM_LOWER					((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() != STREAM_FROM_UP))



//We received a frame
#define		IS_FRAME_RECEIVED				((op_intrpt_type() == OPC_INTRPT_STRM) && (op_intrpt_strm() == STREAM_FROM_RADIO))


//We answer to a received frame (we are in backoff and we receive a frame -> whatever the frame was, we must reply (with a CTS, ACK...)
//NB: we reply only if we are not in communication (bu such a case does not exist since a backoff is not required when a flow is already initiated)
#define		IS_REPLY_TO_SEND				((get_nav_main_freq() <= op_sim_time()) && (!is_reply_required))


//Frame to received (acak, cts...) -> timeout	
#define		IS_FRAME_TIMEOUT				((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == FRAME_TIMEOUT_CODE))


//Is the medium busy ? (transmission / reception / reservation)
#define		IS_MEDIUM_BUSY					((is_rx_busy) || (is_tx_busy) || (get_nav_main_freq() >= op_sim_time()) || ((is_busy_tone_rx && !busy_tone_rx_ignored && BUSY_TONE_ACTIVATED) && (!is_in_ktree)))


//We must defer in any of these conditions: 
//- a CTR msut be transmitted 
//- a packet was received and we must reply (ACK, CTS, CTR...) 
//- the medium is busy (We must get another backoff) 
#define		IS_BACK_TO_DEFER				((next_frame_to_send.type == CTR_PK_TYPE) || (IS_FRAME_RECEIVED && IS_REPLY_TO_SEND))


//We must transmit one packet: our data buffer is not empty OR we have already prepared a frame to send
#define		IS_DATA_OK						((!strict_privileged_mode) || (is_hello_to_send && !IS_BROADCAST_FORBIDDEN) || !is_in_ktree || is_node_privileged || is_sink)
#define		IS_PK_TO_SEND					((IS_DATA_OK && !is_frame_buffer_empty()) || (next_frame_to_send.type != NO_PK_TYPE))




//The mode privileged is finished !
// -> The node must become unprivileged
// -> Or we have no more data frames to send, and we remained privileged for a sufficiently long time
//
//	NB: if we receive PRIVILEGED_MAX_CODE after becoming a unpriviledge mode, nothing happens
//		and two privileged modes are sufficiently inter spaced so that no problem occurs 
//		the sink sends CTR with a period largely superior to PRIVILEGED_MAX_TIME (PRIVILEGED_MAX_TIME * NB_BRANCH * BETA)
//		Moreover, we have a second verification after having received a PRIVILEGED_MAX_CODE
//
#define		PRIVILEGED_END					(PRIVILEGED_MEDIUM_LIMIT || PRIVILEGED_HIGH_LIMIT)

#define		END_PRIV_SLOT					(time_start_privileged + slot_privileged_duration - slot_privileged_offset <= op_sim_time())
#define		END_PRIV_INTRPT					((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == PRIVILEGED_MAX_CODE))

#define		PRIVILEGED_MEDIUM_LIMIT			((is_node_privileged) && (is_frame_buffer_empty()) && (time_start_privileged + slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO <= op_sim_time()))
#define		PRIVILEGED_HIGH_LIMIT			((is_node_privileged) && (END_PRIV_SLOT || END_PRIV_INTRPT))


#define		MAIN_FREQ_RETURN				((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == MAIN_FREQ_RETURN_CODE))


//No frame to send
#define		NO_FRAME						(next_frame_to_send.type == NO_PK_TYPE)


//this node has the priority to sends its packets
#define		IS_NODE_PRIO					((next_frame_to_send.type == CTS_PK_TYPE) || (next_frame_to_send.type == ACK_PK_TYPE) || (next_frame_to_send.type == DATA_UNICAST_PK_TYPE))


//Collision: we have the priority to send a reply, but the medium is busy (another node is not aware of the current communicaiton)
#define		PRIORITY_AND_MEDIUM_BUSY		((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE) && (IS_MEDIUM_BUSY) && (IS_NODE_PRIO))


//transmission canceled from the DEFER state (no frame to send, or a collision occured
#define		TRANSMISSION_CANCELED			(NO_FRAME || PRIORITY_AND_MEDIUM_BUSY)


//I will backoff
#define		GO_TO_BACKOFF					((!TRANSMISSION_CANCELED) && (!IS_MEDIUM_BUSY) && (my_backoff > 0))


//I will directly send one packet
#define		GO_TO_SEND						((!TRANSMISSION_CANCELED) && (!IS_MEDIUM_BUSY) && (my_backoff == 0))


//I can send one BROADCAST frame -> other nodes will receive it
//Special case: the source is the sink (I can send a packet even if I am not privileged (I am never))
#define		IS_BROADCAST_FORBIDDEN			0
//((!is_node_privileged && is_in_ktree && !is_sink && (nb_channels == 1)) || (is_nav_for_other_freq()) || (!is_main_freq_active(STREAM_TO_RADIO)))
//TAG







//-----------------------------------------------
//		   	INTERRUPTION CODES
//-----------------------------------------------


//A frame has timeouted -> no ACK/CTS received
#define		FRAME_TIMEOUT_CODE				1


//The sink must generate a CTR
#define		SINK_CTR_CODE					2


//The node must wait the interframe time berfore the transmission
#define		DEFER_CODE						3


//A CTR packet has to be sent
#define		CTR_PK_CODE						4


//A Hello packet has to be sent
#define		HELLO_PK_CODE					5


//The backoff interruption
#define		BACKOFF_CODE					6


//Verification of timeouts in the neighborhood_table
#define		NEIGHBOR_TIMEOUT_CODE			7


//A nav is expired -> unblock potential transmissions
#define		NAV_END_CODE					8


//The node must become unprivileged
#define		PRIVILEGED_MIN_CODE				9
//The node should become unprivileged if its data buffer is empty
#define		PRIVILEGED_MAX_CODE				10


//The code to generate a sync frame
#define		SINK_SYNC_CODE					11


//The periodical deletion of frame_ids
#define		FRAME_ID_TIMEOUT_CODE			12


//I must return to my main frequency
#define		MAIN_FREQ_RETURN_CODE			13





//-----------------------------------------------
//		   DEBUG FILES
//-----------------------------------------------

//Common -> but no pb since no concurrent execution (discrete event simulator)
FILE	*debug_files[20];
int		cmac_timestamp = 0;

//Number of nodes
int		nb_mac_nodes = 0;




//-----------------------------------------------
//					SHARED VARIABLES
//-----------------------------------------------

int		global_frame_id 	= 0;
int		MAX_BRANCH_LENGTH 	= 0;
double 	TIME_MAX_PRIVILEGED;
int		*nodeid_to_addr_var = NULL;
]]>
	</header-block>
	<function-block>
<![CDATA[

//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------
//---------------------------								  ---------------------------
//---------------------------			COMMON			      ---------------------------
//---------------------------								  ---------------------------
//---------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------






//-----------------------------------------------------------
//
//					PARAMETERS
//
//-----------------------------------------------------------

//returns the nb of nodes in the network
int get_nb_nodes(){
	FIN(get_nb_nodes());
	
	FRET(nb_mac_nodes);
}



//nodeid to mac address
int nodeid_to_addr(int nodeid){
	FIN(nodeid_to_addr(int nodeid));
	
	if ((nodeid < 0) || (nodeid > get_nb_nodes())){
		printf("this node id does not exist (%d). Probably a bug\n", nodeid);
		FRET(ADDR_INVALID);
	}
	
	FRET(nodeid_to_addr_var[nodeid]);
}


//mac address to node id
int addr_to_nodeid(int addr){
	FIN(addr_to_nodeid(int addr));
	int		nb_nodes = get_nb_nodes();
	int		i;
	
	for(i=0; i<nb_nodes; i++)
		if (nodeid_to_addr_var[i] == addr)
			FRET(i);
	
	FRET(ADDR_INVALID);
}


//-----------------------------------------------------------
//
//					FRAME TIMEOUTS
//
//-----------------------------------------------------------

//Adds a timeout interruption
//NB : i have a blocking state -> I do not send any other packet until either I received the reply or the frame timeouts
void add_frame_timeout(double data_pk_size){
	FIN(add_frame_timeout(double data_pk_size));

	//error, the timeout interruption was not canceled !
	op_ev_cancel_if_pending(timeout_intrpt);
	if (op_ev_valid(timeout_intrpt))
		op_sim_end("A timeout interruption must be canceled when the reply is received" , "Please correct this bug", "" , "");

	//adds a timeout interruption
	timeout_intrpt = op_intrpt_schedule_self(op_sim_time() + 2*SIFS + 2*PROPAGATION_DELAY + (double)data_pk_size/operational_speed, FRAME_TIMEOUT_CODE);
	
	//debug
	debug_print(MAX , DEBUG_TIMEOUT , "adds a timeout for %fus\n", 1E6 * (2*SIFS + 2*PROPAGATION_DELAY + (double)data_pk_size/operational_speed) );

	FOUT;
}









//-----------------------------------------------------------
//
//					ANTENNAS & BUSY TONE
//
//-----------------------------------------------------------


//Changes the radio power for tranmissions
void change_tx_power(double power , int stream){
	FIN(change_tx_power(double power , int stream));
	
	//id
	int			tx_id , chan_id , sub_chan_id;
	int			num_chan;
	int			i;
	
	//gets the id of the tansmitter + channel attributes
	tx_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	op_ima_obj_attr_get (tx_id, "channel", &chan_id);

	//Sets the channel attributes
	//NB: I have normally one single channel, but .....
	num_chan = op_topo_child_count(chan_id, OPC_OBJTYPE_RATXCH);		
	for(i=0 ; i<num_chan ; i++){
		sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
		op_ima_obj_attr_set (sub_chan_id, "power", power);
	}

	debug_print(LOW , DEBUG_RADIO , "New power transmission %f\n", power);
	
	FOUT;
}


//returns true if we are focused on the main channel
Boolean is_main_freq_active(int stream){
	FIN(is_main_freq_active(int stream));

	int			radio_id , chan_id , sub_chan_id;
	double		frequency;
	

	//Gets only transmitter value (the receiver value is identical, or there is a big trouble !)
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_get (sub_chan_id, "min frequency", 	&frequency);
	
	FRET(frequency == my_main_frequency);
}

//Changes the radio power for tranmissions
void change_tx_rx_freq(double frequency , double bandwidth , int stream){
	FIN(change_tx_rx_freq(double frequency , double bandwidth , int stream));
	
	int		radio_id , chan_id , sub_chan_id;
	double	old_freq;
	
	//------------ TRANSMISSION -----------
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RATXCH, 0);
	op_ima_obj_attr_get (sub_chan_id, "min frequency", 	&old_freq);
	op_ima_obj_attr_set (sub_chan_id, "bandwidth", 		bandwidth);
	op_ima_obj_attr_set (sub_chan_id, "min frequency", 	frequency);
	
	

	//------------ RECEPTION -----------
	radio_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_IN , OPC_OBJTYPE_RARX , stream);
	op_ima_obj_attr_get (radio_id, "channel", &chan_id);
	sub_chan_id = op_topo_child (chan_id, OPC_OBJTYPE_RARXCH, 0);
	op_ima_obj_attr_set (sub_chan_id, "bandwidth", 		bandwidth);
	op_ima_obj_attr_set (sub_chan_id, "min frequency", 	frequency);

	if (frequency != old_freq){
		debug_print(LOW , DEBUG_RADIO , "new bandwidth %f and frequency %f (main %f/%f)\n", bandwidth , frequency , my_main_bandwidth , my_main_frequency);
		debug_print(LOW , DEBUG_NODE , "new bandwidth %f and frequency %f (main %f/%f)\n", bandwidth , frequency , my_main_bandwidth , my_main_frequency);
	}
	
	FOUT;
}



//Changes the radio power for tranmissions
void change_antenna_direction(int stream , int branch){
	FIN(change_antenna_direction(int stream , int branch));
	
	int			antenna_id;
	int			tx_id;
	double		theta;
	double		x , y;
	
	//Transmitter id (I am connected via a stream to it)
	tx_id 		= op_topo_assoc(op_id_self() , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_RATX , stream);
	
	//One single antenna per transmitter
	antenna_id	= op_topo_assoc(tx_id , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_ANT , 0);
	
	
	//Direction
	theta = 2 * PI * branch / NB_BRANCHES;
	x = cos(theta);
	y = sin(theta);

	//and point it
	op_ima_obj_attr_set (antenna_id, "target latitude", 	x);
	op_ima_obj_attr_set (antenna_id, "target longitude", 	y);

	debug_print(LOW , DEBUG_RADIO , "New direction for the antenna: %f\n", theta);
	
	FOUT;
}




//sends a packet to the busy tone radio (to maintain a busy state)
void maintain_busy_tone(double time){
	FIN(maintain_busy_tone(double time));
	
	Packet	*pkptr;

	//Create a packet with the required size (in bits)
	pkptr = op_pk_create(busy_tone_speed * time);
	debug_print(LOW , DEBUG_RADIO , "new busy tone for %fs (packet size %f bits)\n", time , op_pk_total_size_get(pkptr));

	//transmission
	op_pk_send(pkptr , STREAM_TO_BUSY_TONE);	
	
	FOUT;
}












//-----------------------------------------------------------
//
//			 NAV (Network Allocation Vector)
//
//-----------------------------------------------------------


//Prints the list of current NAV
void print_nav_list(int debug_type){
	FIN(print_nav_list(int debug_type));
	
	int			i;
	nav_struct	*ptr;

	
	debug_print(LOW , debug_type , "-----------------------------------------\n");
	debug_print(LOW , debug_type , "		NAV LIST (%f)\n", op_sim_time());
	debug_print(LOW , debug_type , "-----------------------------------------\n");
	debug_print(LOW , debug_type , "\n");
	
	debug_print(LOW , debug_type , "    ADDR	|	FREQ		|	TIMEOUT\n");
	
	for (i=0 ; i< op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		debug_print(LOW , debug_type , "%8d	|	%3f	|	%f\n", ptr->address , ptr->frequency , ptr->timeout);
	}
	FOUT;
}

//Deletes obsolete nav
void delete_timeouted_nav(void * arg, int code){
	FIN(delete_timeouted_nav(void * arg, int code));
	
	int				i;
	nav_struct		*ptr;
	double			older_entry = 0;
	
	//Walks in the list
	for(i= op_prg_list_size(my_nav_list)-1 ; i>= 0 ; i--){
		ptr = op_prg_list_access(my_nav_list , i);
		
		//Timeouted entry !
		if (ptr->timeout <= op_sim_time()){
			debug_print(LOW , DEBUG_BACKOFF , "NAV from %d deleted\n", ptr->address);
			
			ptr = op_prg_list_remove(my_nav_list , i);
			op_prg_mem_free(ptr);
		}
		
		//updates the time for the older entry
		else if ((older_entry > ptr->timeout) || (older_entry == 0))
			older_entry = ptr->timeout;
	}
	
	
	//Next verification
	if (older_entry != 0)
		op_intrpt_schedule_call(older_entry , 0 , delete_timeouted_nav , NULL);
	FOUT;
}


//adds a medium reservation
void add_nav(int src, double duration , double frequency){
	FIN(add_nav(int src, double duration , double frequency));
	
	nav_struct	*ptr;
	int			i;
	
	//Deletes timeouts
	if (op_prg_list_size(my_nav_list) == 0)
		op_intrpt_schedule_call(op_sim_time() + duration , 0 , delete_timeouted_nav , NULL);
	
	//Updates the entry if one already exists
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->address == src) && (ptr->frequency == frequency)){
			ptr->timeout = op_sim_time() + duration;
	
			debug_print(LOW , DEBUG_BACKOFF , "NAV updated, src %d, duration %fus\n", src , duration * 1E6);			
			FOUT;
		}
	}
	
	//Adds one new element
	ptr = op_prg_mem_alloc(sizeof(nav_struct));
	ptr->address 	= src;
	ptr->frequency	= frequency;
	ptr->timeout 	= op_sim_time() + duration;
	op_prg_list_insert(my_nav_list, ptr , OPC_LISTPOS_TAIL);
	
	debug_print(LOW , DEBUG_BACKOFF , "NAV added, src %d, duration %fus\n", src , duration * 1E6);
	FOUT;
}



//updates the nav
void update_nav_time(double transmission_time, int source , double frequency , int pk_size){
	FIN(update_nav_time(double transmission_time, int source , double frequency , int pk_size));
		
	//No real reservation
	if (transmission_time <= 0){
		debug_print(LOW , DEBUG_BACKOFF , "NAV ! UPDATED -> src %d, duration %fus, pk_size %d\n", source , transmission_time * 1E6 , pk_size);
		FOUT;
	}

	//Stores the NAV duration
	add_nav(source , transmission_time , frequency);
					
	//Schedules the end of the NAV	
	op_intrpt_schedule_self(op_sim_time() + transmission_time , NAV_END_CODE);
	
	
	debug_print(LOW , DEBUG_BACKOFF , "NAV -> src %d, duration %fus, pk_size %d\n", source , transmission_time * 1E6 , pk_size);
	FOUT;
}


//Returns TRUE if a reservation was registered for another frequency
Boolean is_nav_for_other_freq(){
	FIN(is_nav_for_other_freq());
	
	int			i;
	nav_struct	*ptr;
	
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > op_sim_time()) && (ptr->frequency != my_main_frequency))
			FRET(OPC_TRUE);
	}
	
	FRET(OPC_FALSE);
}

//Returns the longest NAV for the main frequency
double get_nav_main_freq(){
	FIN(get_nav_main_freq());
	
	int			i;
	nav_struct	*ptr;
	double		timeout = 0;
	
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > timeout) && (ptr->frequency == my_main_frequency))
			timeout = ptr->timeout;
	}
	
	FRET(timeout);
}


//Is the medium free to reply to addr ? (i.e. no other node has already reserved this frequency ?
Boolean is_reply_possible(int addr , double frequency){
	FIN(is_reply_possible(int addr , double frequency));
	
	int			i;
	nav_struct	*ptr;
	
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > op_sim_time()) && (ptr->frequency == frequency) && (ptr->address != addr))
			FRET(OPC_FALSE);
	}
	
	FRET(OPC_TRUE);
}


//The destination is available for reception (no NAV for any frequency)
Boolean is_destination_available(int destination){
	FIN(is_destination_available(int destination));

	int			i;
	nav_struct	*ptr;
	
	for(i=0 ; i < op_prg_list_size(my_nav_list) ; i++){
		ptr = op_prg_list_access(my_nav_list , i);
		
		if ((ptr->timeout > op_sim_time()) && (ptr->address == destination))
			FRET(OPC_FALSE);
	}
	FRET(OPC_TRUE);
}





//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												QUEUE MANAGEMENT										  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------








//-----------------------------------------------------------
//
//					DUPLICATA DETECTION
//
//-----------------------------------------------------------


//Deletes the frame_id which became obsolete
void del_timeouted_frame_id(void* tot , int code){
	FIN(del_timeouted_frame_id(void* tot , int code));
	
	int						i;
	id_timeout_struct		*ptr;
		
	//Walks in the list
	for(i= op_prg_list_size(my_frame_id_seen)-1 ; i>= 0 ; i--){
		ptr = op_prg_list_access(my_frame_id_seen , i);
		
		//Timeouted entry !
		if (ptr->timeout <= op_sim_time()){
			ptr = op_prg_list_remove(my_frame_id_seen , i);
			op_prg_mem_free(ptr);
		}
	}
	
	
	//Next verification
	if (op_prg_list_size(my_frame_id_seen) != 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_FRAME_ID , FRAME_ID_TIMEOUT_CODE , del_timeouted_frame_id , NULL);

	FOUT;
}


//Is thie frame_id already in the list ?
Boolean is_frame_id_seen(int frame_id){
	FIN(is_frame_id_seen(int frame_id));
	
	id_timeout_struct		*ptr;
	int						i;
	
	FRET(OPC_FALSE);
	
	for(i=0 ; i < op_prg_list_size(my_frame_id_seen) ; i++){
		ptr = op_prg_list_access(my_frame_id_seen , i);
		
		if (ptr->id == frame_id)
			FRET(OPC_TRUE);
	}
	
	FRET(OPC_FALSE);
}



//adds the frame_id as already seen
void add_frame_id_seen(int frame_id){
	FIN(add_frame_id_seen(int frame_id));
	
	id_timeout_struct		*ptr;
	
	FOUT;
	
	//the frame id is already in the list
	if (is_frame_id_seen(frame_id))
		FOUT;
	
	//Empty list -> timeouted verificaiton
	if (op_prg_list_size(my_frame_id_seen) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_FRAME_ID , FRAME_ID_TIMEOUT_CODE , del_timeouted_frame_id , NULL);
	
	//New entry
	ptr = op_prg_mem_alloc(sizeof(id_timeout_struct));
	ptr->id			= frame_id;
	ptr->timeout	= op_sim_time() + TIMEOUT_FRAME_ID;
	op_prg_list_insert(my_frame_id_seen , ptr , OPC_LISTPOS_TAIL);
	
	FOUT;
}








//-----------------------------------------------------------
//
//					UNICAST FRAME BUFFER
//
//-----------------------------------------------------------

//increments the number of retransmissions for the corresponding frame_id
void increment_nb_rety_unicast_frame_buffer(int id){
	FIN(increment_nb_rety_unicast_frame_buffer(int id));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;
	
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == id){
		
			ptr->nb_retry++;
			
			if (ptr->nb_retry == MEDIUM_NB_RETRY){
				ptr->time_transmission_min = op_sim_time() + TIME_MAX_PRIVILEGED * 2;
			}
			
			//Verify that we dont have too many retransmissions
			if (ptr->nb_retry >= MAX_NB_RETRY){
				debug_print(LOW, DEBUG_DATA , "the unicast frame to %d was not acknowledged and we have too many retransmissions -> DELETED (type %s, id %d)\n",  ptr->destination , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
				debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d was not acknowledged and we have too many retransmissions -> DELETED (type %s, id %d)\n",  ptr->destination , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
				
				
				ptr = op_prg_list_remove(unicast_frame_buffer , i);
				if (ptr->payload != NULL)
					op_pk_destroy(ptr->payload);
				op_prg_mem_free(ptr);
			}
			else
				debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d was not acknowledged -> RETRANSMISSION (nb retry %d type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		}
	}
	FOUT;
}


//Deletes the data which were timeouted
void del_timeouted_unicast(void *arg, int code){
	FIN(del_timeouted_unicast(void *arg, int code));
	
	frame_struct	*ptr;
	int				i;
	char			msg[100];
	double			older_entry = -1;
	
	for(i=op_prg_list_size(unicast_frame_buffer) - 1 ; i >=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);
		
		//timeouted entry
		if (ptr->time_added <= op_sim_time() - TIMEOUT_DATA_FRAME){
			
			debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(unicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
		
		//next verification
		else if ((older_entry > ptr->time_added + TIMEOUT_DATA_FRAME) || (older_entry == -1))
			older_entry = ptr->time_added + TIMEOUT_DATA_FRAME;
	}

	if (older_entry != -1)
		op_intrpt_schedule_call(op_sim_time() + older_entry , 0 , del_timeouted_unicast , NULL);
	FOUT;
}


//adds a (data) frame to send
void add_in_unicast_frame_buffer(frame_struct frame_tmp , int position){
	FIN(add_in_unicast_frame_buffer(frame_struct frame_tmp , int position));
	
	//Frame buffer
	frame_struct	*ptr;
		
	//Error
	if ((frame_tmp.type != DATA_UNICAST_PK_TYPE) && (frame_tmp.type != DATA_MULTICAST_PK_TYPE) && (frame_tmp.type != HELLO_PK_TYPE))
		op_sim_end("It is not possible to add a control frame" , "in the buffer of data unicast frame to send", "" , "");
	
	
	//Timeouts
	if (op_prg_list_size(unicast_frame_buffer) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_DATA_FRAME , 0 , del_timeouted_unicast , NULL);

	
	//Memory allocation + insertion in the buffer
	ptr = op_prg_mem_alloc(sizeof(frame_struct));
	*ptr  = frame_tmp;	
	op_prg_list_insert(unicast_frame_buffer , ptr , position);
	
	debug_print(MEDIUM , DEBUG_DATA , "a unicast frame to %d (id %d) was added in the buffer\n", frame_tmp.destination , frame_tmp.frame_id);
	
	FOUT;
}


//returns the nb of data frames to send
int get_unicast_frame_buffer_size(){
	FIN(get_unicast_frame_buffer_size());
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time())
			nb++;
	}
	
	FRET(nb);
}


//Must data frame be transmitted ?
Boolean is_unicast_frame_buffer_empty(){
	FIN(is_unicast_frame_buffer_empty());
	FRET(get_unicast_frame_buffer_size() == 0);
}


//returns the first data frame to send
frame_struct *get_unicast_frame_buffer(int pos){
	FIN(get_unicast_frame_buffer(int pos));
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time()){
			if (pos == nb)
				FRET(ptr);
			nb++;
		}
	}
	
	FRET(NULL);
}


//Prints the content of the data frame buffer
void print_unicast_frame_buffer(int debug_type){
	FIN(print_unicast_frame_buffer(int debug_type));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;

	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "			Unicast Frame Buffer of %d (size %d)\n" , my_address , op_prg_list_size(unicast_frame_buffer));
	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "	DEST	|	TYPE		| 	ID		|	NB_RETRY	|	MIN_TRANSMISSION\n");


	
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		debug_print(LOW , debug_type , "%5d	|	%s	|	%d		|	%d		|	%f\n", ptr->destination ,  pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id , ptr->nb_retry , ptr->time_transmission_min);
	}
	FOUT;
}




//-----------------------------------------------------------
//
//					MULTICAST FRAME BUFFER
//
//-----------------------------------------------------------


//Deletes the multicast frames which were timeouted
void del_timeouted_multicast(void *arg, int code){
	FIN(del_timeouted_multicast(void *arg, int code));
	
	frame_struct	*ptr;
	int				i;
	char			msg[100];
	double			older_entry = -1;
	
	for(i=op_prg_list_size(multicast_frame_buffer) - 1 ; i >=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);
		
		//timeouted entry
		if (ptr->time_added <= op_sim_time() - TIMEOUT_DATA_FRAME){
			
			debug_print(LOW, DEBUG_TIMEOUT , "the multicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
			debug_print(LOW, DEBUG_NODE , "the multicast frame to %d was DELETED after its timeout (nb_retry %d, type %s, id %d)\n",  ptr->destination , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(multicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
		
		//next verification
		else if ((older_entry > ptr->time_added + TIMEOUT_DATA_FRAME) || (older_entry == -1))
			older_entry = ptr->time_added + TIMEOUT_DATA_FRAME;
	}

	if (older_entry != -1)
		op_intrpt_schedule_call(op_sim_time() + older_entry , 0 , del_timeouted_multicast , NULL);
	FOUT;
}


//adds a (data) frame to send
void add_in_multicast_frame_buffer(frame_struct frame_tmp , int position){
	FIN(add_in_multicast_frame_buffer(frame_struct frame_tmp , int position));
	
	//Frame buffer
	frame_struct	*ptr;
		
	//Error
	if ((frame_tmp.type != DATA_MULTICAST_PK_TYPE) && (frame_tmp.type != HELLO_PK_TYPE))
		op_sim_end("It is not possible to add a control frame" , "in the buffer of data frame to send", "" , "");
	
	
	//Timeouts
	if (op_prg_list_size(multicast_frame_buffer) == 0)
		op_intrpt_schedule_call(op_sim_time() + TIMEOUT_DATA_FRAME , 0 , del_timeouted_multicast , NULL);

	
	//Memory allocation + insertion in the buffer
	ptr = op_prg_mem_alloc(sizeof(frame_struct));
	*ptr  = frame_tmp;	
	op_prg_list_insert(multicast_frame_buffer , ptr , position);
	
	debug_print(MEDIUM , DEBUG_DATA , "a multicast frame to %d (id %d) was added in the buffer\n", frame_tmp.destination , frame_tmp.frame_id);

	FOUT;
}


//returns the nb of data frames to send
int get_multicast_frame_buffer_size(){
	FIN(get_multicast_frame_buffer_size());
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time())
			nb++;
	}
	
	FRET(nb);
}


//Must data frame be transmitted ?
Boolean is_multicast_frame_buffer_empty(){
	FIN(is_multicast_frame_buffer_empty());
	FRET(get_multicast_frame_buffer_size() == 0);
}


//returns the first data frame to send
frame_struct *get_multicast_frame_buffer(int pos){
	FIN(get_multicast_frame_buffer(int pos));
	
	frame_struct	*ptr;
	int				i;
	int				nb = 0;

	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->time_transmission_min < op_sim_time()){
			if (pos == nb)
				FRET(ptr);
			nb++;
		}
	}
	
	FRET(NULL);
}



//Prints the content of the data frame buffer
void print_multicast_frame_buffer(int debug_type){
	FIN(print_multicast_frame_buffer(int debug_type));
	
	//Frame buffer
	frame_struct	*ptr;
	//info
	char			msg[100];
	int				i;

	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "			Multicast Frame Buffer of %d (size %d)\n" , my_address , op_prg_list_size(multicast_frame_buffer));
	debug_print(LOW , debug_type , "-------------------------------------------------------------\n");
	debug_print(LOW , debug_type , "	DEST	|	TYPE	| 	ID		|	NB_RETRY	|	MIN_TRANSMISSION\n");


	
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		debug_print(LOW , debug_type , "%5d	|	%s	|	%d		|	%d		|	%f\n", ptr->destination ,  pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id , ptr->nb_retry , ptr->time_transmission_min);
	}
	FOUT;
}



//-----------------------------------------------------------
//
//					MULTICAST & UNICAST FRAME BUFFER
//
//-----------------------------------------------------------


//Rteurns the nb of possible frames
int get_frame_buffer_size(){
	FIN(get_frame_buffer_size());
	
	frame_struct	*ptr;
	frame_struct	*ptr_uni;
	frame_struct	*ptr_multi;
	int				i , j;
	int				nb = 0;
	
	//initialization
	i = 0;
	//Multicast -> only when all my neighbors can receive it
	if (IS_BROADCAST_FORBIDDEN)
		j = op_prg_list_size(multicast_frame_buffer);
	else
		j = 0;

	while((i < op_prg_list_size(unicast_frame_buffer)) || (j < op_prg_list_size(multicast_frame_buffer))){
	
		//no more unicast frame
		if (i == op_prg_list_size(unicast_frame_buffer)){
			ptr = op_prg_list_access(multicast_frame_buffer , j);
			j++;
		}
	
	
		//no more multicast frame
		else if (j == op_prg_list_size(multicast_frame_buffer)){
			ptr = op_prg_list_access(unicast_frame_buffer , i);
			i++;
		}
	
	
		else{
			ptr_uni 	= op_prg_list_access(unicast_frame_buffer , i);
			ptr_multi	= op_prg_list_access(multicast_frame_buffer , j);
			
			//next element for the next time
			if (ptr_uni->time_added < ptr_multi->time_added){
				ptr = ptr_uni;
				i++;
			}
			else{
				ptr = ptr_multi;
				j++;
			}
		}
		
		//result
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)))
			nb++;
	}
	FRET(nb);
}

//Must any multicast / anycast data farme be sent ?
Boolean is_frame_buffer_empty(){
	FIN(is_frame_buffer_empty());
	FRET((get_frame_buffer_size() == 0));
}


//returns the first data frame to send
frame_struct *get_frame_buffer(int pos){
	FIN(get_frame_buffer(int pos));

	frame_struct	*ptr;
	frame_struct	*ptr_uni;
	frame_struct	*ptr_multi;
	int				i , j;
	int				nb = 0;
	
	//initialization
	i = 0;
	//Multicast -> only when all my neighbors can receive it
	if (IS_BROADCAST_FORBIDDEN)
		j = op_prg_list_size(multicast_frame_buffer);
	else
		j = 0;

	while((i < op_prg_list_size(unicast_frame_buffer)) || (j < op_prg_list_size(multicast_frame_buffer))){
	
		//no more unicast frame
		if (i == op_prg_list_size(unicast_frame_buffer)){
			ptr = op_prg_list_access(multicast_frame_buffer , j);
			j++;
		}
	
	
		//no more multicast frame
		else if (j == op_prg_list_size(multicast_frame_buffer)){
			ptr = op_prg_list_access(unicast_frame_buffer , i);
			i++;
		}
	
	
		else{
			ptr_uni 	= op_prg_list_access(unicast_frame_buffer , i);
			ptr_multi	= op_prg_list_access(multicast_frame_buffer , j);
			
			//next element for the next time
			if (ptr_uni->time_added < ptr_multi->time_added){
				ptr = ptr_uni;
				i++;
			}
			else{
				ptr = ptr_multi;
				j++;
			}
		}
		
		//result
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)) && (pos == nb))
			FRET(ptr);
		
		if ((ptr->time_transmission_min < op_sim_time()) && (is_destination_available(ptr->destination)))
			nb++;
	}
	FRET(NULL);
}



//deletes the multicast or unicast frames with the frame_id 'id'
void del_frame_buffer_with_id(int id , Boolean acknowledged){
	FIN(del_frame_buffer_with_id(int id , Boolean acknowledged));
	
	frame_struct	*ptr;
	char			msg[100];
	int				i;

	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == id){
			debug_print(LOW, DEBUG_TIMEOUT , "the unicast frame to %d was received (ack required %d, nb_retry %d, type %s, id %d)\n",  ptr->destination , acknowledged , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(unicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
	}
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->frame_id == id){
			debug_print(LOW, DEBUG_TIMEOUT , "the multicast frame to %d was received (ack required %d, nb_retry %d, type %s, id %d)\n",  ptr->destination , acknowledged , ptr->nb_retry , pk_type_to_str(ptr->type , msg, 100) , ptr->frame_id);
		
			ptr = op_prg_list_remove(multicast_frame_buffer , i);
			if (ptr->payload != NULL)
				op_pk_destroy(ptr->payload);
			op_prg_mem_free(ptr);
		}
	}
	FOUT;
}



//returns TRUE if the frame_id is present in the buffer
Boolean is_in_frame_buffer(int frame_id){
	FIN(is_in_frame_buffer(int frame_id));
	
	frame_struct	*ptr;
	int				i;
	
	for(i=op_prg_list_size(multicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(multicast_frame_buffer , i);

		if (ptr->frame_id == frame_id)
			FRET(OPC_TRUE);
	}
	for(i=op_prg_list_size(unicast_frame_buffer)-1 ; i>=0 ; i--){
		ptr = op_prg_list_access(unicast_frame_buffer , i);

		if (ptr->frame_id == frame_id)
			FRET(OPC_TRUE);
	}
	
	FRET(OPC_FALSE);
}


//Debug
void print_frame_buffer(int debug_type){
	FIN(print_frame_buffer(int debug_type));
	
	print_multicast_frame_buffer(debug_type);
	print_unicast_frame_buffer(debug_type);

	FOUT;
}






//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												ROUTING													  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------




//-----------------------------------------------------------
//
//						NEXT HOP
//
//-----------------------------------------------------------


//returns the next_hop to the sink
int get_next_hop(){
	FIN(get_next_hop());
	
	int				i;
	neigh_struct	*neigh_ptr;
	compar_struct 	next;
	
	debug_print(LOW , DEBUG_DATA , "Routing computation toward the sink. Candidates are:\n");
	
	//Initialization
	next.addr 		= ADDR_BROADCAST;
	next.ktree_dist = my_sink_tree.ktree_dist;
	next.sink_dist	= my_sink_tree.sink_dist;
	switch (MAC_ROUTING){
	
		//In priority to the ktree and then to the sink
		case ROUTING_MAC_KTREE:
		
		//since all nodes have a null distance to the ktree, equivalent to the shortest paths to the sink
		case ROUTING_MAC_SHORT:
		
			//Walks in the list
			for(i= op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
				neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
				//Closer to the ktree core
				if (neigh_ptr->ktree_dist < next.ktree_dist){
					next.addr		= neigh_ptr->address;
					next.ktree_dist	= neigh_ptr->ktree_dist;
					next.sink_dist	= neigh_ptr->sink_dist;
					
					debug_print(MAX , DEBUG_DATA , "case 1\n");
				}
				   
				//Closer to the sink (but not farther from the k-tree core)	   
				else if ((neigh_ptr->ktree_dist == next.ktree_dist) && (neigh_ptr->sink_dist < next.sink_dist)){
					next.addr		= neigh_ptr->address;
					next.ktree_dist	= neigh_ptr->ktree_dist;
					next.sink_dist	= neigh_ptr->sink_dist;
					
					debug_print(MAX , DEBUG_DATA , "case 2\n");
				}
				debug_print(MAX , DEBUG_DATA , "	->%d (dist_kt %d, distSink %d)\n",  neigh_ptr->address, neigh_ptr->ktree_dist, neigh_ptr->sink_dist);
			}
		
		break;
		case ROUTING_MAC_NO:
			op_sim_end("I am not allowed to route packets" , "But I try to find one next hop" , "Please correct the corresponding bug" , "");
		break;
		
		default:
			op_sim_end("Unknown routing type" , "" , "" , "");
		break;
	}

	debug_print(MEDIUM , DEBUG_DATA , "Next hop to the sink is %d\n",  next.addr);
	FRET(next.addr);

}





//-----------------------------------------------------------
//
//					IS KTREE_NODE status
//
//-----------------------------------------------------------

//Is this node a ktree node ?
Boolean		get_is_in_ktree(){
	FIN(get_is_in_ktree());
	
	int				i , j;
	neigh_struct	*neigh_ptr;
	int				*addr_ptr;
	
	//The sink is always a ktree node !
	if (is_sink)
		FRET(OPC_TRUE);
	
		
	//Walks in the list
	for(i=op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//I am in its list of ktree children
		for(j=0 ; j < op_prg_list_size(neigh_ptr->ktree_children) ; j++){
			addr_ptr = op_prg_list_access(neigh_ptr->ktree_children , j);
			
			//It is one parent -> save its stability
			if (*addr_ptr == my_address)
				FRET(OPC_TRUE);
		}
	}
	FRET(OPC_FALSE);
}


//empty a list (memory release of all elements)
void empty_list(List *ll){
	FIN(empty_list(List *ll));
	
	void	*ptr;
	
	while(op_prg_list_size(ll) != 0){
		ptr = op_prg_list_remove(ll ,0);
		op_prg_mem_free(ptr);
	}
	FOUT;
}



//Changes the status of this node
Boolean update_is_in_ktree(){
	FIN(update_is_in_ktree());
	
	int		old_value;

	old_value = is_in_ktree;
	is_in_ktree = get_is_in_ktree();
	
	//the value changed !
	if (is_in_ktree != old_value){
		
		//updates the ktree distance
		if (is_in_ktree)
			my_sink_tree.ktree_dist = 0;
	
		//debug
		debug_print(LOW , DEBUG_NODE , "changed the ktree_node status: %d -> %d\n", old_value , is_in_ktree);
		print_neighborhood_table(DEBUG_NODE);
		printf("%f: %d ktree_node status: %d -> %d\n", op_sim_time(), my_address , old_value , is_in_ktree);
		debug_print(LOW , DEBUG_CMAC , "changed the ktree_node status: %d -> %d\n", old_value , is_in_ktree);
	}
	
	
	//The value changed (a gratuitous hello is surely required)
	FRET(old_value != is_in_ktree);
}


//-----------------------------------------------------------
//
//				DISTANCES KTREE / SINK
//
//-----------------------------------------------------------


//Updates information about the tree toward the sink
void update_sink_tree_infos(){
	FIN(update_sink_tree_infos());
	
	int				i;
	neigh_struct	*neigh_ptr;
	int				current_ktree_dist , current_sink_dist;
	
	//init
	current_ktree_dist	= OPC_INT_INFINITY;
	current_sink_dist	= OPC_INT_INFINITY;
	
	//particular case
	if (is_sink){
		my_sink_tree.sink_dist 	= 0;
		my_sink_tree.ktree_dist	= 0;
		FOUT;
	}
	
	//Walks the neighborhood table and update distance (takes only into account the most stable nodes)
	for(i=0 ; i < op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//Distance to the ktree
		if (current_ktree_dist > neigh_ptr->ktree_dist + 1){
			current_ktree_dist = neigh_ptr->ktree_dist + 1;
		}
			
		//Distance to the sink
		if (current_sink_dist > neigh_ptr->sink_dist + 1){
			current_sink_dist = neigh_ptr->sink_dist + 1;
		}
		
		debug_print(MEDIUM , DEBUG_HELLO , "	-> %d:   %d/%d   d/%d\n", neigh_ptr->address, neigh_ptr->ktree_dist, current_ktree_dist, neigh_ptr->sink_dist, current_sink_dist);
	}
	
	//particular case
	if (is_in_ktree)
		current_ktree_dist = 0;
	
	my_sink_tree.sink_dist 	= current_sink_dist;
	my_sink_tree.ktree_dist	= current_ktree_dist;
	
	debug_print(MAX , DEBUG_HELLO , "Distances update\n");
	if (DEBUG >= MEDIUM)
		print_neighborhood_table(DEBUG_HELLO);
	FOUT;
}




//-----------------------------------------------------------
//
//				KTREE INFO MANAGEMENT
//
//-----------------------------------------------------------



//Returns the ktree child (not for the sink, it has several ktree children!)
int get_ktree_child(){
	FIN(get_ktree_child());	
	int		*int_ptr;
	
	if ((!is_in_ktree) || (op_prg_list_size(my_ktree_children) == 0))
		FRET(ADDR_BROADCAST);
	
	int_ptr = op_prg_list_access(my_ktree_children , 0);
	FRET(*int_ptr);
}


//Returns the child of the current branch
int get_ktree_child_from_sink(int current_branch){
	FIN(get_ktree_child_from_sink(int current_branch));
	
	int		*int_ptr;
	
	if ((!is_in_ktree) || (op_prg_list_size(my_ktree_children) == 0))
		FRET(ADDR_BROADCAST);
	
	
	int_ptr = op_prg_list_access(my_ktree_children , current_branch);
	FRET(*int_ptr);
}


//Prints the list of the current ktree children
char* print_ktree_children(char *msg, int length){
	FIN(print_ktree_children(char *msg, int length));
	
	int		*int_ptr;
	int		i;

	strncpy(msg, "", length);
	for(i=0; i < op_prg_list_size(my_ktree_children) ; i++){
		int_ptr = op_prg_list_access(my_ktree_children , i);
		snprintf(msg , length, "%s %d" , msg , *int_ptr);
	}
	FRET(msg);
}
	
//returns the nb of current branches (number of ktree children)
int get_nb_branches(){
	FIN(get_nb_branches());
	FRET(op_prg_list_size(my_ktree_children));
}


//Compares to couples addr/power 
int compare_election_struct(const void *value_a, const void * value_b){
	FIN(compare_election_struct(void *value_a, void * value_b));

	election_struct	a , b;
	
	a = *(election_struct*)value_a;
	b = *(election_struct*)value_b;
	
	
	//null power -> bad
	if (b.pow == 0)
		FRET(1);
	if (a.pow == 0)
		FRET(-1);
	
	//First criterium: branch nb (for the sink, else no particular interest)
	if ((is_sink) && (is_sync_direct_antenna)){
		if (a.branch < b.branch)
			FRET(1);
		if (a.branch > b.branch)
			FRET(-1);
	}
	
	//Second criterium: power
	if (a.pow < b.pow)
		FRET(1);
	if (a.pow > b.pow)
		FRET(-1);
	
	//3rd criterium: id
	if (a.addr > b.addr)
		FRET(1);
	FRET(-1);
}



//-----------------------------------------------------------
//
//				KTREE-CORE ELECTION
//
//-----------------------------------------------------------


//-----------------------------------------------------------
//					SYNC ALGO
//-----------------------------------------------------------



//returns the list of current ktree chdilren
void compute_current_my_ktree_children_maxtree(List **ll_ptr){
	FIN(compute_current_my_ktree_children_maxtree(List **ll_ptr));
	//Control
	int		*int_ptr;
	int		i;
	List	*ll = *ll_ptr;

	op_sim_end("not yet implemented", "", "", "");
	
	
	debug_print(LOW , DEBUG_CMAC , "FINAL_LIST\n");
	for(i=0 ; i < op_prg_list_size(ll) ; i++){
		int_ptr = op_prg_list_access(ll , i);
		debug_print(LOW , DEBUG_CMAC , "  : %d\n", *int_ptr);
	}
	
	FOUT;
}


//returns the list of current ktree chdilren
void compute_current_my_ktree_children_sync(List **ll_ptr){
	FIN(compute_current_my_ktree_children_sync(List **ll_ptr));
	
	int				i;
	neigh_struct	*neigh_ptr;
	//To store all the power, sorted, in a list
	List			*max_sync_rx_power;
	election_struct	*election_ptr;
	//Control
	child_struct	*child_ptr;
	short			branch_tmp = -1;
	List			*ll = *ll_ptr;
	//conditions
	Boolean			direct_and_new;
	Boolean			no_direct_and_new;

	
	//empty the old list
	while(op_prg_list_size(ll) > 0){
		child_ptr = op_prg_list_remove(ll , 0);
		op_prg_mem_free(child_ptr);
	}

	//--------------------------------------------------
	//				NO KTREE NODE
	//--------------------------------------------------
	if ((!is_sink) && ((my_sync_rx_power == 0) || (!is_in_ktree) || (my_sink_tree.sink_dist > MAX_BRANCH_LENGTH))){
		//debug_print(MAX , DEBUG_CMAC , "No ktree node: %d %d %d\n", my_sync_rx_power == 0 , !is_in_ktree , my_sink_dist > MAX_BRANCH_LENGTH);
		FOUT;
	}
	else{
		//initialization
		max_sync_rx_power = op_prg_list_create();
	
		
		
		//--------------------------------------------------
		//	Stores all the power of my neighbors (sorted)
		//--------------------------------------------------
		for(i= op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
			
			neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
			//Adds the power if the node is farther from the sink
			if (neigh_ptr->sink_dist > my_sink_tree.sink_dist){
				election_ptr = op_prg_mem_alloc(sizeof(election_struct));
				election_ptr->addr 	= neigh_ptr->address;
				election_ptr->pow 	= neigh_ptr->sync_rx_power;
				op_prg_list_insert_sorted(max_sync_rx_power , election_ptr , compare_election_struct);
			}
		}
	
		//--------------------------------------------------
		//			No node in the list
		//--------------------------------------------------
		if (op_prg_list_size(max_sync_rx_power) == 0){
		}
	
		//--------------------------------------------------
		//		For the sink -> places the N min power
		//--------------------------------------------------
		else if (is_sink){
			debug_print(LOW , DEBUG_CMAC , "Ktree children: \n");

			//Firt branch to deal with
			branch_tmp = -1;
			
			//Walks in the sorted list of my neighbors
			for(i=0 ; i < op_prg_list_size(max_sync_rx_power) ; i++){
				election_ptr = op_prg_list_access(max_sync_rx_power , i);
				
				debug_print(MAX , DEBUG_CMAC , "	ptr (%d : %d %f) current (%d)\n", election_ptr->addr , election_ptr->branch , election_ptr->pow , branch_tmp);
				
				//Eliminates nodes nearer from the sink than I am
				direct_and_new		= (is_sync_direct_antenna) && (election_ptr->branch > branch_tmp);
				no_direct_and_new	= (!is_sync_direct_antenna) && (i < NB_BRANCHES);
				
				if ((election_ptr->pow != 0) && (direct_and_new || no_direct_and_new)){
					branch_tmp = election_ptr->branch;
				
					//creates a list of current ktree children
					child_ptr = op_prg_mem_alloc(sizeof(child_struct));
					child_ptr->address 		= election_ptr->addr;
					child_ptr->branch_id 	= election_ptr->branch;
					op_prg_list_insert(ll , child_ptr , OPC_LISTPOS_TAIL);
					
					debug_print(MAX , DEBUG_CMAC , "	->%d\n", child_ptr->address);					
				}
			}
		}	
		//------------------------------------------------------
		//	For a normal ktree node, chooses only the lowest
		//------------------------------------------------------
		else{

			election_ptr = op_prg_list_access(max_sync_rx_power , 0);
			
			if ((election_ptr->pow < my_sync_rx_power) && (election_ptr->pow != 0)){
				debug_print(MAX , DEBUG_CMAC , "node %d chosen as ktree children\n", election_ptr->addr);
					
				//creates a list of current ktree nodes
				child_ptr = op_prg_mem_alloc(sizeof(child_struct));
				child_ptr->address 		= election_ptr->addr;
				child_ptr->branch_id 	= election_ptr->branch;
				op_prg_list_insert(ll , child_ptr , OPC_LISTPOS_TAIL);
			}
			else
				debug_print(MAX , DEBUG_CMAC , "no ktree node : %d\n", election_ptr->pow < my_sync_rx_power , election_ptr->pow != 0);
			
		
		}
			

		//--------------------------------------------------
		//			release memory
		//--------------------------------------------------
		while(op_prg_list_size(max_sync_rx_power) > 0){
			election_ptr = op_prg_list_remove(max_sync_rx_power , 0);
			op_prg_mem_free(election_ptr);
		}
		op_prg_mem_free(max_sync_rx_power);
	}
	
	debug_print(LOW , DEBUG_CMAC , "FINAL_LIST\n");
	for(i=0 ; i < op_prg_list_size(ll) ; i++){
		child_ptr = op_prg_list_access(ll , i);
		debug_print(LOW , DEBUG_CMAC , "  : %d\n", child_ptr->address);
	}
	
	FOUT;
}




//-----------------------------------------------------------
//					SYNC ALGO
//-----------------------------------------------------------







//-----------------------------------------------------------
//					COMMON
//-----------------------------------------------------------

	
//returns the list of current ktree chdilren
void compute_current_my_ktree_children(List **ll){
	FIN(compute_current_my_ktree_children(List **ll));
	
	//only for cmac!
	if (MAC_LAYER != CMAC)
		FOUT;
	
	//elects the children, depdends on the ktree creation algo
	switch(KTREE_ALGO){
	
		case KTREE_ALGO_SYNC :
			compute_current_my_ktree_children_sync(ll);
			FOUT;
		break;
		
		case KTREE_ALGO_MAXTREE :
			compute_current_my_ktree_children_maxtree(ll);
			FOUT;
		break;
		
		default:
			op_sim_end("You have to specify a ktree-algo to construct the structure", "", "", "");
		break;
	}
	FOUT;
}






//-----------------------------------------------------------
//
//				KTREE FIELDS in HELLOS
//
//-----------------------------------------------------------


//Creates a list of ktree nodes
List *create_my_ktree_children_from_packet(Packet *pk){
	FIN(create_my_ktree_children_from_packet(Packet *pk));
	
	//result
	List			*ll;
	//List size and elements
	int				nb_ktree_children;
	child_struct	*child_ptr;
	//Control
	int				i;
	//info
	int				source;
	//list of children
	child_struct	*list_children_ptr;
	
	//init
	ll = op_prg_list_create();
		
	//nb ktree nodes
	op_pk_nfd_get(pk,		FIELD_PK_HELLO_NB_KTREE_CHILDREN, 	&nb_ktree_children);
	op_pk_nfd_get_int32(pk, FIELD_PK_SOURCE, 					&source);
	op_pk_nfd_get_ptr(pk, 	FIELD_PK_HELLO_KTREE_CHILDREN,		(void**)&list_children_ptr);

	//insert each ktree children in the list
	for(i=0 ; i<nb_ktree_children; i++){
		child_ptr 	= op_prg_mem_alloc(sizeof(child_struct));
		*child_ptr 	= list_children_ptr[i];
		op_prg_list_insert(ll , child_ptr , OPC_LISTPOS_HEAD);
	}
	
	FRET(ll);
}


//fills the packet with the list of my ktree children
void fill_ktree_children_fields(Packet *pk){
	FIN(fill_ktree_children_fields(Packet *pk));
	
	child_struct	*child_ptr;
	//Control
	int				i;
	//list of children
	child_struct	*list_children_ptr;
	int				nb_children;

	//Current ktree children
	compute_current_my_ktree_children(&my_ktree_children);
	nb_children = op_prg_list_size(my_ktree_children);
	
	//Nb of ktree children
	op_pk_nfd_set(pk , FIELD_PK_HELLO_NB_KTREE_CHILDREN , nb_children);
		
	//Fills ktree children fields
	if (nb_children != 0){
		list_children_ptr = op_prg_mem_alloc(sizeof(int) * nb_children);
	
		for(i=0; i<nb_children; i++){
			child_ptr = op_prg_list_access(my_ktree_children, i);
			list_children_ptr[i] = *child_ptr;			
		}		
		op_pk_nfd_set_ptr(pk, FIELD_PK_HELLO_KTREE_CHILDREN, list_children_ptr, op_prg_mem_copy_create, op_prg_mem_free, sizeof(int) * nb_children);
	}
	
	print_neighborhood_table(DEBUG_NODE);
	FOUT;
}









//-----------------------------------------------------------
//
//					HELLOS
//
//-----------------------------------------------------------

//Generates an hello (next frame to send !)
void  generate_hello(double next_hello){ 
	FIN(generate_hello(double next_hello));
	
	//Packet to send
	frame_struct	frame;
	//info
	int				frame_id;
	
	//frame id
	frame_id = get_new_frame_id();
	
	frame.source				= my_address;
	frame.destination			= ADDR_BROADCAST;
	frame.type					= HELLO_PK_TYPE;
	frame.frame_id				= frame_id;
	frame.nb_retry				= 0;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	frame.duration				= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE + SINK_DIST_SIZE + KTREE_DIST_SIZE;
	frame.next_hello			= next_hello;
	
	//Adds the hello in head of the data packet buffer
	add_in_multicast_frame_buffer(frame , OPC_LISTPOS_HEAD);
	is_hello_to_send 			= OPC_TRUE;
	
	debug_print(LOW , DEBUG_HELLO , "HELLO generated toward %d\n", frame.destination);
	
	FOUT;
}



//Deletes the neighbors which did not send an HELLO for a long time (timeout)
void delete_timeouted_neighbors(void *ptr , int code){
	FIN(delete_timeouted_neighbors(void *ptr , int code));
		
	double			older_entry = 0;
	int				i;
	neigh_struct	*neigh_ptr;
	Boolean			is_modif_required = OPC_FALSE;
	
	//Walks in the list
	for(i= op_prg_list_size(my_neighborhood_table)-1 ; i>= 0 ; i--){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//The entry is timeouted -> stability --
		if (neigh_ptr->timeout <= op_sim_time()){
			neigh_ptr = op_prg_list_remove(my_neighborhood_table , i);
			
			debug_print(LOW , DEBUG_HELLO , "neighbor %d timeouted after a null stability\n", neigh_ptr->address);
			debug_print(LOW , DEBUG_NODE , "neighbor %d timeouted after a null stability\n",  neigh_ptr->address);

			empty_list(neigh_ptr->ktree_children);
			op_prg_mem_free(neigh_ptr->ktree_children);
			op_prg_mem_free(neigh_ptr);
			neigh_ptr = NULL;

			is_modif_required = OPC_TRUE;
		}
		
		//when must be done the next verification ?
		if ((neigh_ptr != NULL) && ((older_entry > neigh_ptr->timeout) || (older_entry == 0)))
			older_entry = neigh_ptr->timeout;
	}
	
	
	//Modification in the neighborhood table !
	if (is_modif_required){
		//ktree node
		if (update_is_in_ktree())
			generate_hello(0);

		//Distances
		update_sink_tree_infos();
	}
	
	//Next verification
	if (op_prg_list_size(my_neighborhood_table) != 0)
		op_intrpt_schedule_call(older_entry , NEIGHBOR_TIMEOUT_CODE , delete_timeouted_neighbors , NULL);
	FOUT;	
}



//updates the neighborhood table with one new entry !
void update_neighborhood_table(int source , int sink_dist , int ktree_dist, double sync_rx_power, int branch , List *my_ktree_children_tmp , double next_hello){
	FIN(update_neighborhood_table(int source , int sink_dist , int ktree_dist, double sync_rx_power, int branch , List *my_ktree_children_tmp , double next_hello));
	
	int				i;
	neigh_struct	*neigh_ptr;
	Boolean			neighbor_updated 	= OPC_FALSE;
	Boolean			hello_required 		= OPC_FALSE;
	
	
	//---------------------------
	//	DIST SINK / KTREE
	//---------------------------
	if (my_sink_tree.ktree_dist > ktree_dist + 1){
		my_sink_tree.ktree_dist	= ktree_dist + 1 ;
		my_sink_tree.sink_dist 	= sink_dist + 1 ;
		
		debug_print(LOW , DEBUG_HELLO , "Distances updated : ktree %d, sink %d via %d\n", my_sink_tree.sink_dist, my_sink_tree.ktree_dist , source);
	//	hello_required = OPC_TRUE;
	}
	if ((ktree_dist == my_sink_tree.ktree_dist) && (my_sink_tree.sink_dist > sink_dist + 1)){
		my_sink_tree.sink_dist = sink_dist + 1;
		
		debug_print(LOW , DEBUG_HELLO , "Sink distance updated : sink %d via %d\n", my_sink_tree.sink_dist, my_sink_tree.ktree_dist , source);
	//	hello_required = OPC_TRUE;
	}
		
	//---------------------------
	//		LIST UPDATE
	//---------------------------
	for(i=0; i<op_prg_list_size(my_neighborhood_table) ; i++){
		neigh_ptr = op_prg_list_access(my_neighborhood_table , i);
	
		if (neigh_ptr->address == source){
			op_prg_mem_free(neigh_ptr->ktree_children);
			neigh_ptr->sink_dist			= sink_dist;
			neigh_ptr->ktree_dist			= ktree_dist;
			neigh_ptr->sync_rx_power		= sync_rx_power;
			neigh_ptr->ktree_children		= my_ktree_children_tmp;
			neighbor_updated 				= OPC_TRUE;
			if (next_hello != 0)
				neigh_ptr->timeout			= op_sim_time() + next_hello * HELLO_PK_TIMEOUT + 0.1;			
				
			debug_print(MEDIUM , DEBUG_HELLO, "neighbor %d updated (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);
			//debug_print(MEDIUM , DEBUG_NODE, "neighbor %d updated (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);	
		}	
	}
	

	//---------------------------
	//		LIST ADD
	//---------------------------
	if (!neighbor_updated){
		//We add one entry -> we must schedule the timeout verification
		if (op_prg_list_size(my_neighborhood_table) == 0)			
			op_intrpt_schedule_call(op_sim_time() + HELLO_PK_PERIOD , NEIGHBOR_TIMEOUT_CODE , delete_timeouted_neighbors , NULL);

		neigh_ptr = op_prg_mem_alloc(sizeof(neigh_struct));
		neigh_ptr->address				= source;
		neigh_ptr->sink_dist			= sink_dist;
		neigh_ptr->ktree_dist			= ktree_dist;
		neigh_ptr->sync_rx_power		= sync_rx_power;
		neigh_ptr->timeout				= op_sim_time() + HELLO_PK_PERIOD;
		neigh_ptr->ktree_children		= my_ktree_children_tmp;
		neigh_ptr->timeout				= op_sim_time() + next_hello * HELLO_PK_TIMEOUT + 0.1;			
		op_prg_list_insert(my_neighborhood_table , neigh_ptr , OPC_LISTPOS_TAIL);	  
		
	
		debug_print(MEDIUM , DEBUG_HELLO, "neighbor %d added (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);
		debug_print(MEDIUM , DEBUG_NODE, "neighbor %d added (sink %d, ktree %d)\n", source, sink_dist , ktree_dist);
	}
	
	//---------------------------
	//		IS KTREE NODE ?
	//---------------------------
	//NB: I must verify for each reception 
	//the source may have change the list of its ktree children
	
	if (update_is_in_ktree())
		hello_required = OPC_TRUE;
		
	
	//-------------------------------------------------
	//		INFOS ABOUT THE TREE ROOTED AT THE SINK
	//-------------------------------------------------
	update_sink_tree_infos();
	
	
	
	//I changed by ktree node status or my distance to sink / ktree
	if (hello_required)
		generate_hello(0);
	
	FOUT;
}



//Prints in my debug_file the neighborhood table
void print_neighborhood_table(int debug_type){
	FIN(print_neighborhood_table(int debug_type));
	
	int				i , j;
	neigh_struct	*ptr;
	int				*addr_ptr;
	char			msg[50];

	
	debug_print(LOW , debug_type , "---------------------------------------\n");
	debug_print(LOW , debug_type , "	NEIGHBORHOOD TABLE (%f)\n", op_sim_time());
	debug_print(LOW , debug_type , "---------------------------------------\n");
	debug_print(LOW , debug_type , "\n");
	
	debug_print(LOW , debug_type , "addr |Sink|ktree|Timeout|Stability|my_ktree_children\n");
	
	for (i=0 ; i< op_prg_list_size(my_neighborhood_table) ; i++){
		ptr = op_prg_list_access(my_neighborhood_table , i);
		
		//list of ktree children
		strncpy(msg, "", 50);
		for(j=0; j < op_prg_list_size(ptr->ktree_children) ; j++){
			addr_ptr = op_prg_list_access(ptr->ktree_children , j);
			snprintf(msg , 50, "%s %d", msg , *addr_ptr);
		}
			
		//the whole info
		debug_print(LOW , debug_type , "%5d| %3d| %3d  | %f |%s\n", ptr->address , convert_int(ptr->sink_dist) , convert_int(ptr->ktree_dist) , ptr->timeout , msg);
	}
	debug_print(LOW , debug_type , "sink = %d, ktree = %d, isBN = %d, syncPw = %f, bn list = %s\n", 	my_sink_tree.sink_dist , 	my_sink_tree.ktree_dist, is_in_ktree, convert_double(my_sync_rx_power), print_ktree_children(msg, 50));

	
	FOUT;
}


























//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												CONTROL FRAME											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------



//-----------------------------------------------------------
//
//			  	NEXT_FRAME to Send
//
//-----------------------------------------------------------

//from info about the frame, generate the corresponding packet (juste before transmission)
Packet* create_packet(frame_struct frame){
	FIN(create_packet(frame_struct frame));
	
	char	msg[100];
	Packet	*pk;

	switch(frame.type){
		case DATA_MULTICAST_PK_TYPE:
		case DATA_UNICAST_PK_TYPE:
			pk = op_pk_create_fmt("cmac_frame");
			op_pk_nfd_set(pk , FIELD_PK_DATA_PAYLOAD , 	op_pk_copy(frame.payload));
			op_pk_nfd_set(pk , FIELD_PK_DURATION , 		frame.duration);
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO , 	frame.power_ratio);
		break;
		case HELLO_PK_TYPE:
			pk = op_pk_create_fmt("cmac_hello");
			op_pk_nfd_set(pk , FIELD_PK_HELLO_SINK_DIST , 	my_sink_tree.sink_dist);
			op_pk_nfd_set(pk , FIELD_PK_HELLO_KTREE_DIST,	my_sink_tree.ktree_dist);
			op_pk_nfd_set(pk , FIELD_PK_HELLO_NEXT,			frame.next_hello);

			//ktree algo info
			if (op_pk_nfd_is_set(pk , 	FIELD_PK_HELLO_SYNC_POWER))
				op_pk_nfd_strip(pk , 	FIELD_PK_HELLO_SYNC_POWER);
			if (op_pk_nfd_is_set(pk , 	FIELD_PK_HELLO_SINK_SUBTREE_SIZE))
				op_pk_nfd_strip(pk , 	FIELD_PK_HELLO_SINK_SUBTREE_SIZE);
			
			switch (KTREE_ALGO){
				
				case KTREE_ALGO_SYNC:
					op_pk_nfd_set(pk, FIELD_PK_HELLO_SYNC_POWER, my_sync_rx_power);			
				break;
		
				case KTREE_ALGO_MAXTREE:
					op_pk_nfd_set(pk, FIELD_PK_HELLO_SINK_SUBTREE_SIZE, my_sink_tree.subtree_size);
				break;
				
				case KTREE_ALGO_NONE:
				break;
				
				default:
					op_sim_end("Unknown ktree algo", "", "", "");
			}
		
		fill_ktree_children_fields(pk);
		break;
		case RTS_PK_TYPE:
			pk = op_pk_create_fmt("cmac_rts");
			op_pk_nfd_set(pk , FIELD_PK_DURATION , 		frame.duration);
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO , 	frame.power_ratio);
		break;
		case CTS_PK_TYPE:
			pk = op_pk_create_fmt("cmac_cts");
			op_pk_nfd_set(pk , FIELD_PK_DURATION, 		frame.duration);
			op_pk_nfd_set(pk , FIELD_PK_POWER_RATIO, 	frame.power_ratio);
		break;
		case CTR_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr");
			op_pk_nfd_set(pk , FIELD_PK_CTR_FREQ, 		my_privileged_frequency);
			op_pk_nfd_set(pk , FIELD_PK_CTR_TSLOT , 	slot_privileged_duration);
			op_pk_nfd_set(pk , FIELD_PK_CTR_OFFSET , 	op_sim_time() - frame.time_added);
//			debug_print(LOW, DEBUG_NODE , "offset sent %f\n", op_sim_time() - frame.time_added);
//TAG
//			op_pk_nfd_set(pk , FIELD_PK_CTR_OFFSET , 		0);
		
		break;
		case CTR_ACK_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr_ack");
			op_pk_nfd_set(pk , FIELD_PK_CTR_FREQ , 		my_privileged_frequency);
			op_pk_nfd_set(pk , FIELD_PK_CTR_TSLOT , 	slot_privileged_duration);
		break;
		case CTR_END_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ctr_end");
		break;
		case ACK_PK_TYPE:
			pk = op_pk_create_fmt("cmac_ack");
			op_pk_nfd_set(pk , FIELD_PK_DURATION , 		frame.duration);
		break;
		case SYNC_PK_TYPE:
			pk = op_pk_create_fmt("cmac_sync");
			op_pk_nfd_set(pk , FIELD_PK_SYNC_BRANCH, 	sync_last_branch);
		break;
		default:
			strncpy(msg, "Packet type %d unknown", 100);
			op_sim_end(msg , "Consequently, I cannot generate the corresponding packet" , "" , "");
		break;
	}
	
	
	//Common fields
	op_pk_nfd_set(pk , FIELD_PK_SOURCE, 	frame.source);
	op_pk_nfd_set(pk , FIELD_PK_DESTINATION,frame.destination);
	op_pk_nfd_set(pk , FIELD_PK_TYPE,		frame.type);
	op_pk_nfd_set(pk , FIELD_PK_ID,			frame.frame_id);
	op_pk_nfd_set(pk , FIELD_PK_ACCEPT,		OPC_TRUE);
		
	//returns the frame !
	FRET(pk);
}


//Deletes the next scheduled frame
void set_next_frame_null(){
	FIN(set_next_frame_null());
	
	char	msg[100];

	debug_print(MEDIUM , DEBUG_DATA , "old frame scheduled (destination %d, type %s) canceled / deleted / in_progress\n", next_frame_to_send.destination, pk_type_to_str(next_frame_to_send.type , msg, 100));
	
	next_frame_to_send.type = NO_PK_TYPE;
	
	FOUT;
}


//Replaces the next_frame_to_send
void change_next_frame(frame_struct new_frame){
	FIN(change_next_frame(frame_struct new_frame));
	
	char	msg1[100];
	char	msg2[100];

	debug_print(MEDIUM , DEBUG_DATA , "old frame scheduled (destination %d, type %s) replaced by a new frame (destination %d, type %s)\n", next_frame_to_send.destination, pk_type_to_str(next_frame_to_send.type , msg1, 100) , new_frame.destination , pk_type_to_str(new_frame.type , msg2, 100));
	
	next_frame_to_send = new_frame;
	
	FOUT;
}




//-----------------------------------------------------------
//
//				 FRAME ID MANAGEMENT
//
//-----------------------------------------------------------

//Returns a new unique frame id
int get_new_frame_id(){
	FIN(get_new_frame_id());
	
	global_frame_id = (global_frame_id + 1) % ((int)(pow(2, sizeof(int) * 8) / 2) - 1);
	FRET(global_frame_id);
}






//-----------------------------------------------------------
//
//					REQUEST TO SEND
//
//-----------------------------------------------------------

//Generates a RTS
void generate_rts(int destination , int duration , int data_frame_id , double power_ratio){
	FIN(generate_rts(int destination , int duration , int data_frame_id , double power_ratio));
	
	//Packet to send
	frame_struct		frame;

	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= RTS_PK_TYPE;
	frame.frame_id 				= data_frame_id;
	frame.nb_retry				= 0;
	frame.duration				= duration;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + DURATION_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	
	debug_print(MEDIUM , DEBUG_CONTROL , "RTS for %d (frame_id %d)\n", destination , data_frame_id);
	
	FOUT;
}




//-----------------------------------------------------------
//
//					CLEAR TO SEND
//
//-----------------------------------------------------------

//Generates a CTS
void generate_cts(int destination , int duration, int frame_id , double power_ratio){
	FIN(generate_cts(int destination , int duration, int frame_id , double power_ratio));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= CTS_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.duration				= duration;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + DURATION_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);

	debug_print(MEDIUM , DEBUG_CONTROL , "CTS for %d, frame id\n",  destination ,  frame_id);
	
	FOUT;
}




//-----------------------------------------------------------
//
//					ACKNOWLEDGEMENT
//
//-----------------------------------------------------------

//Generates an ACK
void generate_ack(int destination, int frame_id , int duration , double power_ratio){
	FIN(generate_ack(int destination, int frame_id , int duration , double power_ratio));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= ACK_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.duration 				= duration;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	
	//prepares transmission
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "ACK generated by %d at %f\n", my_address , op_sim_time());
	
	FOUT;
}



//-----------------------------------------------------------
//
//					SYNCHRONIZATION
//
//-----------------------------------------------------------


//Generates a SYNC and schedules its transmission (next_frame_to_send)
void generate_sync(){
	FIN(generate_sync());
	
	//Packet to send
	frame_struct		frame;
	//info
	int					frame_id;
	
	//frame id
	frame_id = get_new_frame_id();
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= ADDR_BROADCAST;
	frame.type 					= SYNC_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.duration				= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE + NB_TIER_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "SYNC generated\n");
	
	FOUT;
}



//-----------------------------------------------------------
//
//					CLEAR TO RECEIVE
//
//-----------------------------------------------------------


//Generates a CTR-END and schedules its transmission (next_frame_to_send)
void generate_ctr_end(){
	FIN(generate_ctr_end());
	
	//Packet to send
	frame_struct		frame;
	//info
	int				frame_id;
	
	printf("CTR-END\n");
	
	//frame id
	frame_id = get_new_frame_id();
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= ADDR_BROADCAST;
	frame.type 					= CTR_END_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.duration				= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	change_next_frame(frame);
	
	debug_print(MEDIUM , DEBUG_CONTROL , "CTR-END generated\n");
	
	FOUT;
}



//Generates a CTR and schedules its transmission (next_frame_to_send)
void generate_ctr(){
	FIN(generate_ctr());
	
	//Packet to send
	frame_struct	frame;
	//info
	int				destination;
	int				frame_id;
	
	//Main frequency
	change_tx_rx_freq(my_main_frequency , my_main_bandwidth , STREAM_TO_RADIO);
	
	//Destination
	if (is_sink){
		ctr_last_branch++;
		
		//If several available channels, get one for this branch (round robin when the branch changes)
		if (nb_channels > 1){
			my_privileged_frequency = my_main_frequency;
			my_privileged_frequency += my_main_bandwidth / 1000 + SHIFT_FREQ_SEPARATION;
			my_privileged_frequency += (my_main_bandwidth * RATIO_PRIV_BANDWIDTH  / 1000 + SHIFT_FREQ_SEPARATION) * (ctr_last_branch % (nb_channels - 1));
		}
		else
			my_privileged_frequency = my_main_frequency;
		
		
		if (ctr_last_branch >= get_nb_branches())
			ctr_last_branch = 0;
		destination = get_ktree_child_from_sink(ctr_last_branch);	
	}
	else
		destination = get_ktree_child();
	
	//No more ktree children
	if (destination == ADDR_BROADCAST){
		is_node_privileged = OPC_FALSE;
		FOUT;
	}
	
	//Normal CTR
	else {
		//Unavailability of the next hop
		//update_nav_time(2 * (slot_privileged_duration + MAX_CTR_DELAY_FROM_SINK) , destination , my_privileged_frequency , 0);
	
		//frame id
		frame_id = get_new_frame_id();
	
		//Next frame to send
		frame.source 				= my_address;
		frame.destination 			= destination;
		frame.type 					= CTR_PK_TYPE;
		frame.frame_id 				= frame_id;
		frame.nb_retry				= 0;
		frame.duration				= 0;
		frame.power_ratio			= 1;
		frame.pk_size				= HEADERS_PK_SIZE;
		frame.time_added			= op_sim_time();
		frame.time_sent				= 0;
		frame.time_transmission_min	= 0;
		frame.released				= OPC_FALSE;
		frame.payload				= NULL;
		change_next_frame(frame);
	
		debug_print(LOW , DEBUG_CONTROL , "CTR generated for the child %d\n", destination);
	}
	FOUT;
}


//Generates a CTR-ACK
void generate_ctr_ack(int destination, int frame_id , int duration_unavailable){
	FIN(generate_ctr_ack(int destination, int frame_id , int duration_unavailable));
	
	//Packet to send
	frame_struct		frame;
	
	//Next frame to send
	frame.source 				= my_address;
	frame.destination 			= destination;
	frame.type 					= CTR_ACK_PK_TYPE;
	frame.frame_id 				= frame_id;
	frame.nb_retry				= 0;
	frame.power_ratio			= 1;
	frame.pk_size				= HEADERS_PK_SIZE;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.duration 				= duration_unavailable;
	frame.released				= OPC_FALSE;
	frame.payload				= NULL;
	
	//prepares transmission
	change_next_frame(frame);
	
	
	debug_print(MEDIUM , DEBUG_CONTROL , "CTR-ACK generated by %d at %f\n", my_address , op_sim_time());
	
	FOUT;
}




//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												RECEPTION												  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------












//-----------------------------------------------------------
//
//				 RECEIVE FROM UPPER
//
//-----------------------------------------------------------

//Prepares a data frame (headers, queue...)
void prepare_data_frame(Packet	*payload , int frame_id , int next_hop , double power_ratio){
	FIN(generate_ctr_ack(int destination, int frame_id , int duration_unavailable));
	
	//Packet to send
	frame_struct	frame;
	
	if (DEBUG >= MAX)
		print_neighborhood_table(DEBUG_NODE);
	debug_print(MAX , DEBUG_NODE , "NEXT HOP to the sink is %d\n", my_address , next_hop); 
	
	//Fields
	frame.source				= my_address;
	frame.destination			= next_hop;
	frame.frame_id				= frame_id;
	frame.nb_retry				= 0;
	frame.time_added			= op_sim_time();
	frame.time_sent				= 0;
	frame.time_transmission_min	= 0;
	frame.released				= OPC_FALSE;
	frame.payload				= payload;
	frame.duration				= 0;
	frame.power_ratio			= power_ratio;
	frame.pk_size				= HEADERS_PK_SIZE + op_pk_total_size_get(payload);
	
	if (next_hop == ADDR_BROADCAST){
		frame.type	= DATA_MULTICAST_PK_TYPE;
		add_in_multicast_frame_buffer(frame , OPC_LISTPOS_TAIL);
	}
	else{
		frame.type	= DATA_UNICAST_PK_TYPE;
		add_in_unicast_frame_buffer(frame , OPC_LISTPOS_TAIL);
	}
	FOUT;	
}



//receives a packet from the upper layer
void receive_packet_from_up(){
	FIN(receive_packet_from_up());
	
	Packet	*payload;
	int		frame_id;
	int		data_id;
	//Info from the upper layer
	int		next_hop;
	double	power_ratio;
	
	//frame id
	frame_id = get_new_frame_id();
	
	//Packet from upper
	payload = op_pk_get(op_intrpt_strm());
	op_pk_fd_get(payload, FIELD_PAYLOAD_ID, &data_id);
	
	//routing
	next_hop	= get_next_hop();		
	power_ratio	= 1;

	//ready to send !
	if (next_hop != -1)
		prepare_data_frame(payload , frame_id , next_hop , power_ratio);

	debug_print(LOW , DEBUG_DATA , "DATA frame sent by %d to %d (frameid %d, dataid %d)\n", my_address , next_hop , frame_id, data_id);
	
	FOUT;
}





//-----------------------------------------------------------
//
//					TRANSMISSION TIMES
//
//-----------------------------------------------------------




//returns the time required for a whole exchange RTS / CTS / DATA / ACK (according to the data frame size)
double compute_rts_cts_data_ack_time(int data_pk_size){
	FIN(compute_rts_cts_data_ack_time(int data_pk_size));
	
	//Packet size
	Packet			*pkptr;
	int				rts_pk_size , cts_pk_size , ack_pk_size;	
	
	//to get the size of RTS/CTS/ACK without a constant (if we change the format -> it will be dynamically updated here !)
	//RTS
	pkptr = op_pk_create_fmt("cmac_rts");
	rts_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//CTS
	pkptr = op_pk_create_fmt("cmac_cts");
	cts_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange: SIFS / RTS / SIFS / CTS / SIFS / DATA / SIFS / ACK	
	FRET(4 * SIFS + 4 * PROPAGATION_DELAY + ((double)rts_pk_size + (double)cts_pk_size + (double)data_pk_size + (double)ack_pk_size ) / operational_speed);
}



//returns the time required for a whole exchange CTS / DATA / ACK (according to the data frame size)
double compute_cts_data_ack_time(int data_pk_size){
	FIN(compute_cts_data_ack_time(int data_pk_size));

	//Packet size
	Packet			*pkptr;
	int				cts_pk_size , ack_pk_size;
	
	//to get the size of RTS/CTS/ACK without a constant (if we change the format -> it will be dynamically updated here !)
	//CTS
	pkptr = op_pk_create_fmt("cmac_cts");
	cts_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange: SIFS / CTS / SIFS / DATA / SIFS / ACK	
	FRET(3 * SIFS + 3 * PROPAGATION_DELAY + ((double)cts_pk_size + (double)data_pk_size + (double)ack_pk_size ) / operational_speed);
}

//returns the time required for a whole exchange DATA / ACK (according to the data frame size)
double compute_data_ack_time(int data_pk_size){
	FIN(compute_data_ack_time(int data_pk_size));
	
	//Packet size
	Packet			*pkptr;
	int				ack_pk_size;

	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange: SIFS / DATA / SIFS / ACK	
	FRET(2 * SIFS + 2 * PROPAGATION_DELAY + ( (double)data_pk_size + (double)ack_pk_size ) / operational_speed);
}

//returns the time for an ack
double compute_ack_time(){
	FIN(compute_ack_time());
	
	//Packet size
	Packet			*pkptr;
	int				ack_pk_size;

	//ACk pk size
	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	//Exchange:  SIFS / ACK	
	FRET(SIFS + PROPAGATION_DELAY + (double)(ack_pk_size ) / operational_speed);
}

//returns the pk size for an ack
double compute_ack_pk_size(){
	FIN(compute_ack_pk_size());
	
	Packet			*pkptr;
	int				ack_pk_size;

	pkptr = op_pk_create_fmt("cmac_ack");
	ack_pk_size = op_pk_total_size_get(pkptr);
	op_pk_destroy(pkptr);
	
	FRET(ack_pk_size);
}






//-----------------------------------------------------------
//
//			 RECEIVE FROM RADIO
//
//-----------------------------------------------------------




//Receives a frame after an interruption
void receive_packet_from_radio(){
	FIN(receive_packet_from_radio());
	
	//Pk to receive
	Packet			*payload;
	Packet			*frame;
	//is the frame valid
	int				accepted;
	//Pk fields
	int				source , destination;
	short			frame_type;
	int				frame_id;
	int				next_hop;
	double			power_ratio;
	//CTR
	double			freq;
	double			t_slot;
	double			offset;	
	//data frame
	frame_struct	*frame_ptr;
	//hellos
	int				sink_dist , ktree_dist , branch;
	List			*my_ktree_children_tmp;
	double			sync_power;
	//RTS / CTS / DATA / ACK for nav
	int				duration;
	//transmission time for the flow
	double			transmission_time;
	//next hello
	double			next_hello;
	//Control
	char			msg[100];
	

	//Gets the packet
	frame  = op_pk_get(op_intrpt_strm());

	
	//Some pk fields
	op_pk_nfd_get(frame, FIELD_PK_ACCEPT,		&accepted);
	op_pk_nfd_get(frame, FIELD_PK_SOURCE, 		&source);
	op_pk_nfd_get(frame, FIELD_PK_DESTINATION, 	&destination);
	op_pk_nfd_get(frame, FIELD_PK_TYPE, 		&frame_type);
	op_pk_nfd_get(frame, FIELD_PK_ID,			&frame_id);
	
	//DEBUG
	//debug_print(MEDIUM , DEBUG_NODE , "received a frame from %d to %d (type %s, id %d, accepted %d, reply_required %d , nav main freq %f)\n", source , destination , pk_type_to_str(frame_type , msg, 100) , frame_id , accepted , is_reply_required , get_nav_main_freq());
	
	//Valid frame ?
	if ((!accepted) && ((my_address == destination) || (destination == ADDR_BROADCAST)) ){
		//printf("Frame -> collision (%f)\n" , op_sim_time());
	}
	
	if (accepted){
		//---------------------------------------------------------------------------
		//						REPLY RECEIVED -> BAD or VALID ?
		//---------------------------------------------------------------------------
		//Verify that if we waited a reply, this frame is a valid reply
		//i.e. it does not come from another node, or it presents a bad type....
		switch(last_frame_sent.type){		

			case RTS_PK_TYPE:
				if ((frame_type == CTS_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else
					is_reply_bad = OPC_TRUE;
			break;
			
			case CTS_PK_TYPE:
				if ((frame_type == DATA_UNICAST_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else
					is_reply_bad = OPC_TRUE;
			break;
			
			case DATA_UNICAST_PK_TYPE:
				if ((frame_type == ACK_PK_TYPE) && (destination == my_address) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else
					is_reply_bad = OPC_TRUE;
			break;
			
			case CTR_PK_TYPE:
				//ANY data frame -> ack since a ktree node is allowed to send a frame only when it becomes privileged
				if (((frame_type == DATA_UNICAST_PK_TYPE) || (frame_type == DATA_MULTICAST_PK_TYPE) || (frame_type == HELLO_PK_TYPE))  && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else if ((frame_type == CTR_PK_TYPE) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else if ((frame_type == CTR_ACK_PK_TYPE) && (source == last_frame_sent.destination))
					is_reply_received = OPC_TRUE;
				else if ((frame_type == ACK_PK_TYPE) && (source == last_frame_sent.destination) && (destination == my_address))
					is_reply_received = OPC_TRUE;
				else
					is_reply_bad = OPC_TRUE;
						
				//We are no longer privileged
				if (is_reply_received)
					is_node_privileged = OPC_FALSE;
			break;
		
			default:
				is_reply_bad = OPC_TRUE;
			break;
		}

		
		//---------------------------------------------------------------------------
		//						WHAT TO DO AFTER THIS FRAME ?
		//---------------------------------------------------------------------------
		switch(frame_type){
			case DATA_UNICAST_PK_TYPE :
			case DATA_MULTICAST_PK_TYPE :
			
				op_pk_nfd_get(frame, FIELD_PK_POWER_RATIO , &power_ratio);
				
				
				//Duration of the whole exchange
				transmission_time = 0;
				if (op_pk_nfd_is_set(frame, FIELD_PK_DURATION)){
					op_pk_nfd_get(frame , FIELD_PK_DURATION, &duration);
					if (duration != 0)
						transmission_time = compute_data_ack_time(duration);
				}
				
					
				//If NAV & data reception -> drop the packet (I won't be able to acknowledge it !)
				if ((destination == my_address) || (destination == ADDR_BROADCAST)){
				 	
					//gets the payload
				 	op_pk_nfd_get(frame , FIELD_PK_DATA_PAYLOAD,	&payload);

					
					//Transmission to the upper layer
					if ((!is_frame_id_seen(frame_id)) && ((is_sink) || (MAC_ROUTING == ROUTING_MAC_NO))){
						debug_print(LOW, DEBUG_DATA, "The data frame was received by the sink (id %d)\n", frame_id);
						op_pk_send(op_pk_copy(payload), STREAM_TO_UP);
					}
					
					//Forwarding (max power, since we have no info)
					else if (!is_frame_id_seen(frame_id)){
						next_hop = get_next_hop();
						if (next_hop != ADDR_BROADCAST)
							prepare_data_frame(payload , frame_id , next_hop , 1);					
					}
					
					else 
						printf("frame id %d dropped by %d\n", frame_id , my_address);
					
					
					//This frame is marked as seen
					add_frame_id_seen(frame_id);
					
					
					//sends an acknowledgement (unicast + no nav)
					if ((destination != ADDR_BROADCAST) && (is_reply_possible(destination , my_main_frequency)))
						generate_ack(source , frame_id , duration , power_ratio);
				}
				else if (destination != my_address)
					update_nav_time(transmission_time , source , my_main_frequency , duration);
			
			break;
				
				
			//Deletes the corresponding DATA_PK from the buffer -> it was correctly transmitted
			case ACK_PK_TYPE:
			
				//Duration of the whole exchange
				transmission_time = 0;
				if (op_pk_nfd_is_set(frame, FIELD_PK_DURATION)){
					op_pk_nfd_get(frame, FIELD_PK_DURATION, &duration);
					if (duration != 0)
						transmission_time = compute_data_ack_time(duration);
				}
			
				//Registers the ack
				if (destination == my_address){
					del_frame_buffer_with_id(last_frame_sent.frame_id, OPC_TRUE);
				}
				
				//NaV if a reservation is present
				else if (destination != my_address)
					update_nav_time(transmission_time , source , my_main_frequency , duration);
			
			break;
			
			//We must generate a CTS
			case RTS_PK_TYPE:
			
				//Duration of the whole exchange
				op_pk_nfd_get(frame, FIELD_PK_DURATION, 		&duration);
				op_pk_nfd_get(frame, FIELD_PK_POWER_RATIO, 	&power_ratio);
				transmission_time = compute_cts_data_ack_time(duration);
			
				//We received a RTS for us -> we have to send now a CTS to accept the connection
				// -> No other reservation has been done by neighbors
				// -> I am not in communication (I am waiting for a reply for a transmitted frame)
				// -> If we are privileged, our privileged time has not expired
				//
				if ((destination == my_address) && (is_reply_possible(destination , my_main_frequency)) && (!is_reply_required) && (!is_node_privileged))
					generate_cts(source , duration , frame_id , power_ratio);
			

				//debug
				else if (destination == my_address)
					debug_print(LOW , DEBUG_DATA , "no reply authorized: reply_possible (%d), is rep_required (%d), piviledged %d\n" , is_reply_possible(destination , my_main_frequency) , is_reply_required , is_node_privileged);
			
				//exchange : RTS - CTS - DATA - ACK
				else if (destination != my_address)
					update_nav_time(transmission_time , source , my_main_frequency , duration);

			break;
			
			//We can send the DATA -> place it in the next_frame_to_send
			//The interruption will leave the current state, and we will enter in transmission for the data frame
			case CTS_PK_TYPE:
			
				//Duration of the whole exchange
				op_pk_nfd_get(frame, FIELD_PK_DURATION, &duration);
				transmission_time = compute_data_ack_time(duration);
				
			
				//We received a CTS for us -> we have to send now the data packet
				//NB: it is unicast because multicast frame are sent in ADDR_BROADCAST, wihtout RTS / CTS
				if ((destination == my_address) && (is_reply_possible(destination , my_main_frequency)) && (!is_frame_buffer_empty())){
					frame_ptr = get_unicast_frame_buffer(0);
					if (frame_ptr != NULL)
						change_next_frame(*frame_ptr);
				}

				//A particular case : we received a CTS and meanwhile, the data packet we wanted to send was timeouted and deleted
				else if ((destination == my_address) && (is_reply_possible(destination , my_main_frequency))){
					
					debug_print(LOW, DEBUG_CONTROL , "ERROR: we received a CTS and we do not have any data frame to transmit\n");
					print_unicast_frame_buffer(DEBUG_CONTROL);
					print_multicast_frame_buffer(DEBUG_CONTROL);
				}
			
				//exchange : RTS - CTS - DATA - ACK
				else if (destination != my_address)
					update_nav_time(transmission_time , source , my_main_frequency , duration);

			break;
			
			//We become privileged node
			//-> automatically, we will send a DATA_PK (or a CTR if we have none)
			case CTR_PK_TYPE:
				op_pk_nfd_get(frame , FIELD_PK_CTR_FREQ, 	&freq);
				op_pk_nfd_get(frame , FIELD_PK_CTR_TSLOT, 	&t_slot);
				op_pk_nfd_get(frame , FIELD_PK_CTR_OFFSET, 	&offset);
				
				//Multi-channel -> this ktree node is in privileged mode (using another frequency)
				if (nb_channels > 1)
					transmission_time 		= t_slot;
				
				//Single channel -> reserves the medium for the reply (which will be sent through this channel)
				else
					transmission_time =  SIFS + PROPAGATION_DELAY + (double)MTU_MAX / operational_speed;
				
				
				
				if ((destination == my_address) && (is_reply_possible(destination , my_main_frequency))){
					
					//the node becomes privileged
					is_node_privileged 			= OPC_TRUE;
					time_start_privileged		= op_sim_time();
					slot_privileged_duration	= t_slot;
					slot_privileged_offset		= offset;
					my_privileged_frequency 	= freq;
					
					//Error
					if (!is_in_ktree)
						update_is_in_ktree();

					
					//Schedules the end of the privileged mode
					if (slot_privileged_duration > offset){
						op_intrpt_schedule_self(op_sim_time() + (slot_privileged_duration - slot_privileged_offset) * PRIVILEGED_MIN_TIME_RATIO , 	PRIVILEGED_MIN_CODE);
						op_intrpt_schedule_self(op_sim_time() + (slot_privileged_duration - slot_privileged_offset), 								PRIVILEGED_MAX_CODE);
					}
					else
						op_intrpt_schedule_self(op_sim_time() , PRIVILEGED_MAX_CODE);
					//debug_print(LOW , DEBUG_NODE , "duration : %f/%f -> min %f max %f\n",  slot_privileged_duration , slot_privileged_offset  , (slot_privileged_duration - offset) * PRIV_MIN_RATIO , (slot_privileged_duration - offset) );
					
					
					//Multi channel case (CTR_ACK -> in F1+F2 if no data)
					if (nb_channels > 1)					
						generate_ctr_ack(source , frame_id , 0);
					
					//No data frame -> ack to send (max power)
					//No ack if I have already finished my slot -> I will send a CTR which will act as a CTR-ACK
					else if ((is_frame_buffer_empty()) && ((slot_privileged_duration - slot_privileged_offset > 0) || (get_ktree_child()== ADDR_BROADCAST))){
						generate_ack(source , frame_id , 0 , 1);
					}
					
				}
				
				else if (destination != my_address)
					update_nav_time(transmission_time , source , freq , 0);
					
			break;
		   	
			case CTR_ACK_PK_TYPE:
				//A node which sends a CTR-ACK will become unavailable during t_slot
				//Then, it will send a CTR to indicate that it will privilege receiver
				op_pk_nfd_get(frame , FIELD_PK_CTR_FREQ, 	&freq);
				op_pk_nfd_get(frame , FIELD_PK_CTR_TSLOT, 	&t_slot);
				
				//And I will update this only if it comes from the 'normal' frequency
				//If it comes throug the privileged frequency -> I already set this NAV (with an higher value since I know that I is busy 2*t_slot)
				if (is_main_freq_active(STREAM_TO_RADIO))
					update_nav_time(t_slot , source , freq , 0);
			//TAG
			break;
			
			
			//Nothing to do, we just ignore the packet
			case CTR_END_PK_TYPE:			
			break;
			
			
			//Updates the neighborhood table
			case HELLO_PK_TYPE:
				op_pk_nfd_get(frame , FIELD_PK_HELLO_NEXT, 	&next_hello);
			
				if (destination != ADDR_BROADCAST){
					op_sim_end("An hello is sent in unicast" , "not in ADDR_BROADCAST", "please correct the bug", "");
				}
				op_pk_nfd_get(frame , FIELD_PK_HELLO_SINK_DIST, 	&sink_dist);
				op_pk_nfd_get(frame , FIELD_PK_HELLO_KTREE_DIST, 	&ktree_dist);
				op_pk_nfd_get(frame , FIELD_PK_HELLO_SYNC_POWER, 	&sync_power);
				my_ktree_children_tmp = create_my_ktree_children_from_packet(frame);
				update_neighborhood_table(source , sink_dist , ktree_dist , sync_power , branch , my_ktree_children_tmp , next_hello);
			
			break;
				
			//Reception of a sync frame from the sink 
			//in order to select ktree nodes
			case SYNC_PK_TYPE:			
				op_pk_nfd_get(frame , FIELD_PK_SYNC_BRANCH, 	&my_branch);
			
				my_sync_rx_power = last_rx_power * 1E14;
				debug_print(LOW , DEBUG_NODE , "%d -> SYNC Level reception : %f , branch %d\n", my_address , my_sync_rx_power , my_branch);
				
			break;
				
			default:
				snprintf(msg , 100, "TYPE %d" , frame_type);
				op_sim_end("Unknown received packet" , msg , "" , "");
			break;
		}
	}

	//This packet became useless -> destroy it !
	op_pk_destroy(frame);
	
	FOUT;
}



















//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												INTERRUPTIONS											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------















//-----------------------------------------------------------
//
//			  INTERRUPTIONS
//
//-----------------------------------------------------------



//handle all interruptions when It does not depend on the state machine
void interrupt_process(){
	FIN(interrupt_process());
	
	//control
	char		msg[100];
	//debug
	Boolean		old;
	//reception power 
	double		new_rx_power;
	//next hello to generate
	double		next_hello;
	
	if (DEBUG_STATE_MACHINE)
		debug_print(MAX , DEBUG_GLOBAL, "type %d (self %d, stat %d , pk %d)\n", op_intrpt_type() , OPC_INTRPT_SELF , OPC_INTRPT_STAT , OPC_INTRPT_STRM);

	switch (op_intrpt_type()){
	
		//A PACKET WAS RECEIVED !
		case OPC_INTRPT_STRM :
			switch (op_intrpt_strm()){
				case STREAM_FROM_RADIO :
					receive_packet_from_radio();
				break;
				
				case STREAM_FROM_UP:
					receive_packet_from_up();
				break;
				
				default:
					op_sim_end("An unregistered stream sent you a packet" , "" , "" , "");
				break;
			}	
		break;
		
		//Change in the medium state
		case OPC_INTRPT_STAT :
			
			switch(op_intrpt_stat()){
				
				//signal from radio receiver (and registers the power of the last received packet)
				case STAT_FROM_RX :
					new_rx_power = op_stat_local_read(op_intrpt_stat()); 
					old = 	is_rx_busy;

					if (new_rx_power > rx_power_threshold){
						is_rx_busy 		= OPC_TRUE;
						last_rx_power 	= new_rx_power;
						//debug_print(MAX, DEBUG_RADIO , "last_rx_power %f -> %f\n", last_rx_power , new_rx_power);
					}
					else
						is_rx_busy 		= OPC_FALSE;
				
					//debug_print(MEDIUM , DEBUG_RADIO , "rx_busy %d -> %d (rx pow %f)\n", old , is_rx_busy , new_rx_power * 1E14);
				break;
				
				//Signal from my busy tone receiver	
				case STAT_FROM_RX_BUSY_TONE :
				
					new_rx_power = op_stat_local_read(op_intrpt_stat()); 
					old = is_busy_tone_rx;
					is_busy_tone_rx	= (new_rx_power > rx_power_threshold);	
					if (old != is_busy_tone_rx)
						debug_print(LOW , DEBUG_RADIO , "busy tone %d -> %d (power %f, threshold %f)\n", old , is_busy_tone_rx , new_rx_power*1E14 , rx_power_threshold*1E14);
					
				break;
				
				//2 transmitters but considered logicaly as one single transmitter with a different antenna
				case STAT_FROM_TX_DIREC_SYNC:
				case STAT_FROM_TX :
					old = is_tx_busy ;				
				
					is_tx_busy = (op_stat_local_read(op_intrpt_stat()) == 1.0);
				
					//debug_print(MEDIUM , DEBUG_RADIO , "tx_busy %d -> %d\n", old , is_tx_busy);
				break;
				
				//End of busy tone -> we send another packet
				case STAT_FROM_TX_BUSY_TONE:
					
				
					if ((op_stat_local_read(op_intrpt_stat()) != 1.0) && (is_busy_tone_tx)){
						maintain_busy_tone(1E-6);						
				
						debug_print(MEDIUM , DEBUG_RADIO , "keeps on maintaining activity on the busy_tone tx\n");
					}
				break;
					
				default :
					snprintf(msg, 100, "We are not configured to handle the stat from the line %d\n", op_intrpt_stat());
					op_sim_end(msg, "" , "" , "");
			}
		break;
		
		//SELF INTERRUPTS
		case OPC_INTRPT_SELF:
		
			//CTR from the sink
			if (op_intrpt_code() == SINK_CTR_CODE){
				generate_ctr();
				
				//The next CTR from the sink (if several channels, the period of CTR should be reduced)
				if (nb_channels > 1)
					op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration * BETA /  (nb_channels - 1) + MAX_CTR_DELAY_FROM_SINK, SINK_CTR_CODE);
				else
					op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration * BETA + MAX_CTR_DELAY_FROM_SINK, 						SINK_CTR_CODE);
			}

			//SYNC from the sink
			if (op_intrpt_code() == SINK_SYNC_CODE)
				generate_sync();

		
			//HELLO
			if (op_intrpt_code() == HELLO_PK_CODE){
				
				//The next HELLO
				next_hello = HELLO_PK_PERIOD - op_dist_uniform(HELLO_PK_PERIOD / 10);
				
				//prepares the packet
				generate_hello(next_hello);
				
				//schedules the next interruption
				op_intrpt_schedule_self(op_sim_time() + next_hello , HELLO_PK_CODE);
			}
			
			
			//privileged END !
			if (op_intrpt_code() == PRIVILEGED_MAX_CODE){
			
				//End interruption (we have also a min_time interruption)
				if ((is_node_privileged) && (time_start_privileged + slot_privileged_duration <= op_sim_time()))
					generate_ctr();
			}
			
			//Returns to the main frequency
			if (op_intrpt_code() == MAIN_FREQ_RETURN_CODE)			
				change_tx_rx_freq(my_main_frequency , my_main_bandwidth , STREAM_TO_RADIO);
		
			
			
		break;
		
		//Stats, debug ...
		case OPC_INTRPT_ENDSIM :
			//direct function
			end_sim();
		break;
	
		
		//no default -> some interruptions can be managed directly by a particular state
		default:
		break;
	}
	FOUT;
}



//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												STATISTICS												  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------





//-----------------------------------------------------------
//
//			   ROUTES MANAGEMENT
//
//-----------------------------------------------------------


//Prints the content of a route (route_length, source, ..., destination)
void mac_print_route(List* route_tmp){
	FIN(mac_print_route(List* route_tmp));
	
	int		i;
	int		*int_ptr;

	printf("ROUTE : ");
	for(i=0 ; i < op_prg_list_size(route_tmp) ; i++){
		int_ptr = op_prg_list_access(route_tmp, i);
	
		printf(" %d" , *int_ptr);
		}
	printf("\n");

	FOUT;
}


//returns the route length
short get_route_length(List* route_tmp){
	FIN(get_route_length(List* route_tmp));
	
	int		*int_ptr;
	
	//route length -> firt elem
	int_ptr = op_prg_list_access(route_tmp , 0);
	FRET(*int_ptr);
}


//Returns the average route length
double get_average_route_length(List *route_list){
	FIN(get_average_route_length(List *route_list));
	
	//final values
	int		value = 0;
	int		nb_routes = 0;
	//Elems
	int		*int_ptr;
	List	*route_tmp;
	//control
	int		i;
	
	
	for(i=0 ; i < op_prg_list_size(route_list) ; i++){
	
		//Gets the it^h route
		route_tmp = op_prg_list_access(route_list , i);
		
		//Its length
		int_ptr = op_prg_list_access(route_tmp , 0);
		
		//Update values
		value +=  *int_ptr;
		if (*int_ptr != 0)
			nb_routes++;
	}
	
	FRET(value / nb_routes);
}


//is addr in the route ?
Boolean is_in_route(List* route_tmp , int addr){
	FIN(is_in_route(List* route_tmp , int addr));
	
	int		i;
	int		*int_ptr;
	
	//NB : the first element is the route length
	for(i=1 ; i < op_prg_list_size(route_tmp) ; i++){
		int_ptr = op_prg_list_access (route_tmp , i);
		if (*int_ptr == addr)
			FRET(OPC_TRUE);
	}
	FRET(OPC_FALSE);
}

//returns the ratio of routes which pass through addr
double get_ratio_of_traffic(List* route_list , int addr){
	FIN(get_ratio_of_traffic(List* route_list , int addr));
	
	//final values
	int		value = 0;
	int		nb_routes = 0;
	//Elems
	int		*int_ptr;
	List	*route_tmp;
	//control
	int		i;
	
	
	for(i=0 ; i < op_prg_list_size(route_list) ; i++){
	
		//Gets the it^h route
		route_tmp = op_prg_list_access(route_list , i);
		
		//Its length
		if (is_in_route(route_tmp , addr))
			value ++;

		//Number of routes
		int_ptr = op_prg_list_access(route_tmp , 0);
		if (*int_ptr != 0)
			nb_routes++;
	}
	
	FRET( (double)value / (double)nb_routes);
}











//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												DEBUG													  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------







//-----------------------------------------------------------
//
//			   			TOOLS
//
//-----------------------------------------------------------



//infinity conversion for debug messages
double convert_double(double value){
	FIN(convert_double(double value));
	
	if (value == OPC_DBL_INFINITY)
		FRET(-1);
	FRET(value);
}

//infinity conversion for debug messages
int convert_int(int value){
	FIN(convert_int(int value));
	
	if (value == OPC_INT_INFINITY)
		FRET(-1);
	FRET(value);
}



//-----------------------------------------------------------
//
//			   DEBUG FUNCTIONS
//
//-----------------------------------------------------------

//Converts a pk_type in string
char* pk_type_to_str(short pk_type , char *msg, int length){
	FIN(pk_type_to_str(short pk_type , char *msg, int length));

	switch(pk_type){
		case RTS_PK_TYPE:
			strncpy(msg, "RTS", length);
		break;
		case CTS_PK_TYPE:
			strncpy(msg, "CTS", length);
		break;
		case CTR_PK_TYPE:
			strncpy(msg, "CTR", length);
		break;
		case CTR_ACK_PK_TYPE:
			strncpy(msg, "CTR-ACK", length);
		break;
		case CTR_END_PK_TYPE:
			strncpy(msg, "CTR-END", length);
		break;
		case ACK_PK_TYPE:
			strncpy(msg, "ACK", length);
		break;
		case DATA_UNICAST_PK_TYPE:
			strncpy(msg, "DATA-UNI", length);
		break;
		case DATA_MULTICAST_PK_TYPE:
			strncpy(msg, "DATA-MULTI", length);
		break;
		case HELLO_PK_TYPE:
			strncpy(msg, "HELLO", length);
		break;
		case SYNC_PK_TYPE:
			strncpy(msg, "SYNC", length);
		break;
		default:
			snprintf(msg, length, "%d unknown", pk_type);
		break;
	}

	FRET(msg);
}

// Print all debug messages classified in different files
void debug_print(const int level, const int type , const char* fmt, ...){	
	FIN(debug_print(const int level, const int type , const char* fmt, ...));
	
	FILE		*pfile;
	va_list 	argptr;
	double		time = op_sim_time();
	
	//Special case: we call debug_print after having closed the debug file (this is the simulation end)
	if (op_intrpt_type() == OPC_INTRPT_ENDSIM)
		FOUT;
	
	//error
	if ((type <0) || (type > DEBUG_NODE))
		op_sim_end("Error, you specify an unkwnown type for debug_print()", "", "", "");

	//Prepares the args
	va_start(argptr, fmt);	
	
	//Particular case of my_debug_file (ths file is not shared with other nodes)
	if (type != DEBUG_NODE)
		pfile = debug_files[type];
	else
		pfile = my_debug_file;
	
	
	if (level <= DEBUG)	{			
		//Normal debug
		if (type != DEBUG_GLOBAL){
			fprintf(pfile , "[%4ds , "	, (int) floor(time));
			fprintf(pfile , "%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
			fprintf(pfile , "%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
			fprintf(pfile , "%4.1i] "	, my_address);	
			vfprintf(pfile , fmt, argptr);     
		}
		
		
		//print on the console some particular debug messages 
		if (OPC_FALSE){
			printf("[%4ds , "	, (int) floor(time));
			printf("%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
			printf("%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
			printf("%4.1i] "	, my_address);	
			vprintf(fmt, argptr);   
		}
		
		//print some particular message per node
		if (OPC_FALSE){
			fprintf(my_debug_file , "[%4ds , "	, (int) floor(time));
			fprintf(my_debug_file , "%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
			fprintf(my_debug_file , "%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
			fprintf(my_debug_file , "%4.1i] "	, my_address);	
			vfprintf(my_debug_file , fmt, argptr);     
		}
		
		//put all debugs in a gobal file (useful sometimes to see all the events)
		if (OPC_TRUE){
			fprintf(debug_files[DEBUG_GLOBAL] , "[%4ds , "	, (int) floor(time));
			fprintf(debug_files[DEBUG_GLOBAL] , "%4dms , "	, (int) (floor(time * 1E3) - 1E3 * floor(time)));
			fprintf(debug_files[DEBUG_GLOBAL] , "%4dus , "	, (int) (floor(time * 1E6) - 1E3 * floor(time * 1E3)));
			fprintf(debug_files[DEBUG_GLOBAL] , "%4.1i] "	, my_address);	
			vfprintf(debug_files[DEBUG_GLOBAL] , fmt, argptr);     
		}
		
		//fush the printed messages (for all opened file pointers)
		fflush(NULL);	
	}
	
	va_end(argptr);
	FOUT;
}	



//opens a debug file
void open_debug_file(FILE **fout , const char* fmt, ...){	
	FIN(open_debug_file(FILE **fout , const char* fmt, ...));
	
	char	filename[100];
	char	msg[100];	
	va_list argptr;
	
	//The file was already opened -> nothing to do
	if (*fout != NULL)
		FOUT;
	
	//Args
	va_start(argptr, fmt);
	
	//gets the filename
	strncpy(filename, "", 100);
	vsnprintf(filename , 100, fmt, argptr);     
	
	//And open it !
	*fout = fopen(filename, "w");
	if (*fout == NULL){
		snprintf(msg, 100, "%s -> %s", filename , strerror(errno));
		op_sim_end("I cannot open the debug file", msg , "" , "");	
	}	
	
	va_end(argptr);
	FOUT;
}












//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------																										  ---------------------------
//---------------------------												END SIMULATION											  ---------------------------
//---------------------------																										  ---------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------
//---------------------------------------------------------------------------------------------------------------------------------------------------------------






//end simulation (debug + eventual stats)
void end_sim(){
	FIN(end_sim());	
	int		i;
	
	if (DEBUG > NO){
		
		//Debug message
		print_neighborhood_table(DEBUG_NODE);
		print_frame_buffer(DEBUG_NODE);

		//write a xfig file
		if (my_stat_id == 0)
			tools_fig_generate();

		
		//Close common debug files !
		if (my_stat_id == 0)
			for (i=0 ; i < 20 ; i++)
				if (debug_files[i] != NULL)
					fclose(debug_files[i]);

		//and the debug file reserved for this particular node
		if (my_debug_file != NULL)
			fclose(my_debug_file);
		
	}
	FOUT;
}













]]>
	</function-block>
	<termination-block>
<![CDATA[

]]>
	</termination-block>
	<states initial-state-id="40">
		<state id="40" x="90" y="90">
			<attribute name="name" type="string" value="INIT"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Ids
Objid	mac_params_comp_attr_objid;
Objid	params_attr_objid;
//Parameters
Objid	chann_params_comp_attr_objid;
Objid	subchann_params_attr_objid;
//transmitters
int		nb_radio;
//Channels
int		num_chann;
Objid	chann_objid;
Objid	sub_chann_objid;
Objid	tx_id , rx_id;
//Control
int		i , j;
char	str[300];
//char	msg[500];
//Statwires
Objid	statwire_objid;
int		num_statwires;
double	threshold;
//for debug files
char	dirname[200];
DIR		*pdir;
char 	log_dir_tmp[FILENAME_LOG_MAX];
//Id
int		intf_id;



	
//-----------------------------------------------
//		   		IDENTIFICATION
//-----------------------------------------------


//Process IDS 	
my_stat_id		= nb_mac_nodes++;


if (cmac_timestamp == 0)
	cmac_timestamp = time(NULL);

//Address
op_ima_obj_attr_get(op_topo_parent(op_id_self()) , "name" , str);
my_address = atoi(str);
op_ima_obj_attr_set (op_id_self(), "Address", my_address);



//-----------------------------------------------
//		   			ROUTING
//-----------------------------------------------


//-----------  IS_KTREE_NODE  --------------

is_in_ktree 				= OPC_FALSE;
my_sink_tree.subtree_size	= 0;
my_sink_tree.parent			= ADDR_INVALID;
my_sink_tree.sink_dist		= SHORT_INFINITY;

//--------------  IS_SINK  -----------------

//The upper process is connected to two out-streams -> It has a SINK process
intf_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_PROC, 0);
if (op_topo_assoc_count(intf_id , OPC_TOPO_ASSOC_OUT , OPC_OBJTYPE_STRM) > 1)
	is_sink = OPC_TRUE;
if (is_sink){
	is_in_ktree 		= OPC_TRUE;
	my_sync_rx_power 	= OPC_DBL_INFINITY;
}



//---------  DISTANCES / ROUTING  ------------

if (is_sink)
	my_sink_tree.sink_dist = 0;
else
	my_sink_tree.sink_dist = pow (2, 4) - 1;

//dist ktree
if (is_in_ktree)
	my_sink_tree.ktree_dist = 0;
else
	my_sink_tree.ktree_dist = pow (2, 4) - 1;






//-----------------------------------------------
//		  		 PARAMETERS
//-----------------------------------------------

//Parameters
op_ima_sim_attr_get(OPC_IMA_INTEGER , "debug_level",			&DEBUG);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "beta",					&BETA);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "RTS",					&RTS_PK_SIZE);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "mac_layer",				&MAC_LAYER);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "nb_channels",			&nb_channels);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "routing",				&MAC_ROUTING);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "ktree_algo",				&KTREE_ALGO);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "busy_tone",				&BUSY_TONE_ACTIVATED);
op_ima_sim_attr_get(OPC_IMA_INTEGER , "nb_branches",			&NB_BRANCHES);

//no ktree-algo if I do not execute CMAC
if (MAC_LAYER != CMAC)
	KTREE_ALGO = KTREE_ALGO_NONE;

//log directory name
if (op_ima_sim_attr_exists("Result_Directory")){
	op_ima_sim_attr_get_str("Result_Directory", 	FILENAME_LOG_MAX, log_dir_tmp);
	set_log_dir(log_dir_tmp);
}
	
//No RTS / CTS -> pk_size set to the infinity value
if (RTS_PK_SIZE == -1)
	RTS_PK_SIZE = OPC_INT_INFINITY;

	
	
if (is_sink){
	op_ima_sim_attr_get(OPC_IMA_DOUBLE ,  "max_time_priv_mode",	&slot_privileged_duration);
	TIME_MAX_PRIVILEGED = slot_privileged_duration * 2;
}
else
	slot_privileged_duration 	= 0;

op_ima_obj_attr_get(op_id_self() ,  "Transmission Power",	&POWER_TX);


//A ktree node is allowed to send packets only when it is privileged
strict_privileged_mode = (MAC_LAYER == CMAC);






//-----------------------------------------------
//		   		PROPERTIES
//-----------------------------------------------

is_node_privileged			= OPC_FALSE;
last_frame_sent.type		= NO_PK_TYPE;
next_frame_to_send.type		= NO_PK_TYPE;

unicast_frame_buffer		= op_prg_list_create();
multicast_frame_buffer		= op_prg_list_create();
my_neighborhood_table		= op_prg_list_create();
my_frame_id_seen			= op_prg_list_create();
my_ktree_children			= op_prg_list_create();
my_nav_list					= op_prg_list_create();



//Backoff distribution initialization
cw 							= MAX_BACKOFF;
backoff_dist 				= op_dist_load("uniform_int" , 0 , cw);
backoff_intrpt				= op_ev_current();

	
//no reservation
is_reply_required 			= OPC_FALSE;

//Power of the last received sync frame
my_sync_rx_power			= 0;

//Power of the last received packet (when rx busy -> !busy)
last_rx_power				= 0;
busy_tone_rx_ignored		= OPC_FALSE;

//next packet == hello
is_hello_to_send 			= OPC_FALSE;

//Branches id
ctr_last_branch 			= 0;
sync_last_branch			= 0;
my_branch					= -1;




//-----------------------------------------------
//		  				 DEBUG
//-----------------------------------------------

if (my_stat_id == 0)
	for(i=0 ; i < 20 ; i++)
		debug_files[i] = NULL;

if (DEBUG > NO){
	if (my_stat_id == 0){
	
		//create debug directories if they do not exist	
		pdir = opendir(get_log_dir());
		if (!pdir)
			mkdir(get_log_dir() , 0777);
		snprintf(dirname , 200, "%s/%s", get_log_dir() , LOG_SUFFIX_NODES);
		pdir = opendir(dirname);
		if (!pdir)
			mkdir(dirname , 0777);
	
		//open the associated debug files
		open_debug_file(&debug_files[DEBUG_GLOBAL] ,	"%s/%d_all.txt" , 		get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_BACKOFF] ,	"%s/%d_backoff.txt" ,	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_DATA] ,		"%s/%d_data.txt" , 		get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_RADIO] ,		"%s/%d_radio.txt" , 	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_CONTROL] ,	"%s/%d_control.txt" ,	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_CMAC] ,		"%s/%d_cmac.txt" , 		get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_HELLO] ,		"%s/%d_hello.txt" , 	get_log_dir(), cmac_timestamp);
		open_debug_file(&debug_files[DEBUG_TIMEOUT] ,	"%s/%d_timeout.txt" ,	get_log_dir(), cmac_timestamp);
	}
	open_debug_file(&my_debug_file,						"%s/%s/%d.txt" , 		get_log_dir(), LOG_SUFFIX_NODES, my_address);
		
}




//-----------------------------------------------
//		  	 	TRANSMISSION
//-----------------------------------------------


//RADIO Parameters
op_ima_obj_attr_get (op_id_self(), "Wireless LAN Parameters", &mac_params_comp_attr_objid);
params_attr_objid = op_topo_child (mac_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);

	
//Parameters
op_ima_obj_attr_get (params_attr_objid, "Data Rate", 						&operational_speed);

//Power reception (to detect radio activity)
op_ima_obj_attr_get (params_attr_objid, "Packet Reception-Power Threshold", &rx_power_threshold);

//Channel
op_ima_obj_attr_get (params_attr_objid, "Channel Settings", &chann_params_comp_attr_objid);
subchann_params_attr_objid = op_topo_child (chann_params_comp_attr_objid, OPC_OBJTYPE_GENERIC, 0);
op_ima_obj_attr_get (subchann_params_attr_objid, "Bandwidth", 				&my_main_bandwidth);	
op_ima_obj_attr_get (subchann_params_attr_objid, "Min frequency", 			&my_main_frequency);	





//-----------------------------------------------
//				DATA RADIO
//-----------------------------------------------


//----- TRANSMISSION ----

nb_radio = op_topo_assoc_count(op_id_self() , OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX);

for (i=0; i<nb_radio ; i++){
	

	tx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX, i);
	if (tx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached transmitter\n", "" , "" , "");

	//Channels nb
	op_ima_obj_attr_get (tx_id, "channel", &chann_objid);

	//id access
	sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RATXCH, 0);

	//Frequency + bandwidth
	op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		my_main_bandwidth);
	op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	my_main_frequency);
	op_ima_obj_attr_set (sub_chann_objid, "power", 			POWER_TX);

}

my_current_tx_power = POWER_TX ;


//----- RECEPTION ----

nb_radio = op_topo_assoc_count(op_id_self() , OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX);

for (i=0; i<nb_radio ; i++){

	rx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX, i);
	if (rx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached receiver\n", "" , "" , "");


	//Nb channels
	op_ima_obj_attr_get (rx_id, "channel", &chann_objid);
	num_chann = op_topo_child_count (chann_objid, OPC_OBJTYPE_RARXCH);
	

	//Frequency + bandwidth of the first received
	for (j = 0; j < num_chann; j++){ 	
		//Id
		sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RARXCH, j);
	
		//Frequency + bandwidth
		op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		my_main_bandwidth);
		op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	my_main_frequency);		
		
		//Reception power threshold
		op_ima_obj_state_set (sub_chann_objid, &rx_power_threshold);
	}
}


//-----------------------------------------------
//				BUSY TONE
//-----------------------------------------------

//Such that one bit is transmitted in 1us
busy_tone_speed = 1E6;

if (OPC_TRUE){

//Transmission
	tx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_OUT, OPC_OBJTYPE_RATX, STREAM_TO_BUSY_TONE);
	if (tx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached transmitter\n", "" , "" , "");

	//Channels nb
	op_ima_obj_attr_get (tx_id, "channel", &chann_objid);

	//id access
	sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RATXCH, 0);

	//Speed
	op_ima_obj_attr_set (sub_chann_objid, "data rate", 		busy_tone_speed);
	op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		my_main_bandwidth * busy_tone_speed / operational_speed);
	op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	my_main_frequency - SHIFT_FREQ_SEPARATION);
	op_ima_obj_attr_set (sub_chann_objid, "power", 			POWER_TX);
	
	//NB: bandwidth in KHz, frequency in MHz
	if (my_main_bandwidth * busy_tone_speed / operational_speed >= 1000 * SHIFT_FREQ_SEPARATION)
		op_sim_end("The bandiwthd separation between the busy tone " , "and the principal radio is too small." , "Please increase the value of SHIFT_FREQ_BUSY_TONE", "to separate sufficiently the channels");

	
//reception	
	rx_id = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_RARX, STREAM_FROM_BUSY_TONE);
	if (rx_id == OPC_OBJID_INVALID)
		op_sim_end("No attached transmitter\n", "" , "" , "");

	//Channels nb
	op_ima_obj_attr_get (rx_id, "channel", &chann_objid);

	//id access
	sub_chann_objid = op_topo_child (chann_objid, OPC_OBJTYPE_RARXCH, 0);

	//Speed
	op_ima_obj_attr_set (sub_chann_objid, "bandwidth", 		my_main_bandwidth * busy_tone_speed / operational_speed);
	op_ima_obj_attr_set (sub_chann_objid, "min frequency", 	my_main_frequency - SHIFT_FREQ_SEPARATION);
}








//-----------------------------------------------
//		   			STATWIRES
//-----------------------------------------------

//for all statswirs (tx, rx, busy tone, normal ...)
num_statwires = op_topo_assoc_count (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE);
for (i = 0; i < num_statwires; i++){
	//Id														*/
	statwire_objid = op_topo_assoc (op_id_self(), OPC_TOPO_ASSOC_IN, OPC_OBJTYPE_STATWIRE, i);
	op_ima_obj_attr_get (statwire_objid, "high threshold trigger", &threshold);
	
	//value
	op_ima_obj_attr_set (statwire_objid, "high threshold trigger", rx_power_threshold);	
}


















//-----------------------------------------------
//		   	SYNCHRO WITH OTHER LAYERS
//-----------------------------------------------

op_intrpt_schedule_self (op_sim_time (), 0);


]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[


]]>
				</value-text>
			</attribute>
		</state>
		<state id="41" x="450" y="90">
			<attribute name="name" type="string" value="IDLE"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[




]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - IDLE2 - %d\n", my_address);

//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - IDLE2 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="52" x="270" y="90">
			<attribute name="name" type="string" value="INFO_SYNCHRO"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
/* Schedule a self interrupt to wait for mac interface 	*/
/* to move to next state after registering				*/
op_intrpt_schedule_self (op_sim_time (), 0);
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[


//----------------------------------------------
//					IDENTIFICATION
//----------------------------------------------



//nodeid/addr conversion
if (nodeid_to_addr_var == NULL)
	nodeid_to_addr_var = op_prg_mem_alloc(sizeof(int) * get_nb_nodes());
nodeid_to_addr_var[my_stat_id] = my_address;


//----------------------------------------------
//					BRANCH LENGTH
//----------------------------------------------


if (my_stat_id == 0)
	MAX_BRANCH_LENGTH = 5;//min_int(BETA + 1 , (int)(pow(nb_mac_nodes , 0.5) / 2) - 1);



//----------------------------------------------
//					SINK 
//----------------------------------------------

//The sink must send periodically a CTR (create it, not forward it)
//NB: let the routing info converge (dist_sink and dist_ktree)
if (is_sink)
	if (MAC_LAYER == CMAC){
		op_intrpt_schedule_self(TIME_BEFORE_HELLO_CONVERGENCE , SINK_CTR_CODE); 
		op_intrpt_schedule_self(op_sim_time() + 0.1 , SINK_SYNC_CODE); 
	}




//----------------------------------------------
//					HELLOS 
//----------------------------------------------

//periodical hello for everyone (initally, shorter hello_interval to decrease convergence delays)
op_intrpt_schedule_self(op_sim_time() + 5.0 + op_dist_uniform(3.0) , HELLO_PK_CODE);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="54" x="690" y="510">
			<attribute name="name" type="string" value="EMISSION"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//----------------------------------------------------------------
//
//				FRAME TRANSMISSION
//
// - The medium is free
// - The backoff was decremented or not required
// - The frame 'next_frame_to_send' is ready to be transmitted
//
//-----------------------------------------------------------------

//Control
char		msg[100];
//Packet
Packet*		frame_pk;

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - EMISSION1 - %d\n", my_address);


//------------------------------------------
//			  TRANSMISSION
//------------------------------------------

//The transmitter is not busy -> we are not in transmission -> we send our packet
//- We have a default state self-transition (if the medium keeps on being used)
//  Consequently we must avoid to send the same frame although the current frame is already in transmission
if (!is_tx_busy){

	//debug
	debug_print(LOW , DEBUG_DATA , "sends a packet to %d (type %s, id %d, my_nav %f, busy %d, power_ratio %f)\n",  next_frame_to_send.destination , pk_type_to_str(next_frame_to_send.type , msg, 100) , next_frame_to_send.frame_id , get_nav_main_freq() , IS_MEDIUM_BUSY , next_frame_to_send.power_ratio);


	//Prepares the packet
	is_tx_busy = OPC_TRUE;
	frame_pk = create_packet(next_frame_to_send);
	
	
	//The reply was sent (if it was a reply!)
	is_reply_required = OPC_TRUE;
	
	// -----  SPECIAL ACTIONS  -----

	
	if (next_frame_to_send.destination == ADDR_BROADCAST)
		print_nav_list(DEBUG_HELLO);
	
	switch (next_frame_to_send.type){
	
		//Ack sent -> no more busy_tone required
		case ACK_PK_TYPE:
			is_busy_tone_tx = OPC_FALSE;
		break;
		
		//RTS sent -> we ignore further busy tone in reception
		case RTS_PK_TYPE:
			busy_tone_rx_ignored = OPC_TRUE;
		break;
		
		//CTS sent -> we activate the busy tone
		case CTS_PK_TYPE:
			maintain_busy_tone(SIFS);
		break;
		
		//Increases power (to 10W, that is enormous and all the nodes will get it)
		//If a node does not receive the SYNC it is not a problem: the branch will not expand to the network extremities
		case SYNC_PK_TYPE:
	
			if (is_sync_direct_antenna)	
				change_antenna_direction(STREAM_TO_DIRECT_SYNC , sync_last_branch);
			else
				change_tx_power(1000 , STREAM_TO_RADIO);
		break;
		
		case HELLO_PK_TYPE:
			is_hello_to_send = OPC_FALSE;
		break;
	}
	
	
	
	// -----  TRANSMISSSION  -----
	if ((next_frame_to_send.type == SYNC_PK_TYPE) && (is_sync_direct_antenna))
		op_pk_send(frame_pk , STREAM_TO_DIRECT_SYNC);
	else 
		op_pk_send(frame_pk , STREAM_TO_RADIO);

	
	//Registers the frame as sent (if a reply is required: ACK/CTS/...)
	last_frame_sent = next_frame_to_send;
	last_frame_sent.released = OPC_FALSE;
	set_next_frame_null();
}
//else -> nothing, we just stay in this state while the transmission and keep to treat other interrupts









//Timeouts -> an interruption will be scheduled when we finished the transmission (the medium becomes idle)
if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - EMISSION1 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[


if (DEBUG_STATE_MACHINE)
	debug_print(MAX , DEBUG_GLOBAL , "ENTER - EMISSION2 - %d\n", my_address);


//Handles the possible interruptions (STREAM || STAT)
interrupt_process();




	
	
//Transmission finished !
if (!is_tx_busy){
	debug_print(MEDIUM , DEBUG_RADIO, "transmission ended\n");


	//-----------------------------------------------------
	//	NORMAL TRANSMISSION POWER
	//-----------------------------------------------------


	//Decrease the power to a normal value
	if (last_frame_sent.type == SYNC_PK_TYPE){
		
		//normal power transmission
		if (!is_sync_direct_antenna)
			change_tx_power(POWER_TX , STREAM_TO_RADIO);
		
		//Next sync if we have a directional antenna
		if ((sync_last_branch != NB_BRANCHES - 1) && (is_sync_direct_antenna)){
			sync_last_branch++;
			generate_sync();
		}
		else
			sync_last_branch = 0;
	}
		
	
	
	//-----------------------------------------------------
	//	MULTI_CHANNEL -> COMMUTES
	//-----------------------------------------------------

	if (nb_channels > 1){
	
		//CTR sent -> changes to the privileged channel
		if (last_frame_sent.type == CTR_PK_TYPE){
			change_tx_rx_freq(my_privileged_frequency , my_main_bandwidth * RATIO_PRIV_BANDWIDTH , STREAM_TO_RADIO);
			
			if (op_ev_valid(main_freq_return_intrpt))
				op_ev_cancel(main_freq_return_intrpt);
			main_freq_return_intrpt = op_intrpt_schedule_self(op_sim_time() + slot_privileged_duration , MAIN_FREQ_RETURN_CODE);
		}
		
		
		//CTR-ACK sent -> changes to the privileged channel
		if ((last_frame_sent.type == CTR_ACK_PK_TYPE) && (last_frame_sent.nb_retry == 0)){
		
			//Channel change
			change_tx_rx_freq(my_privileged_frequency , my_main_bandwidth * RATIO_PRIV_BANDWIDTH , STREAM_TO_RADIO);
			
			//sends a CTR-ACK through the privileged channel if no data frame to send
			if (is_frame_buffer_empty()){
				last_frame_sent.nb_retry++;
				change_next_frame(last_frame_sent);
			}
			
		}
		
		
		
	}
		
		
	//-----------------------------------------------------
	//	Must the node wait a reply for this frame ?
	//-----------------------------------------------------

	//BROADCAST Frame 
	if (last_frame_sent.destination == ADDR_BROADCAST)
		is_reply_required = OPC_FALSE;
	
	//Ack Frame
	else if (last_frame_sent.type == ACK_PK_TYPE)
		is_reply_required = OPC_FALSE;
	
	//CTR
	else if (last_frame_sent.type == CTR_END_PK_TYPE)
		is_reply_required = OPC_FALSE;
	
	else if (last_frame_sent.type == CTR_ACK_PK_TYPE)
		is_reply_required = OPC_FALSE;

	//default behavior	
	else	
		is_reply_required = OPC_TRUE;

	
	
	
	
	//-----------------------------------------------------
	//					Privileged mode
	//-----------------------------------------------------	
	//I sent a CTR-END -> I am no longer priviledged
	if (last_frame_sent.type == CTR_END_PK_TYPE){
		is_node_privileged = OPC_FALSE;
		debug_print(LOW , DEBUG_CONTROL , "the node becomes unpriviledged\n");
	}

	
	
	
	//-----------------------------------------------------
	//						Timeout
	//-----------------------------------------------------	
	//Timeout of a reply is required
	if (is_reply_required){

		//DATA sent -> a ack only is required
		if ((is_node_privileged) && (nb_channels > 1) && (last_frame_sent.type == DATA_UNICAST_PK_TYPE))
			add_frame_timeout(compute_ack_pk_size());
		else 
			add_frame_timeout(MTU_MAX);
	}
		
	//-----------------------------------------------------
	//						Acks
	//-----------------------------------------------------	
	//Deletes the corresponding data frame (no ack required)
	else if ((last_frame_sent.type == DATA_MULTICAST_PK_TYPE) || (last_frame_sent.type == HELLO_PK_TYPE))
		del_frame_buffer_with_id(last_frame_sent.frame_id , OPC_FALSE);
	

}

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - EMISSION2 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="56" x="510" y="270">
			<attribute name="name" type="string" value="DEFER"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Next data frame to send
frame_struct	*frame_ptr;
frame_struct	data_frame;
frame_struct	next_data_frame;
//transmission time
double			time_for_first_data;
double			time_for_second_data;
//Control
char			msg[100];


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - DEFER1 - %d\n", my_address);


//------------------------------------------
//			   GET DATA FRAME
//------------------------------------------


debug_print(MAX , DEBUG_CONTROL , "STATE_DEFER: data_buffer_empty %d, frame_to_send %d (type %s), IS_PK_TO_SEND %d, ktree %d, priviledged %d\n", is_frame_buffer_empty() , next_frame_to_send.type != NO_PK_TYPE , pk_type_to_str(next_frame_to_send.type , msg, 100) ,  IS_PK_TO_SEND , is_in_ktree , is_node_privileged);
if (is_node_privileged)
	debug_print(MAX , DEBUG_CONTROL , "start_priviledged %f, time_min %f, CAN_SLOT_BE_ENDED %d, PRIVILEDGE_END %d (medium %d, high %d)\n", time_start_privileged , slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO , time_start_privileged + slot_privileged_duration * PRIVILEGED_MIN_TIME_RATIO <= op_sim_time() , PRIVILEGED_END , PRIVILEGED_MEDIUM_LIMIT , PRIVILEGED_HIGH_LIMIT);
		

//We have no frame which is scheduled to be transmitted
if (next_frame_to_send.type == NO_PK_TYPE){


	//----------------------------------------------
	//			KTREE NODE & PRIVILEGED 
	//----------------------------------------------
	if (is_node_privileged){
	
		//Buffer empty -> I will lose my priviledged status
		if ((PRIVILEGED_MEDIUM_LIMIT) || (PRIVILEGED_HIGH_LIMIT))
			generate_ctr();

		else if ((is_frame_buffer_empty()) && (!PRIVILEGED_MEDIUM_LIMIT))
			op_sim_end("We should not be in this state if we have nothing to send", "and we cannot end the priviledge mode" , "" , "");
			
		//I send the first data_frame of the queue
		else{
			//first frame
			frame_ptr			= get_frame_buffer(0);
			data_frame 			= *frame_ptr;
			time_for_first_data = compute_rts_cts_data_ack_time(data_frame.pk_size) ;
			
			//An eventual second frame
			frame_ptr	= get_frame_buffer(1);
			if (frame_ptr != NULL){
				next_data_frame 		= *frame_ptr;
				time_for_second_data 	= compute_rts_cts_data_ack_time(next_data_frame.pk_size) ;
			}
			else
				time_for_second_data = 0;
			
			//We have not the time to send this data packet !
			if (time_for_first_data + op_sim_time() >= slot_privileged_duration + time_start_privileged)
				generate_ctr();
			
			else{
				
				//Medium reservation if a second packet has to be transmitted
				if ((time_for_second_data == 0) || (time_for_first_data + time_for_second_data + op_sim_time() >= slot_privileged_duration + time_start_privileged))
					data_frame.duration = 0;
				else
					data_frame.duration = next_data_frame.pk_size;
				
				//Prepare the next transmission
				change_next_frame(data_frame);
			}
			
			
		}
	}
	
	//----------------------------------------------
	//			NORMAL NODE
	//----------------------------------------------
	else if (!is_frame_buffer_empty()){

		//get the first data packet to send
		frame_ptr = get_frame_buffer(0);		
		if (frame_ptr != NULL)
			data_frame = *frame_ptr;
	
		//broadcast frames do not need any RTS
		if ((data_frame.destination == ADDR_BROADCAST) || (data_frame.pk_size  < RTS_PK_SIZE))
			change_next_frame(data_frame);
		
		//Generates a new RTS, it will be automatically registered as the new frame to send
		else{

			generate_rts(data_frame.destination , data_frame.pk_size , data_frame.frame_id , data_frame.power_ratio);

			if (DEBUG >= MAX){
				print_unicast_frame_buffer(DEBUG_DATA);
				print_multicast_frame_buffer(DEBUG_DATA);
			}
		}
	}
	else
		printf("It is strange, I entered in DEFER wihtout any packet to send\n");
}







//debug
debug_print(MEDIUM , DEBUG_DATA , "has a packet to send to %d (type %s, id %d, nb_retry %d)\n", next_frame_to_send.destination , pk_type_to_str(next_frame_to_send.type , msg, 100) , next_frame_to_send.frame_id , next_frame_to_send.nb_retry);



//------------------------------------------
//			   INTER FRAME TIME
//------------------------------------------


//The medium becomes free -> we must wait the inter_frame time
if (!IS_MEDIUM_BUSY){
	if ((is_node_privileged) && ((next_frame_to_send.type == CTR_PK_TYPE) || (next_frame_to_send.type == CTR_END_PK_TYPE)) )
		next_frame_to_send.ifs = PIFS;
	else if ((is_node_privileged) && (nb_channels > 1))
		next_frame_to_send.ifs = 0;
	else if (is_node_privileged)
		next_frame_to_send.ifs = SIFS;
	else if ((next_frame_to_send.type == RTS_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == HELLO_PK_TYPE))
		next_frame_to_send.ifs = DIFS;
	else
		next_frame_to_send.ifs = SIFS;

	//We will verify that the medium remains idle
	debug_print(MEDIUM, DEBUG_BACKOFF, "self interrupt, ifs %f\n", next_frame_to_send.ifs);
	op_intrpt_schedule_self(op_sim_time() + next_frame_to_send.ifs , DEFER_CODE);
}




if (DEBUG_STATE_MACHINE){
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - DEFER1 - %d - timeout %f\n", my_address , next_frame_to_send.ifs *1E6);
	debug_print(LOW, DEBUG_GLOBAL , "%d : %d %d %d %d %d %d %d\n", IS_MEDIUM_BUSY , is_rx_busy , is_tx_busy , get_nav_main_freq() >= op_sim_time() , is_busy_tone_rx , !busy_tone_rx_ignored , BUSY_TONE_ACTIVATED , !is_in_ktree);
	print_nav_list(DEBUG_GLOBAL);
}
]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//The inter-frame time
//double		time_to_wait;



if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - DEFER2 - %d\n", my_address);



//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


//------------------------------------------
//			   BACKOFF
//------------------------------------------

// STAT_INTRPT + !MEDIUM_BUSY -> I must wait the IFS (and not take directly a transition)
// If such an interruptions occurs, we schedule the IFS verification, but don't change the backoff
// Thus, the default behavior is to have an invalid backoff in order to avoid any state transition
my_backoff = -1;



//I try to transmit or decrement the backoff only if :
// -> No transmission (this is never the case since the transmission state is not here)
// -> No reception
// -> The medium was not previously reserved (verify the value of my NAV)
//
if ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE)){


	if (!IS_MEDIUM_BUSY){
		if ((!is_node_privileged) &&     (     (next_frame_to_send.type == RTS_PK_TYPE) || (next_frame_to_send.destination == ADDR_BROADCAST) || ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE))   )      ){

			//Takes a new backoff
			my_backoff = op_dist_outcome (backoff_dist);
		
			//Schedules the backoff interrupt (deletes an eventual old interruption)
			op_ev_cancel_if_pending(backoff_intrpt);			
			backoff_intrpt = op_intrpt_schedule_self(op_sim_time() + SLOT_BACKOFF * my_backoff , BACKOFF_CODE);
	
			//debug
			debug_print(MAX , DEBUG_BACKOFF , "new backoff %d\n", my_backoff);
		}
		else{
			//debug_print(MEDIUM , DEBUG_BACKOFF , "No backoff nedded: privileged %d & \n", (!is_node_privileged));
			//debug_print(MEDIUM , DEBUG_BACKOFF , "rts %d | broadcast %d | data without rts %d\n", (next_frame_to_send.type == RTS_PK_TYPE) , (next_frame_to_send.destination == ADDR_BROADCAST) , ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE)));
			//debug_print(MEDIUM , DEBUG_BACKOFF , "%d = %d & %f < %f\n", next_frame_to_send.type, DATA_UNICAST_PK_TYPE, next_frame_to_send.pk_size, RTS_PK_SIZE);
			debug_print(MEDIUM , DEBUG_BACKOFF , "no backoff required (!priviledged %d, next=rts %d, broadcast %d, data_without_rts %d, rts_thresh %f)\n", !is_node_privileged , next_frame_to_send.type == RTS_PK_TYPE , next_frame_to_send.destination == ADDR_BROADCAST, ((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) && (next_frame_to_send.pk_size < RTS_PK_SIZE)), RTS_PK_SIZE);
			my_backoff = 0;
		}		
	}
	else
		debug_print(MEDIUM , DEBUG_DATA , "the medium is busy, we must wait\n");


	//The medium is busy and we have the priority -> that is not regular !
	if (PRIORITY_AND_MEDIUM_BUSY){
		debug_print(LOW , DEBUG_DATA , "a collision occurred (we have the priority and the medium is busy, we discard the current flow\n");
		
		//Discard the current packet
		set_next_frame_null();
		
	}
}


//------------------------------------------
//		  CANCEL OBSOLETE TRANSMISSIONS
//------------------------------------------

if 	((next_frame_to_send.type == RTS_PK_TYPE) && (is_unicast_frame_buffer_empty())){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: RTS and the frame buffer is empty\n");
	set_next_frame_null();
}


if 	(((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && (!is_in_frame_buffer(next_frame_to_send.frame_id))){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the frame is no longer present in the frame buffer\n");
	set_next_frame_null();
}

if 	(((next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && IS_BROADCAST_FORBIDDEN){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the broadcast is currently not authorized\n");
	set_next_frame_null();
}




if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - DEFER2 - %d (%d, %d)\n", my_address, IS_MEDIUM_BUSY , my_backoff);


//debug_print(MAX , DEBUG_DATA , "busy -> rx_busy %d tx_busy %d nav %f -> %d medium busy %d\n", is_rx_busy , is_tx_busy , get_nav_main_freq() , get_nav_main_freq() > op_sim_time() , IS_MEDIUM_BUSY);

]]>
				</value-text>
			</attribute>
		</state>
		<state id="58" x="270" y="510">
			<attribute name="name" type="string" value="BACKOFF"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "Enter in backoff state\n");


]]>
				</value-text>
			</attribute>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//Inter frame time
//double		time_to_wait;

if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - BACKOFF2 - %d\n", my_address);




//Handles the possible interruptions (STREAM || STAT)
interrupt_process();


//The backoff is finished
if ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == BACKOFF_CODE)){
	debug_print(MEDIUM, DEBUG_BACKOFF , "the backoff is finished, we can transmit our frame\n");
	my_backoff = 0;
}




//------------------------------------------
//			   STOP  BACKOFF
//------------------------------------------

//The medium is busy OR medium reserved -> stop the backoff
if ((op_ev_valid(backoff_intrpt)) && (IS_MEDIUM_BUSY)){
	
	//Stores the remaining backoff
	my_backoff = ceil((op_ev_time(backoff_intrpt) - op_sim_time()) / SLOT_BACKOFF);

	//disable the previous backoff interrupt (the backoff must not be decremented during medium activity)
	op_ev_cancel(backoff_intrpt);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "stoping backoff %d (busy %d, nav %3f)\n", my_backoff , is_rx_busy , (get_nav_main_freq() - op_sim_time()) * 1E6);
}





//------------------------------------------
//			  RESTART  BACKOFF
//------------------------------------------

//the medium becomes idle OR reservation expired -> resume the backoff
if ((!op_ev_valid(backoff_intrpt)) && (!IS_MEDIUM_BUSY) && ((op_intrpt_type() == OPC_INTRPT_SELF) && (op_intrpt_code() == DEFER_CODE))){

	//Schedules the backoff interrupt
	backoff_intrpt = op_intrpt_schedule_self(op_sim_time() + SLOT_BACKOFF * my_backoff , BACKOFF_CODE);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "resuming backoff %d (busy %d nav %3f)\n", my_backoff , is_rx_busy , (get_nav_main_freq() - op_sim_time()) * 1E6);
}







//------------------------------------------
//			   INTER FRAME TIME
//------------------------------------------


//The medium becomes free -> we must wait the inter_frame time
if ((!op_ev_valid(backoff_intrpt)) && (!IS_MEDIUM_BUSY) && (!op_ev_valid(defer_intrpt))){

	//We will verify that the medium remains idle (inter frame space was already computed in the state DEFER)
	defer_intrpt = op_intrpt_schedule_self(op_sim_time() + next_frame_to_send.ifs , DEFER_CODE);

	//debug
	debug_print(MEDIUM , DEBUG_BACKOFF , "defer %f for the inter frame time\n", next_frame_to_send.ifs * 1E6);
}






//------------------------------------------
//		  CANCEL OBSOLETE TRANSMISSIONS
//------------------------------------------
// This case can occur if we received an ack athough we already entered in backoff mode

if 	((next_frame_to_send.type == RTS_PK_TYPE) && (is_unicast_frame_buffer_empty())){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: RTS and the frame buffer is empty\n");
	set_next_frame_null();
}


if 	(((next_frame_to_send.type == DATA_UNICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && (!is_in_frame_buffer(next_frame_to_send.frame_id))){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the frame is no longer present in the frame buffer\n");
	set_next_frame_null();
}

if 	(((next_frame_to_send.type == DATA_MULTICAST_PK_TYPE) || (next_frame_to_send.type == DATA_MULTICAST_PK_TYPE)) && IS_BROADCAST_FORBIDDEN){
	debug_print(LOW , DEBUG_DATA , "Tranmission canceled: the broadcast is currently not authorized\n");
	set_next_frame_null();
}




//------------------------------------------
//			   DEBUG
//------------------------------------------

/*
//Debug
debug_print(MAX , DEBUG_BACKOFF , "IS_BACK_TO_DEFER %d backoff %d (conditions %d %d %d %d)\n", IS_BACK_TO_DEFER , my_backoff , next_frame_to_send.type == CTR_PK_TYPE , IS_FRAME_RECEIVED , IS_REPLY_TO_SEND , is_rx_busy);


debug_print(MAX , DEBUG_BACKOFF , "TYPE %d (self %d stream %d stat %d), code %d\n", op_intrpt_type() , OPC_INTRPT_SELF , OPC_INTRPT_STRM , OPC_INTRPT_STAT , op_intrpt_code());
if (op_intrpt_type() == OPC_INTRPT_STRM){
	debug_print(MAX , DEBUG_BACKOFF , "stream %d\n", op_intrpt_strm());
	debug_print(MAX , DEBUG_BACKOFF , "%d %d %d %d %d\n", op_intrpt_type() , OPC_INTRPT_STRM , (op_intrpt_type() == OPC_INTRPT_STRM) , (op_intrpt_strm() == STREAM_FROM_RADIO) , IS_FRAME_RECEIVED);
}
*/






//---------------------------------------------
//		EXIT BACKOFF -> CANCEL the INTRPT
//---------------------------------------------

if ((IS_BACK_TO_DEFER) || (TRANSMISSION_CANCELED))
	if (op_ev_valid(backoff_intrpt))
		op_ev_cancel(backoff_intrpt);












if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - BACKOFF2 - %d\n", my_address);
]]>
				</value-text>
			</attribute>
		</state>
		<state id="62" x="810" y="150">
			<attribute name="name" type="string" value="END_TRANSMIT"/>
			<attribute name="Enter Execs" type="textlist">
				<value-text>
<![CDATA[
//Control
char	msg[100];



//Just a debug message when we start to wait the reply for one of our frame
if (is_reply_required){
	//debug
	debug_print(MAX , DEBUG_RADIO , "%s sent, it must wait a reply\n", pk_type_to_str(last_frame_sent.type , msg, 100));


	//We did not received yet a reply for our transmission (we just leave it !)
	is_reply_received = OPC_FALSE;
}
]]>
				</value-text>
			</attribute>
			<attribute name="status" type="toggle" value="1"/>
		</state>
		<state id="63" x="1050" y="90">
			<attribute name="name" type="string" value="WAIT_NEXT"/>
			<attribute name="Exit Execs" type="textlist">
				<value-text>
<![CDATA[
//Control
char		msg[100];


//Default (will change of the received packet is not that we expect
is_reply_bad = OPC_FALSE;


if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "ENTER - WAIT_NEXT2 - %d\n", my_address);


//Handles the possible interruptions (STREAM || STAT)
//NB: if we had a timeout, and we received a packet, we can answer to the received packet and discard temporarily the retransmission (rather delay it)
interrupt_process();



//The frame timeouted -> we must retransmit it
if ((is_reply_bad) || (IS_FRAME_TIMEOUT)){
	
	//Failed -> we increments the nb_retry for the corresponding data_frame
	//NB: it is a unicast frame since multicast frame are not acknowledged
	if ((last_frame_sent.type == DATA_UNICAST_PK_TYPE) || (last_frame_sent.type == RTS_PK_TYPE))
		increment_nb_rety_unicast_frame_buffer(last_frame_sent.frame_id);
		
	debug_print(LOW , DEBUG_TIMEOUT , "the flow to %d is broken for one of my frame (type %s, retry %d , id %d, next type %d) (timeout %d bad_reply %d)\n", last_frame_sent.destination , pk_type_to_str(last_frame_sent.type, msg, 100) , last_frame_sent.nb_retry , last_frame_sent.frame_id , next_frame_to_send.type , IS_FRAME_TIMEOUT , is_reply_bad);
	
	
	//CTR -> we must retransmit it
	if ((last_frame_sent.type == CTR_PK_TYPE) && (last_frame_sent.nb_retry < MAX_NB_RETRY)){
	
		//increase the nb of retries
		last_frame_sent.nb_retry ++;
		
		//And retransmission !
		change_next_frame(last_frame_sent);
		
		//Failed -> go to the main channel
		if (nb_channels > 1)
			change_tx_rx_freq(my_main_frequency , my_main_bandwidth * RATIO_PRIV_BANDWIDTH , STREAM_TO_RADIO);
	}
	

	//Error time when a packet failed
	if (!is_node_privileged)
		update_nav_time(EIFS , my_address , my_main_frequency , -1);
	
	
	//The frame timeouted: no more busy tone in transmission
	is_busy_tone_tx 		= OPC_FALSE;
}



//The medium is no longer reserved for this flow
if ((is_reply_received) || (IS_FRAME_TIMEOUT) || is_reply_bad) {
	is_reply_required 		= OPC_FALSE;
	
	//The transmission whatever it is succefull or not is ended: we must take into account the current busy tones
	busy_tone_rx_ignored 	= OPC_FALSE;
}








if (DEBUG_STATE_MACHINE)
	debug_print(LOW , DEBUG_GLOBAL , "EXIT - WAIT_NEXT2 - %d\n", my_address);

]]>
				</value-text>
			</attribute>
		</state>
	</states>
	<transitions>
		<transition source-state-id="40" destination-state-id="52" label-x="181" label-y="88">
			<path-point x="116" y="88"/>
			<path-point x="243" y="88"/>
			<attribute name="name" type="string" value="tr_292"/>
		</transition>
		<transition source-state-id="52" destination-state-id="41" label-x="360" label-y="88">
			<path-point x="297" y="90"/>
			<path-point x="428" y="90"/>
			<attribute name="name" type="string" value="tr_293"/>
		</transition>
		<transition source-state-id="41" destination-state-id="56" label-x="484" label-y="167">
			<path-point x="436" y="94"/>
			<path-point x="506" y="265"/>
			<attribute name="name" type="string" value="tr_307"/>
			<attribute name="condition" type="string" value="IS_PK_TO_SEND || PRIVILEGED_END"/>
		</transition>
		<transition source-state-id="56" destination-state-id="54" label-x="600" label-y="416">
			<path-point x="506" y="268"/>
			<path-point x="687" y="509"/>
			<attribute name="name" type="string" value="tr_308"/>
			<attribute name="condition" type="string" value="GO_TO_SEND"/>
		</transition>
		<transition source-state-id="56" destination-state-id="58" label-x="409" label-y="391">
			<path-point x="510" y="274"/>
			<path-point x="274" y="501"/>
			<attribute name="name" type="string" value="tr_309"/>
			<attribute name="condition" type="string" value="GO_TO_BACKOFF"/>
		</transition>
		<transition source-state-id="58" destination-state-id="54" label-x="485" label-y="565">
			<path-point x="278" y="513"/>
			<path-point x="666" y="515"/>
			<attribute name="name" type="string" value="tr_310"/>
			<attribute name="condition" type="string" value="!IS_BACK_TO_DEFER &amp;&amp; !TRANSMISSION_CANCELED  &amp;&amp; (my_backoff == 0)"/>
		</transition>
		<transition source-state-id="58" destination-state-id="56" label-x="291" label-y="324">
			<path-point x="267" y="503"/>
			<path-point x="300" y="334"/>
			<path-point x="480" y="277"/>
			<attribute name="name" type="string" value="tr_312"/>
			<attribute name="condition" type="string" value="!TRANSMISSION_CANCELED &amp;&amp; IS_BACK_TO_DEFER"/>
		</transition>
		<transition source-state-id="54" destination-state-id="62" label-x="755" label-y="323">
			<path-point x="692" y="497"/>
			<path-point x="817" y="149"/>
			<attribute name="name" type="string" value="tr_314"/>
			<attribute name="condition" type="string" value="!is_tx_busy"/>
		</transition>
		<transition source-state-id="62" destination-state-id="63" label-x="918" label-y="85">
			<path-point x="807" y="134"/>
			<path-point x="1042" y="82"/>
			<attribute name="name" type="string" value="tr_315"/>
			<attribute name="condition" type="string" value="is_reply_required"/>
		</transition>
		<transition source-state-id="63" destination-state-id="62" label-x="1013" label-y="162">
			<path-point x="1047" y="99"/>
			<path-point x="827" y="151"/>
			<attribute name="name" type="string" value="tr_316"/>
			<attribute name="condition" type="string" value="is_reply_received || IS_FRAME_TIMEOUT || is_reply_bad"/>
		</transition>
		<transition source-state-id="62" destination-state-id="41" label-x="643" label-y="70">
			<path-point x="794" y="147"/>
			<path-point x="444" y="73"/>
			<attribute name="name" type="string" value="tr_317"/>
			<attribute name="condition" type="string" value="!is_reply_required&amp;&amp; !IS_PK_TO_SEND &amp;&amp; ! PRIVILEGED_END"/>
		</transition>
		<transition source-state-id="62" destination-state-id="56" label-x="648" label-y="199">
			<path-point x="817" y="159"/>
			<path-point x="520" y="266"/>
			<attribute name="name" type="string" value="tr_318"/>
			<attribute name="condition" type="string" value="!is_reply_required &amp;&amp; (IS_PK_TO_SEND || PRIVILEGED_END)"/>
		</transition>
		<transition source-state-id="54" destination-state-id="54" label-x="821" label-y="512">
			<path-point x="704" y="507"/>
			<path-point x="791" y="499"/>
			<path-point x="781" y="534"/>
			<path-point x="705" y="517"/>
			<attribute name="name" type="string" value="tr_321"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="58" destination-state-id="58" label-x="238" label-y="587">
			<path-point x="257" y="518"/>
			<path-point x="236" y="553"/>
			<path-point x="257" y="573"/>
			<path-point x="259" y="525"/>
			<attribute name="name" type="string" value="tr_323"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="41" destination-state-id="41" label-x="457" label-y="10">
			<path-point x="452" y="78"/>
			<path-point x="424" y="29"/>
			<path-point x="476" y="28"/>
			<path-point x="446" y="65"/>
			<attribute name="name" type="string" value="tr_327"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="56" destination-state-id="56" label-x="611" label-y="280">
			<path-point x="527" y="276"/>
			<path-point x="579" y="292"/>
			<path-point x="580" y="260"/>
			<path-point x="529" y="273"/>
			<attribute name="name" type="string" value="tr_329"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
		<transition source-state-id="56" destination-state-id="41" label-x="287" label-y="207">
			<path-point x="497" y="255"/>
			<path-point x="282" y="224"/>
			<path-point x="439" y="106"/>
			<attribute name="name" type="string" value="tr_332"/>
			<attribute name="condition" type="string" value="TRANSMISSION_CANCELED"/>
		</transition>
		<transition source-state-id="58" destination-state-id="41" label-x="112" label-y="277">
			<path-point x="261" y="501"/>
			<path-point x="105" y="262"/>
			<path-point x="205" y="155"/>
			<path-point x="440" y="97"/>
			<attribute name="name" type="string" value="tr_337"/>
			<attribute name="condition" type="string" value="TRANSMISSION_CANCELED"/>
		</transition>
		<transition source-state-id="63" destination-state-id="63" label-x="1176" label-y="93">
			<path-point x="1064" y="78"/>
			<path-point x="1137" y="88"/>
			<path-point x="1124" y="142"/>
			<path-point x="1062" y="94"/>
			<attribute name="name" type="string" value="tr_322"/>
			<attribute name="condition" type="string" value="default"/>
		</transition>
	</transitions>
	<external-sources>
<![CDATA[
ams_basetraf_supp
ams_support_v2
apptrack_support
ip_addr_v4
oms_auto_addr_support
oms_basetraf
oms_bgutil
oms_data_def
oms_dim_stat_support
oms_dist_support
oms_ext_file_support
oms_ot_support
oms_pipeline
oms_pr
oms_rr
oms_sim_attr_cache
oms_string_support
oms_sv
oms_tan
tools_fig
wlan_support
]]>
	</external-sources>
	<packet-formats>
<![CDATA[
wlan_control
wlan_mac
]]>
	</packet-formats>
	<local-statistics>
		<statistic name="Backoff Slots (slots)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of slots station needs to backoff before transmission while contenting for the medium, and the number of slots in the contention windows after station's successful transmissions.
]]>
			</description>
		</statistic>
		<statistic name="Channel Reservation (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The amount of time the channel will be 
busy (network allocation vector). 



]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Rcvd (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
received by the station in bits/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Rcvd (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack( traffic 
received by the station in packets/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Sent (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
transmitted by the station in bits/sec 

]]>
			</description>
		</statistic>
		<statistic name="Control Traffic Sent (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan control (Rts,Cts or Ack) traffic 
transmitted by the station in 
packets/sec 

]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Rcvd (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic received by the 
station in bits/sec 
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Rcvd (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic rcvd by the station 
from the network.  
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Sent (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic transmitted by the 
station in bits/sec  
]]>
			</description>
		</statistic>
		<statistic name="Data Traffic Sent (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Wlan data traffic transmitted by the 
station. 
]]>
			</description>
		</statistic>
		<statistic name="Delay (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the end to end delay of all the packets received by the wireless LAN MAC of this node and forwarded to the higher layer.

This delay includes medium access delay at the source MAC, reception of all the fragments individually, and the transfer of the frame via AP, if acccess point functionality is enabled.
]]>
			</description>
		</statistic>
		<statistic name="Dropped Data Packets (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The packets dropped in bits by the WLAN MAC due to 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.

]]>
			</description>
		</statistic>
		<statistic name="Dropped Data Packets (packets/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The packets dropped by the WLAN MAC due to 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.

]]>
			</description>
		</statistic>
		<statistic name="Hld Queue Size (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/time average" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Size of the queue that holds the frames received from higher layer until they are forwarded to the physical layer by the MAC for transmission.   



]]>
			</description>
		</statistic>
		<statistic name="Load (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Load (in bits/sec) submitted to wlan 
layer by all other higher layers in 
this node. 
]]>
			</description>
		</statistic>
		<statistic name="Load (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Load (in packets) submitted to wlan 
layer by all other higher layers in 
this node. 
]]>
			</description>
		</statistic>
		<statistic name="Media Access Delay (sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The total of queue and contention delays of data packets received by WLAN MAC from higher layer. For each packet, the delay is recorded when the packet is sent to the physical layer for the first time. 
Hence, it also includes the period for the successful RTS/CTS exchange, if this exchange is used for that packet.
]]>
			</description>
		</statistic>
		<statistic name="Retransmission Attempts (packets)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of retransmission attempts 
before the packet was successfully 
transmitted.



]]>
			</description>
		</statistic>
		<statistic name="Throughput (bits/sec)" group="Wireless Lan" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Number of bits sent to the higher layer.

]]>
			</description>
		</statistic>
	</local-statistics>
	<global-statistics>
		<statistic name="Data Dropped (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
The total size of higher layer data packets (in bits/sec) dropped by all the WLAN MACs in the network due to: 
a) the overflow of higher layer buffer, or
b) failure of all retransmissions until retry limit.
]]>
			</description>
		</statistic>
		<statistic name="Delay (sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the end to end delay of all the packets received by the wireless LAN MACs of all WLAN nodes in the network and forwarded to the higher layer. 

This delay includes medium access delay at the source MAC, reception of all the fragments individually, and transfer of the frames via AP, if acccess point functionality is enabled.
]]>
			</description>
		</statistic>
		<statistic name="Load (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the total load (in bits/sec) submitted to wireless LAN layers by all other higher layers in all WLAN nodes of the network.
]]>
			</description>
		</statistic>
		<statistic name="Media Access Delay (sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sample mean" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the global statistic for the total of queue and contention delays of data packets received by all WLAN MACs in the network from higher layer.

For each packet, the delay is recorded when the packet is sent to the physical layer for the first time. Hence, it also includes the period for the successful RTS/CTS exchange, if this exchange is used for that packet.
]]>
			</description>
		</statistic>
		<statistic name="Throughput (bits/sec)" group="Wireless LAN" dimension="0" capture-mode="bucket/default total/sum_time" display-mode="linear" low-bound="0.0" high-bound="disabled">
			<description>
<![CDATA[
Represents the total number of bits (in bits/sec) forwarded from wireless LAN layers to higher layers in all WLAN nodes of the network.
]]>
			</description>
		</statistic>
	</global-statistics>
	<comments>
<![CDATA[
General Process Description:

----------------------------

The IEEE802.11 (wireless lan) process model is a MAC layer protocol. The 
role of the wlan_mac is to accept data packets from the higher layer 
protocols, encapsulate this data into wlan frames, and to send these 
frames in first-in-first-out order to the destination station. It provides 
efficient and fair sharing of bandwidth among all the stations attached to 
the wireless lan. Collision avoidance and deference is handled by the   
individual station.  



 Packet Formats:

---------------

"wlan_mac" packet format is used to encapsulate higher layer data into 
wireless lan frames. It carries control fields such as the source and 
destination addresses and the protocol type. In addition, the frame check 
sequence and preamble components are modeled as fields of the packet.



Statistic Wires:

----------------

On input statistic 1, the wlan_mac process expects to receive a boolean 
statistic indicating whether a transmission is in progress by this 
station. This statistic wire comes from the busy statistic of the 
transmitter channel. The "rising edge trigger" should only be enabled for 
this statistic wire.



On input statistic 2, the wlan_mac process expects to receive a boolean 
statistic indicating whether a reception is in progress or a complete 
packet has been received by this station. This statistic wire comes from 
the busy statistic of the receiver channel. The "rising edge trigger"  
should only be enabled for this statistic wire.



Process Registry:

-----------------

Published Attributes: protocol, address

Expected Attributes: None



Streams:



-------

There are four input streams from the receiver to the MAC process and four 
output streams from the MAC process to the transmitter. Each of these 
streams are dedicated to a data rate (1Mbps, 2Mbps, 5.5Mbps, and 11Mbps). 
The stream numbers are hardwired to be (0,1,2,and 3). The process model 
use these stream numbers to process incoming and outgoing packets. 



]]>
	</comments>
</process-model>
